package com.example.stayops.automation;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

/**
 * Scheduled jobs for automated reservation management
 *
 * These jobs run automatically in the background to handle:
 * - Auto-cancellation of unconfirmed reservations
 * - Auto-checkout of overdue guests
 * - Auto-check-in processing
 * - Sending reminders
 * - Archiving old data
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class ReservationAutomationJob {

    private final ReservationAutomationService reservationAutomationService;

    /**
     * CRITICAL JOB: Check for unconfirmed reservations every 30 minutes
     * This ensures we catch reservations that need to be cancelled 3 hours before check-in
     */
    @Scheduled(cron = "0 */30 * * * *") // Every 30 minutes
    public void autoReleaseUnconfirmedReservations() {
        log.info("===== STARTING: Auto-release unconfirmed reservations =====");
        try {
            int cancelled = reservationAutomationService.autoReleaseUnconfirmedReservations();
            log.info("Auto-release job completed successfully. Cancelled: {}", cancelled);
        } catch (Exception e) {
            log.error("Error in auto-release unconfirmed reservations job", e);
        }
        log.info("===== COMPLETED: Auto-release unconfirmed reservations =====");
    }

    /**
     * Check for overdue checkouts every hour at minute 15
     */
    @Scheduled(cron = "0 15 * * * *") // Every hour at :15
    public void autoCheckoutOverdueReservations() {
        log.info("===== STARTING: Auto-checkout overdue reservations =====");
        try {
            int checkedOut = reservationAutomationService.autoCheckoutOverdueReservations();
            log.info("Auto-checkout job completed successfully. Checked out: {}", checkedOut);
        } catch (Exception e) {
            log.error("Error in auto-checkout overdue reservations job", e);
        }
        log.info("===== COMPLETED: Auto-checkout overdue reservations =====");
    }

    /**
     * Auto-check-in arriving guests - runs every hour after 2 PM
     * This gives flexibility for early arrivals while automating the process
     */
    @Scheduled(cron = "0 0 14-23 * * *") // Every hour from 2 PM to 11 PM
    public void autoUpdateArrivingGuests() {
        log.info("===== STARTING: Auto-update arriving guests =====");
        try {
            int updated = reservationAutomationService.autoUpdateArrivingGuests();
            log.info("Auto-update arriving guests completed successfully. Updated: {}", updated);
        } catch (Exception e) {
            log.error("Error in auto-update arriving guests job", e);
        }
        log.info("===== COMPLETED: Auto-update arriving guests =====");
    }

    /**
     * Send arrival reminders daily at 9 AM
     */
    @Scheduled(cron = "0 0 9 * * *") // 9 AM daily
    public void sendArrivalReminders() {
        log.info("===== STARTING: Send arrival reminders =====");
        try {
            int sent = reservationAutomationService.sendArrivalReminders();
            log.info("Arrival reminders job completed successfully. Reminders sent: {}", sent);
        } catch (Exception e) {
            log.error("Error in send arrival reminders job", e);
        }
        log.info("===== COMPLETED: Send arrival reminders =====");
    }

    /**
     * Archive old reservations - runs weekly on Sunday at 3 AM
     */
    @Scheduled(cron = "0 0 3 * * SUN") // 3 AM every Sunday
    public void archiveOldReservations() {
        log.info("===== STARTING: Archive old reservations =====");
        try {
            int archived = reservationAutomationService.archiveOldReservations();
            log.info("Archive old reservations job completed successfully. Archived: {}", archived);
        } catch (Exception e) {
            log.error("Error in archive old reservations job", e);
        }
        log.info("===== COMPLETED: Archive old reservations =====");
    }

    /**
     * Health check job - runs every 5 minutes to ensure automation system is alive
     */
    @Scheduled(cron = "0 */5 * * * *") // Every 5 minutes
    public void healthCheck() {
        log.debug("Reservation automation system health check - OK");
    }
}package com.example.stayops.automation;

import com.example.stayops.entity.AuditLog;
import com.example.stayops.entity.Reservation;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.event.EventPublisher;
import com.example.stayops.event.ReservationEvent;
import com.example.stayops.repository.AuditLogRepository;
import com.example.stayops.repository.ReservationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class ReservationAutomationService {

    private final ReservationRepository reservationRepository;
    private final EventPublisher eventPublisher;
    private final AuditLogRepository auditLogRepository;

    // FIXED: Added configurable time zone support
    private static final ZoneId SYSTEM_ZONE = ZoneId.systemDefault();
    private static final int DEFAULT_CHECK_IN_HOUR = 14; // 2 PM
    private static final long CONFIRMATION_DEADLINE_HOURS = 3;

    /**
     * REQUIREMENT 1: Auto-cancel reservations not confirmed 3 hours before check-in
     * FIXES:
     * - Use efficient database query instead of findAll()
     * - Corrected time calculation logic
     * - Added proper null safety
     * - Fixed inconsistent room clearing
     */
    @Transactional
    public int autoReleaseUnconfirmedReservations() {
        log.info("Running auto-release for unconfirmed reservations...");

        LocalDateTime now = LocalDateTime.now(SYSTEM_ZONE);
        LocalDateTime threeHoursFromNow = now.plusHours(CONFIRMATION_DEADLINE_HOURS);

        // FIXED: Use efficient query instead of findAll()
        // Find PENDING reservations with upcoming check-in dates
        LocalDate startDate = now.toLocalDate();
        LocalDate endDate = threeHoursFromNow.toLocalDate().plusDays(1);

        List<Reservation> pendingReservations = reservationRepository
                .findByStatusAndCheckInDateBetween(
                        ReservationStatus.PENDING,
                        startDate,
                        endDate
                );

        int cancelledCount = 0;
        for (Reservation reservation : pendingReservations) {
            // FIXED: Properly calculate check-in datetime with configurable hour
            LocalDateTime checkInDateTime = reservation.getCheckInDate()
                    .atTime(DEFAULT_CHECK_IN_HOUR, 0);

            // FIXED: Correct logic - cancel if we're within 3 hours of check-in
            long hoursUntilCheckIn = ChronoUnit.HOURS.between(now, checkInDateTime);

            if (hoursUntilCheckIn <= CONFIRMATION_DEADLINE_HOURS && hoursUntilCheckIn >= 0) {
                ReservationStatus oldStatus = reservation.getStatus();
                reservation.setStatus(ReservationStatus.CANCELLED);

                // FIXED: Consistent and safe room clearing
                clearRoomAssociations(reservation);

                reservationRepository.save(reservation);

                // Log audit
                logAudit("RESERVATION", reservation.getReservationId().toString(),
                        "AUTO_CANCEL_UNCONFIRMED", "SYSTEM", "AUTOMATION",
                        String.format("Auto-cancelled: Not confirmed %d hours before check-in",
                                CONFIRMATION_DEADLINE_HOURS));

                // Publish event
                publishReservationEvent(reservation, oldStatus, ReservationStatus.CANCELLED,
                        "AUTO_CANCELLED_UNCONFIRMED", "SYSTEM_AUTO_CANCEL_3H");

                cancelledCount++;
                log.info("Auto-cancelled reservation {} - not confirmed before {}-hour deadline (check-in: {})",
                        reservation.getReservationId(), CONFIRMATION_DEADLINE_HOURS, checkInDateTime);

                // TODO: Send notification to guest about cancellation
            }
        }

        log.info("Auto-release completed: {} reservations cancelled", cancelledCount);
        return cancelledCount;
    }

    /**
     * REQUIREMENT 2: Auto-confirm same-day reservations
     * This is called from ReservationServiceImpl during creation
     */
    public ReservationStatus determineInitialStatus(LocalDate checkInDate, ReservationStatus requestedStatus) {
        LocalDate today = LocalDate.now(SYSTEM_ZONE);

        // If check-in is today, automatically confirm (skip PENDING status)
        if (checkInDate.equals(today)) {
            log.info("Same-day reservation detected - auto-confirming");
            return ReservationStatus.CONFIRMED;
        }

        // Otherwise, use the requested status (typically PENDING)
        return requestedStatus != null ? requestedStatus : ReservationStatus.PENDING;
    }

    /**
     * ADDITIONAL AUTOMATION: Auto-checkout past-due reservations
     * FIXES:
     * - Use efficient database query
     * - Corrected date comparison logic
     */
    @Transactional
    public int autoCheckoutOverdueReservations() {
        log.info("Running auto-checkout for overdue reservations...");

        LocalDate today = LocalDate.now(SYSTEM_ZONE);

        // FIXED: Use efficient query
        List<Reservation> overdueReservations = reservationRepository
                .findByStatusInAndCheckOutDateBefore(
                        List.of(ReservationStatus.CHECKED_IN, ReservationStatus.OCCUPIED),
                        today
                );

        int checkedOutCount = 0;
        for (Reservation reservation : overdueReservations) {
            ReservationStatus oldStatus = reservation.getStatus();
            reservation.setStatus(ReservationStatus.CHECKED_OUT);
            reservationRepository.save(reservation);

            logAudit("RESERVATION", reservation.getReservationId().toString(),
                    "AUTO_CHECKOUT", "SYSTEM", "AUTOMATION",
                    "Auto-checked out: Past checkout date");

            publishReservationEvent(reservation, oldStatus, ReservationStatus.CHECKED_OUT,
                    "AUTO_CHECKED_OUT", "SYSTEM_AUTO_CHECKOUT");

            checkedOutCount++;
            log.info("Auto-checked out reservation {} - past checkout date (due: {})",
                    reservation.getReservationId(), reservation.getCheckOutDate());
        }

        log.info("Auto-checkout completed: {} reservations checked out", checkedOutCount);
        return checkedOutCount;
    }

    /**
     * ADDITIONAL AUTOMATION: Auto-transition CONFIRMED to CHECKED_IN on check-in date
     * FIXES:
     * - Use efficient database query
     * - Proper time checking
     */
    @Transactional
    public int autoUpdateArrivingGuests() {
        log.info("Running auto-update for arriving guests...");

        LocalDate today = LocalDate.now(SYSTEM_ZONE);
        LocalDateTime now = LocalDateTime.now(SYSTEM_ZONE);

        // Only process if it's past check-in time (2 PM)
        if (now.getHour() < DEFAULT_CHECK_IN_HOUR) {
            log.debug("Not yet check-in time, skipping auto-check-in");
            return 0;
        }

        // FIXED: Use efficient query
        List<Reservation> arrivingReservations = reservationRepository
                .findByStatusAndCheckInDate(ReservationStatus.CONFIRMED, today);

        int updatedCount = 0;
        for (Reservation reservation : arrivingReservations) {
            ReservationStatus oldStatus = reservation.getStatus();
            reservation.setStatus(ReservationStatus.CHECKED_IN);
            reservationRepository.save(reservation);

            logAudit("RESERVATION", reservation.getReservationId().toString(),
                    "AUTO_CHECK_IN", "SYSTEM", "AUTOMATION",
                    "Auto-checked in: Check-in date arrived");

            publishReservationEvent(reservation, oldStatus, ReservationStatus.CHECKED_IN,
                    "AUTO_CHECKED_IN", "SYSTEM_AUTO_CHECK_IN");

            updatedCount++;
            log.info("Auto-checked in reservation {} - check-in date reached",
                    reservation.getReservationId());
        }

        log.info("Auto-update arriving guests completed: {} reservations checked in", updatedCount);
        return updatedCount;
    }

    /**
     * ADDITIONAL AUTOMATION: Send reminders for upcoming arrivals
     * FIXES:
     * - Use efficient database query
     * - Better error handling
     */
    @Transactional(readOnly = true)
    public int sendArrivalReminders() {
        log.info("Sending arrival reminders...");

        LocalDate tomorrow = LocalDate.now(SYSTEM_ZONE).plusDays(1);

        // FIXED: Use efficient query
        List<Reservation> tomorrowArrivals = reservationRepository
                .findByStatusAndCheckInDate(ReservationStatus.CONFIRMED, tomorrow);

        int remindersSent = 0;
        for (Reservation reservation : tomorrowArrivals) {
            try {
                // FIXED: Added null safety for guest
                String guestEmail = (reservation.getGuest() != null && reservation.getGuest().getEmail() != null)
                        ? reservation.getGuest().getEmail()
                        : "Unknown";

                // TODO: Implement actual email/SMS sending
                log.info("Reminder: Guest {} checking in tomorrow at reservation {}",
                        guestEmail, reservation.getReservationId());

                logAudit("RESERVATION", reservation.getReservationId().toString(),
                        "REMINDER_SENT", "SYSTEM", "AUTOMATION",
                        "Sent check-in reminder for tomorrow");

                remindersSent++;
            } catch (Exception e) {
                log.error("Failed to send reminder for reservation {}: {}",
                        reservation.getReservationId(), e.getMessage());
            }
        }

        log.info("Arrival reminders sent: {}", remindersSent);
        return remindersSent;
    }

    /**
     * ADDITIONAL AUTOMATION: Clean up old cancelled/checked-out reservations
     * FIXES:
     * - Use efficient database query
     * - Configurable archive period
     */
    @Transactional
    public int archiveOldReservations() {
        return archiveOldReservations(30); // Default 30 days
    }

    @Transactional
    public int archiveOldReservations(int daysOld) {
        log.info("Archiving old reservations ({}+ days)...", daysOld);

        LocalDate cutoffDate = LocalDate.now(SYSTEM_ZONE).minusDays(daysOld);

        // FIXED: Use efficient query
        List<Reservation> oldReservations = reservationRepository
                .findByStatusInAndCheckOutDateBefore(
                        List.of(ReservationStatus.CANCELLED, ReservationStatus.CHECKED_OUT),
                        cutoffDate
                );

        int archivedCount = 0;
        for (Reservation reservation : oldReservations) {
            try {
                // In a real system, you might move to archive table or mark as archived
                logAudit("RESERVATION", reservation.getReservationId().toString(),
                        "ARCHIVED", "SYSTEM", "AUTOMATION",
                        String.format("Archived old reservation (%d+ days past checkout)", daysOld));

                archivedCount++;
            } catch (Exception e) {
                log.error("Failed to archive reservation {}: {}",
                        reservation.getReservationId(), e.getMessage());
            }
        }

        log.info("Archived {} old reservations", archivedCount);
        return archivedCount;
    }

    // FIXED: Added helper method for consistent room clearing
    private void clearRoomAssociations(Reservation reservation) {
        if (reservation.getRooms() != null && !reservation.getRooms().isEmpty()) {
            reservation.getRooms().clear();
        }
    }

    // FIXED: Added helper method to reduce duplication and ensure null safety
    private void publishReservationEvent(Reservation reservation, ReservationStatus oldStatus,
                                         ReservationStatus newStatus, String eventType, String triggeredBy) {
        try {
            String guestId = (reservation.getGuest() != null) ? reservation.getGuest().getGuestId() : null;

            eventPublisher.publishReservationEvent(ReservationEvent.builder()
                    .reservationId(reservation.getReservationId())
                    .guestId(guestId)
                    .previousStatus(oldStatus)
                    .newStatus(newStatus)
                    .eventType(eventType)
                    .eventTime(Instant.now())
                    .triggeredBy(triggeredBy)
                    .build());
        } catch (Exception e) {
            log.error("Failed to publish reservation event for {}: {}",
                    reservation.getReservationId(), e.getMessage());
        }
    }

    // Helper method with improved error handling
    private void logAudit(String entityType, String entityId, String action,
                          String actorType, String actorId, String description) {
        try {
            AuditLog auditLog = AuditLog.builder()
                    .entityType(entityType)
                    .entityId(entityId)
                    .action(action)
                    .actorType(actorType)
                    .actorId(actorId)
                    .description(description)
                    .timestamp(Instant.now())
                    .build();
            auditLogRepository.save(auditLog);
        } catch (Exception e) {
            log.error("Failed to create audit log for {} {}: {}", entityType, entityId, e.getMessage());
        }
    }
}package com.example.stayops.automation;

import com.example.stayops.config.AutomationConfig;
import com.example.stayops.entity.Reservation;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.event.EventPublisher;
import com.example.stayops.event.ReservationEvent;
import com.example.stayops.repository.ReservationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class ReservationCleanupJobs {

    private final ReservationRepository reservationRepository;
    private final EventPublisher eventPublisher;
    private final AutomationConfig config;

    // FIXED: Added time zone support
    private static final ZoneId SYSTEM_ZONE = ZoneId.systemDefault();

    /**
     * Auto-mark no-shows - Runs every hour
     * FIXES:
     * - Use efficient database query instead of findAll()
     * - Corrected grace period calculation (hours instead of days)
     * - Better null safety
     * - Improved logging
     */
    @Scheduled(cron = "0 0 * * * *") // Every hour at minute 0
    @Transactional
    public void autoMarkNoShows() {
        if (!config.isAutoMarkNoShows()) {
            log.debug("No-show automation is disabled");
            return;
        }

        log.info("Running no-show automation job");

        try {
            LocalDateTime now = LocalDateTime.now(SYSTEM_ZONE);

            // FIXED: Calculate grace period cutoff properly in hours
            LocalDateTime gracePeriodCutoff = now.minusHours(config.getNoShowGracePeriodHours());
            LocalDate checkInCutoffDate = gracePeriodCutoff.toLocalDate();

            // FIXED: Use efficient query instead of findAll()
            // Find CONFIRMED reservations with check-in date before the grace period cutoff
            List<Reservation> potentialNoShows = reservationRepository
                    .findByStatusAndCheckInDateBefore(
                            ReservationStatus.CONFIRMED,
                            checkInCutoffDate.plusDays(1) // Include today if applicable
                    );

            int markedCount = 0;
            for (Reservation reservation : potentialNoShows) {
                // FIXED: Properly calculate if grace period has passed
                // Assume standard check-in time of 2 PM if not specified
                LocalDateTime checkInDateTime = reservation.getCheckInDate().atTime(14, 0);
                LocalDateTime graceEndTime = checkInDateTime
                        .plusHours(config.getNoShowGracePeriodHours());

                // Only mark as no-show if we're past the grace period
                if (now.isAfter(graceEndTime)) {
                    ReservationStatus oldStatus = reservation.getStatus();
                    reservation.setStatus(ReservationStatus.CANCELLED);

                    // FIXED: Consistent room clearing
                    clearRoomAssociations(reservation);

                    reservationRepository.save(reservation);

                    log.info("Marked reservation {} as NO-SHOW (check-in: {}, grace period: {} hours)",
                            reservation.getReservationId(),
                            reservation.getCheckInDate(),
                            config.getNoShowGracePeriodHours());

                    // Publish event with proper null safety
                    publishReservationEvent(
                            reservation,
                            oldStatus,
                            ReservationStatus.CANCELLED,
                            "NO_SHOW",
                            "SYSTEM_AUTO_NO_SHOW"
                    );

                    markedCount++;

                    // TODO: Apply no-show charges per policy
                    // TODO: Send notification to guest
                }
            }

            log.info("No-show automation completed. Marked {} reservations as no-show", markedCount);

        } catch (Exception e) {
            log.error("Error in no-show automation: {}", e.getMessage(), e);
            // FIXED: Don't rethrow to prevent job scheduler from stopping
        }
    }

    /**
     * Auto-cancel stale PENDING reservations - Runs every 6 hours
     * FIXES:
     * - Use efficient database query
     * - Proper timestamp comparison
     * - Consistent room clearing
     * - Better error handling
     */
    @Scheduled(cron = "0 0 */6 * * *") // Every 6 hours
    @Transactional
    public void autoReleaseStaleReservations() {
        if (config.getStalePendingHours() <= 0) {
            log.debug("Stale reservation cleanup is disabled or has invalid configuration");
            return;
        }

        log.info("Running stale reservation cleanup job");

        try {
            Instant staleCutoff = Instant.now()
                    .minus(config.getStalePendingHours(), ChronoUnit.HOURS);

            // FIXED: Use efficient query instead of findAll()
            List<Reservation> staleReservations = reservationRepository
                    .findByStatusAndCreatedAtBefore(
                            ReservationStatus.PENDING,
                            staleCutoff
                    );

            int cancelledCount = 0;
            for (Reservation reservation : staleReservations) {
                try {
                    ReservationStatus oldStatus = reservation.getStatus();
                    reservation.setStatus(ReservationStatus.CANCELLED);

                    // FIXED: Consistent and safe room clearing
                    clearRoomAssociations(reservation);

                    reservationRepository.save(reservation);

                    long hoursStale = ChronoUnit.HOURS.between(reservation.getCreatedAt(), Instant.now());
                    log.info("Cancelled stale PENDING reservation {} (pending for {} hours)",
                            reservation.getReservationId(), hoursStale);

                    // Publish event with proper null safety
                    publishReservationEvent(
                            reservation,
                            oldStatus,
                            ReservationStatus.CANCELLED,
                            "STALE_CANCELLED",
                            "SYSTEM_AUTO_STALE_CLEANUP"
                    );

                    cancelledCount++;

                    // TODO: Send notification to guest about cancellation
                } catch (Exception e) {
                    log.error("Failed to cancel stale reservation {}: {}",
                            reservation.getReservationId(), e.getMessage());
                }
            }

            log.info("Stale reservation cleanup completed. Cancelled {} reservations",
                    cancelledCount);

        } catch (Exception e) {
            log.error("Error in stale reservation cleanup: {}", e.getMessage(), e);
            // FIXED: Don't rethrow to prevent job scheduler from stopping
        }
    }

    /**
     * ADDED: Comprehensive cleanup job that runs daily
     * Performs multiple cleanup operations in sequence
     */
    @Scheduled(cron = "0 0 2 * * *") // Daily at 2 AM
    @Transactional
    public void performDailyCleanup() {
        log.info("Starting daily comprehensive cleanup");

        try {
            // Clean up old audit logs if needed
            cleanupOldAuditLogs();

            // Other cleanup tasks can be added here

            log.info("Daily comprehensive cleanup completed successfully");
        } catch (Exception e) {
            log.error("Error in daily cleanup: {}", e.getMessage(), e);
        }
    }

    // FIXED: Added helper method for consistent room clearing
    private void clearRoomAssociations(Reservation reservation) {
        if (reservation.getRooms() != null && !reservation.getRooms().isEmpty()) {
            reservation.getRooms().clear();
        }
    }

    // FIXED: Added helper method to reduce duplication and ensure null safety
    private void publishReservationEvent(Reservation reservation, ReservationStatus oldStatus,
                                         ReservationStatus newStatus, String eventType,
                                         String triggeredBy) {
        try {
            String guestId = (reservation.getGuest() != null)
                    ? reservation.getGuest().getGuestId()
                    : null;

            eventPublisher.publishReservationEvent(ReservationEvent.builder()
                    .reservationId(reservation.getReservationId())
                    .guestId(guestId)
                    .previousStatus(oldStatus)
                    .newStatus(newStatus)
                    .eventType(eventType)
                    .eventTime(Instant.now())
                    .triggeredBy(triggeredBy)
                    .build());
        } catch (Exception e) {
            log.error("Failed to publish reservation event for {}: {}",
                    reservation.getReservationId(), e.getMessage());
            // Don't rethrow - event publishing failure shouldn't stop the cleanup
        }
    }

    // ADDED: Helper method for audit log cleanup
    private void cleanupOldAuditLogs() {
        // TODO: Implement if AuditLogRepository supports cleanup
        log.debug("Audit log cleanup not yet implemented");
    }
}package com.example.stayops.controller;

import com.example.stayops.dto.*;
import com.example.stayops.service.ReservationService;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/reservations")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
// Removed @CrossOrigin here as it's handled globally in SecurityConfig
public class ReservationController {

    private final ReservationService reservationService;

    // ========== RESERVATION CRUD ==========
    @PostMapping("/create")
    public ResponseEntity<ReservationResponseDTO> createReservation(@RequestBody ReservationRequestDTO dto) {
        return ResponseEntity.ok(reservationService.createReservation(dto));
    }

    @PutMapping("/update/{reservationId}")
    public ResponseEntity<ReservationResponseDTO> updateReservation(
            @PathVariable Long reservationId,
            @RequestBody ReservationRequestDTO dto) {
        return ResponseEntity.ok(reservationService.updateReservation(reservationId, dto));
    }

    @DeleteMapping("/delete/{reservationId}")
    public ResponseEntity<Void> deleteReservation(@PathVariable Long reservationId) {
        reservationService.deleteReservation(reservationId);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/get/{reservationId}")
    public ResponseEntity<ReservationResponseDTO> getReservationById(@PathVariable Long reservationId) {
        return ResponseEntity.ok(reservationService.getReservationById(reservationId));
    }

    @GetMapping("/getAll")
    public ResponseEntity<List<ReservationResponseDTO>> getAllReservations() {
        return ResponseEntity.ok(reservationService.getAllReservations());
    }

    // ========== ROOM STATUS & AVAILABILITY ==========

    @GetMapping("/room-status")
    public ResponseEntity<List<RoomStatusDTO>> getRoomStatusForDate(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {
        return ResponseEntity.ok(reservationService.getRoomStatusForDate(date));
    }

    @GetMapping("/room-status/range")
    public ResponseEntity<Map<Long, List<RoomStatusDTO>>> getRoomStatusForDateRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(reservationService.getRoomStatusForDateRange(startDate, endDate));
    }

    @GetMapping("/reservations")
    public List<Map<String, Object>> getAllRoomReservations() {
        return reservationService.getAllRoomReservationStatuses();
    }

    // ========== CALENDAR & DATE-BASED QUERIES ==========

    @GetMapping("/calendar")
    public ResponseEntity<List<ReservationSummaryDTO>> getReservationCalendar(
            @RequestParam int year,
            @RequestParam int month) {
        return ResponseEntity.ok(reservationService.getMonthlySummary(year, month));
    }

    @GetMapping("/day")
    public ResponseEntity<List<ReservationDayDetailDTO>> getReservationsByDate(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {
        return ResponseEntity.ok(reservationService.getReservationsForDate(date));
    }

    @GetMapping("/date-range")
    public ResponseEntity<List<ReservationResponseDTO>> getReservationsInDateRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(reservationService.getReservationsInDateRange(startDate, endDate));
    }

    // ========== ARRIVALS & DEPARTURES ==========

    @GetMapping("/arrivals")
    public ResponseEntity<List<ReservationResponseDTO>> getArrivals(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {
        return ResponseEntity.ok(reservationService.getArrivalsForDate(date));
    }

    @GetMapping("/departures")
    public ResponseEntity<List<ReservationResponseDTO>> getDepartures(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {
        return ResponseEntity.ok(reservationService.getDeparturesForDate(date));
    }

    @GetMapping("/daily-summary")
    public ResponseEntity<DailyOperationsSummaryDTO> getDailySummary(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {
        return ResponseEntity.ok(reservationService.getDailyOperationsSummary(date));
    }

    // ========== STATUS MANAGEMENT ==========

    @PatchMapping("/{reservationId}/status")
    public ResponseEntity<ReservationResponseDTO> updateReservationStatus(
            @PathVariable Long reservationId,
            @RequestParam String status) {
        return ResponseEntity.ok(reservationService.updateReservationStatus(reservationId, status));
    }

    @PostMapping("/{reservationId}/check-in")
    public ResponseEntity<ReservationResponseDTO> checkIn(@PathVariable Long reservationId) {
        return ResponseEntity.ok(reservationService.checkInReservation(reservationId));
    }

    @PostMapping("/{reservationId}/check-out")
    public ResponseEntity<ReservationResponseDTO> checkOut(@PathVariable Long reservationId) {
        return ResponseEntity.ok(reservationService.checkOutReservation(reservationId));
    }

    @PostMapping("/{reservationId}/cancel")
    public ResponseEntity<ReservationResponseDTO> cancel(@PathVariable Long reservationId) {
        return ResponseEntity.ok(reservationService.cancelReservation(reservationId));
    }

    // ========== GUEST & SEARCH ==========

    @GetMapping("/guest/{guestId}")
    public ResponseEntity<List<ReservationResponseDTO>> getGuestReservations(@PathVariable String guestId) {
        return ResponseEntity.ok(reservationService.getReservationsByGuestId(guestId));
    }

    @GetMapping("/search")
    public ResponseEntity<List<ReservationResponseDTO>> searchReservations(
            @RequestParam(required = false) String guestId,
            @RequestParam(required = false) String status,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate checkInDate,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate checkOutDate) {
        return ResponseEntity.ok(reservationService.searchReservations(guestId, status, checkInDate, checkOutDate));
    }

    // ========== OCCUPANCY STATS ==========

    @GetMapping("/occupancy/current")
    public ResponseEntity<OccupancyStatsDTO> getCurrentOccupancy() {
        return ResponseEntity.ok(reservationService.getCurrentOccupancyStats());
    }

    @GetMapping("/occupancy/date")
    public ResponseEntity<OccupancyStatsDTO> getOccupancyForDate(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {
        return ResponseEntity.ok(reservationService.getOccupancyStatsForDate(date));
    }
}package com.example.stayops.controller;

import com.example.stayops.dto.ReservationDetailsDTO;
import com.example.stayops.service.ReservationDetailsService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/reservation-details")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
public class ReservationDetailsController {

    private final ReservationDetailsService reservationDetailsService;

    @PostMapping("/create/{reservationId}")
    public ResponseEntity<ReservationDetailsDTO> create(@PathVariable Long reservationId,
                                                        @RequestBody ReservationDetailsDTO dto) {
        return ResponseEntity.ok(reservationDetailsService.saveReservationDetails(reservationId, dto));
    }

    @GetMapping("/get/{reservationId}")
    public ResponseEntity<ReservationDetailsDTO> get(@PathVariable Long reservationId) {
        return ResponseEntity.ok(reservationDetailsService.getReservationDetails(reservationId));
    }

    @PutMapping("/update/{reservationId}")
    public ResponseEntity<ReservationDetailsDTO> update(@PathVariable Long reservationId,
                                                        @RequestBody ReservationDetailsDTO dto) {
        return ResponseEntity.ok(reservationDetailsService.updateReservationDetails(reservationId, dto));
    }

    @DeleteMapping("/delete/{reservationId}")
    public ResponseEntity<Void> delete(@PathVariable Long reservationId) {
        reservationDetailsService.deleteReservationDetails(reservationId);
        return ResponseEntity.noContent().build();
    }
}
package com.example.stayops.controller;

import com.example.stayops.dto.ReservationHistoryDTO;
import com.example.stayops.service.ReservationHistoryService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/reservation-history")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
public class ReservationHistoryController {

    private final ReservationHistoryService reservationHistoryService;

    @PostMapping
    public ResponseEntity<ReservationHistoryDTO> recordHistory(@RequestBody ReservationHistoryDTO dto) {
        return ResponseEntity.ok(reservationHistoryService.recordHistory(dto));
    }

    @GetMapping("/{reservationId}")
    public ResponseEntity<List<ReservationHistoryDTO>> getHistory(@PathVariable Long reservationId) {
        return ResponseEntity.ok(reservationHistoryService.getHistoryByReservation(reservationId));
    }
}
package com.example.stayops.controller;

import com.example.stayops.dto.ReservationHoldRequestDTO;
import com.example.stayops.dto.ReservationHoldResponseDTO;
import com.example.stayops.service.ReservationHoldService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/holds")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
public class ReservationHoldController {

    private final ReservationHoldService holdService;

    @PostMapping("/create")
    public ResponseEntity<ReservationHoldResponseDTO> createHold(@RequestBody ReservationHoldRequestDTO request) {
        return ResponseEntity.ok(holdService.createHold(request));
    }

    @GetMapping("/{holdToken}")
    public ResponseEntity<ReservationHoldResponseDTO> getHold(@PathVariable String holdToken) {
        return ResponseEntity.ok(holdService.getHoldByToken(holdToken));
    }

    @PostMapping("/{holdToken}/convert")
    public ResponseEntity<Long> convertToReservation(@PathVariable String holdToken) {
        Long reservationId = holdService.convertHoldToReservation(holdToken);
        return ResponseEntity.ok(reservationId);
    }

    @DeleteMapping("/{holdToken}/cancel")
    public ResponseEntity<Void> cancelHold(@PathVariable String holdToken) {
        holdService.cancelHold(holdToken);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{holdToken}/extend")
    public ResponseEntity<ReservationHoldResponseDTO> extendHold(
            @PathVariable String holdToken,
            @RequestParam Integer additionalMinutes) {
        return ResponseEntity.ok(holdService.extendHold(holdToken, additionalMinutes));
    }

    @GetMapping("/guest/{guestId}")
    public ResponseEntity<List<ReservationHoldResponseDTO>> getGuestHolds(@PathVariable String guestId) {
        return ResponseEntity.ok(holdService.getActiveHoldsByGuest(guestId));
    }

    @PostMapping("/process-expired")
    public ResponseEntity<Integer> processExpiredHolds() {
        int processed = holdService.processExpiredHolds();
        return ResponseEntity.ok(processed);
    }
}package com.example.stayops.dto;

import com.example.stayops.enums.ReservationStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationDayDetailDTO {
    private Long reservationId;
    private String guestId;
    private Set<Long> roomIds;
    private LocalDate checkInDate;
    private LocalDate checkOutDate;
    private ReservationStatus status;
}
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationDetailsDTO {

    private Long id;  // Auto-generated ID
    private Long reservationId;  // Foreign key to reservation
    private Integer adults;
    private Integer kids;
    private String mealPlan;
    private String amenities;
    private String specialRequests;
    private String additionalNotes;
}package com.example.stayops.dto;

import com.example.stayops.enums.ReservationStatus;
import lombok.*;

import java.time.Instant;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationHistoryDTO {
    private Long historyId;
    private Long reservationId;
    private ReservationStatus previousStatus;
    private ReservationStatus newStatus;
    private String changedBy;
    private String notes;
    private Instant changedAt;
}
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationHoldRequestDTO {

    private String sessionId;
    private String guestId;
    private Set<Long> roomIds;
    private String roomType;  // Alternative: hold at room type level
    private Integer numberOfRooms;
    private LocalDate checkInDate;
    private LocalDate checkOutDate;
    private Integer numberOfGuests;
    private String notes;
    private Integer ttlMinutes;  // Time-to-live in minutes (default 15)
}package com.example.stayops.dto;

import com.example.stayops.enums.HoldStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.time.LocalDate;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationHoldResponseDTO {

    private Long holdId;
    private String holdToken;
    private String sessionId;
    private String guestId;
    private Set<Long> roomIds;
    private String roomType;
    private Integer numberOfRooms;
    private LocalDate checkInDate;
    private LocalDate checkOutDate;
    private HoldStatus status;
    private Instant expiresAt;
    private Long secondsRemaining;  // Calculated field
    private Instant createdAt;
}// ========== 2. ReservationRequestDTO.java (ENHANCED) ==========
package com.example.stayops.dto;

import com.example.stayops.enums.ReservationStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationRequestDTO {
    private String guestId;
    private Set<Long> roomIds;
    private LocalDate checkInDate;
    private LocalDate checkOutDate;
    private ReservationStatus status;

    // Additional fields for reservation details
    private Integer adults;
    private Integer kids;
    private String mealPlan;
    private String amenities;
    private String specialRequests;
    private String additionalNotes;
}package com.example.stayops.dto;

import com.example.stayops.enums.ReservationStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.time.LocalDate;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationResponseDTO {

    private Long reservationId;
    private String guestId;
    private Set<Long> roomIds;
    private LocalDate checkInDate;
    private LocalDate checkOutDate;
    private ReservationStatus status;
    private Instant createdAt;
    private Instant updatedAt;
}
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class ReservationStatusDTO {
    private Long roomId;
    private String roomNumber;
    private Long reservationId;
    private LocalDate checkInDate;
    private LocalDate checkOutDate;
    private String status;
}
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class ReservationSummaryDTO {
    private LocalDate date;
    private int checkIns;
    private int checkOuts;
    private int totalReservations;

    // Increment methods
    public void incrementCheckIns() {
        this.checkIns++;
    }

    public void incrementCheckOuts() {
        this.checkOuts++;
    }

    public void incrementTotalReservations() {
        this.totalReservations++;
    }
}
package com.example.stayops.entity;

import com.example.stayops.enums.ReservationStatus;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Entity
@Table(name = "reservations")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"guest", "rooms", "reservationDetails", "history", "roomBlock"})
@EqualsAndHashCode(exclude = {"guest", "rooms", "reservationDetails", "history", "roomBlock"})
@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
public class Reservation {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long reservationId;

    @Column(nullable = false)
    private LocalDate checkInDate;

    @Column(nullable = false)
    private LocalDate checkOutDate;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    @Builder.Default
    private ReservationStatus status = ReservationStatus.PENDING;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "guest_id", nullable = false)
    @JsonIgnoreProperties({"qrCodeImage"})
    private Guest guest;

    @ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(
            name = "room_reservations",
            joinColumns = @JoinColumn(name = "reservation_id"),
            inverseJoinColumns = @JoinColumn(name = "room_id")
    )
    @JsonIgnoreProperties({"reservations", "hotel"})
    @Builder.Default
    private Set<Room> rooms = new HashSet<>();

    @OneToOne(mappedBy = "reservation", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @JsonIgnoreProperties("reservation")
    private ReservationDetails reservationDetails;

    @OneToMany(mappedBy = "reservation", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @JsonIgnoreProperties("reservation")
    @Builder.Default
    private List<ReservationHistory> history = new ArrayList<>();

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_block_id")
    @JsonIgnoreProperties({"reservations", "hotel"})
    private RoomBlock roomBlock;

    @CreationTimestamp
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;

    // Helper methods for managing bidirectional relationships
    public void addRoom(Room room) {
        this.rooms.add(room);
        room.getReservations().add(this);
    }

    public void removeRoom(Room room) {
        this.rooms.remove(room);
        room.getReservations().remove(this);
    }

    public void setRoomsCollection(Set<Room> newRooms) {
        if (this.rooms != null) {
            this.rooms.forEach(room -> room.getReservations().remove(this));
        }
        this.rooms = newRooms != null ? newRooms : new HashSet<>();
        this.rooms.forEach(room -> room.getReservations().add(this));
    }
}package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "reservation_details")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "reservation")
@EqualsAndHashCode(exclude = "reservation")
public class ReservationDetails {

    @Id
    @Column(name = "reservation_id")
    private Long reservationId;  // Use reservation_id as the primary key

    @OneToOne(fetch = FetchType.LAZY)
    @MapsId  // This tells JPA to use the same value for both the PK and FK
    @JoinColumn(name = "reservation_id")
    private Reservation reservation;

    @Column(nullable = false)
    @Builder.Default
    private Integer adults = 1;

    @Column(nullable = false)
    @Builder.Default
    private Integer kids = 0;

    @Column(name = "meal_plan", length = 100)
    private String mealPlan;

    @Column(length = 500)
    private String amenities;

    @Column(name = "special_requests", length = 1000)
    private String specialRequests;

    @Column(name = "additional_notes", length = 1000)
    private String additionalNotes;

    // Ignore the room_id column if it exists in database but not needed
    @Transient
    private Long roomId;
}package com.example.stayops.entity;

import com.example.stayops.enums.ReservationStatus;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.time.Instant;

@Entity
@Table(name = "reservation_history")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationHistory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long historyId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reservation_id", nullable = false)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private Reservation reservation;

    @Enumerated(EnumType.STRING)
    private ReservationStatus previousStatus;

    @Enumerated(EnumType.STRING)
    private ReservationStatus newStatus;

    private String changedBy; // staff username/system

    @Column(length = 500)
    private String notes;

    @CreationTimestamp
    private Instant changedAt;
}
package com.example.stayops.entity;

import com.example.stayops.enums.HoldStatus;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;
import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "reservation_holds", indexes = {
        @Index(name = "idx_hold_expires_at", columnList = "expiresAt"),
        @Index(name = "idx_hold_status", columnList = "status"),
        @Index(name = "idx_hold_session", columnList = "sessionId")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"guest", "rooms"})
@EqualsAndHashCode(exclude = {"guest", "rooms"})
public class ReservationHold {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long holdId;

    @Column(nullable = false, unique = true, length = 100)
    private String holdToken;  // Idempotency token

    @Column(length = 100)
    private String sessionId;  // User session identifier

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "guest_id")
    private Guest guest;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
            name = "hold_rooms",
            joinColumns = @JoinColumn(name = "hold_id"),
            inverseJoinColumns = @JoinColumn(name = "room_id")
    )
    @Builder.Default
    private Set<Room> rooms = new HashSet<>();

    @Column(nullable = false)
    private LocalDate checkInDate;

    @Column(nullable = false)
    private LocalDate checkOutDate;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    @Builder.Default
    private HoldStatus status = HoldStatus.ACTIVE;

    @Column(nullable = false)
    private Instant expiresAt;  // TTL expiry timestamp

    @Column(length = 20)
    private String roomType;  // If hold is at room type level

    private Integer numberOfRooms;  // Number of rooms in hold

    private Integer numberOfGuests;

    @Column(length = 500)
    private String notes;

    // Link to reservation if converted
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reservation_id")
    private Reservation reservation;

    @CreationTimestamp
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;

    // Helper method to check if hold is expired
    public boolean isExpired() {
        return Instant.now().isAfter(expiresAt);
    }

    // Helper method to check if hold is active
    public boolean isActive() {
        return status == HoldStatus.ACTIVE && !isExpired();
    }
}package com.example.stayops.enums;

public enum ReservationStatus {
    PENDING,
    OCCUPIED,
    CONFIRMED,
    CHECKED_IN,
    CHECKED_OUT,
    CANCELLED
}
package com.example.stayops.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

/**
 * Event triggered when a reservation is cancelled
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationCancelledEvent {
    private Long reservationId;
    private String cancellationReason;
    private Instant eventTime;
}package com.example.stayops.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

/**
 * Event triggered when a new reservation is created
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationCreatedEvent {
    private Long reservationId;
    private String guestId;
    private LocalDate checkInDate;
    private LocalDate checkOutDate;
    private Instant eventTime;
}package com.example.stayops.event;

import com.example.stayops.enums.ReservationStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ReservationEvent {
    private Long reservationId;
    private String guestId;
    private ReservationStatus previousStatus;
    private ReservationStatus newStatus;
    private String eventType; // CREATED, CONFIRMED, CHECKED_IN, CHECKED_OUT, CANCELLED
    private Instant eventTime;
    private String triggeredBy;
}package com.example.stayops.repository;

import com.example.stayops.entity.ReservationDetails;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ReservationDetailsRepository extends JpaRepository<ReservationDetails, Long> {

    // Remove the custom query since we're using reservation_id as the primary key
    // The default findById will work now
}package com.example.stayops.repository;

import com.example.stayops.entity.ReservationHistory;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ReservationHistoryRepository extends JpaRepository<ReservationHistory, Long> {
    List<ReservationHistory> findByReservation_ReservationId(Long reservationId);
}
package com.example.stayops.repository;

import com.example.stayops.entity.ReservationHold;
import com.example.stayops.enums.HoldStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface ReservationHoldRepository extends JpaRepository<ReservationHold, Long> {

    Optional<ReservationHold> findByHoldToken(String holdToken);

    List<ReservationHold> findBySessionId(String sessionId);

    List<ReservationHold> findByStatus(HoldStatus status);

    // Find expired active holds
    @Query("SELECT h FROM ReservationHold h WHERE h.status = 'ACTIVE' AND h.expiresAt < :currentTime")
    List<ReservationHold> findExpiredActiveHolds(@Param("currentTime") Instant currentTime);

    // Find holds overlapping with a date range for a specific room
    @Query("SELECT h FROM ReservationHold h " +
            "JOIN h.rooms r " +
            "WHERE r.id = :roomId " +
            "AND h.status = 'ACTIVE' " +
            "AND h.checkInDate < :checkOutDate " +
            "AND h.checkOutDate > :checkInDate")
    List<ReservationHold> findActiveHoldsForRoom(
            @Param("roomId") Long roomId,
            @Param("checkInDate") LocalDate checkInDate,
            @Param("checkOutDate") LocalDate checkOutDate
    );

    // Find active holds by guest
    List<ReservationHold> findByGuestGuestIdAndStatus(String guestId, HoldStatus status);

    // Find holds that will expire soon (for notifications)
    @Query("SELECT h FROM ReservationHold h " +
            "WHERE h.status = 'ACTIVE' " +
            "AND h.expiresAt BETWEEN :now AND :threshold")
    List<ReservationHold> findHoldsExpiringSoon(
            @Param("now") Instant now,
            @Param("threshold") Instant threshold
    );
}package com.example.stayops.repository;

import com.example.stayops.entity.Reservation;
import com.example.stayops.enums.ReservationStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@Repository
public interface ReservationRepository extends JpaRepository<Reservation, Long> {

    // ==================== BASIC QUERIES ====================

    Optional<Reservation> findByReservationId(Long reservationId);

    /**
     * Find all reservations by status
     */
    List<Reservation> findByStatus(ReservationStatus status);

    // ==================== DATE OVERLAP QUERIES ====================

    /**
     * Find all reservations that overlap with a given date range
     * A reservation overlaps if its checkout is after or on the start date
     * AND its checkin is before or on the end date
     */
    @Query("SELECT r FROM Reservation r WHERE r.checkInDate <= :end AND r.checkOutDate >= :start")
    List<Reservation> findReservationsOverlapping(@Param("start") LocalDate start, @Param("end") LocalDate end);

    /**
     * Find overlapping reservations for a specific room
     */
    @Query("SELECT r FROM Reservation r JOIN r.rooms rm WHERE rm.id = :roomId " +
            "AND r.checkInDate <= :end AND r.checkOutDate >= :start")
    List<Reservation> findOverlappingReservationsForRoom(@Param("roomId") Long roomId,
                                                         @Param("start") LocalDate start,
                                                         @Param("end") LocalDate end);

    /**
     * Find overlapping reservations for a specific room, excluding a specific reservation
     * (useful when updating an existing reservation)
     */
    @Query("SELECT r FROM Reservation r JOIN r.rooms rm WHERE rm.id = :roomId " +
            "AND r.reservationId <> :excludeId " +
            "AND r.checkInDate <= :end AND r.checkOutDate >= :start")
    List<Reservation> findOverlappingReservationsForRoomExcludingReservation(
            @Param("roomId") Long roomId,
            @Param("excludeId") Long excludeId,
            @Param("start") LocalDate start,
            @Param("end") LocalDate end);

    // ==================== DATE-SPECIFIC QUERIES ====================

    /**
     * Find all reservations checking in on a specific date
     */
    @Query("SELECT r FROM Reservation r WHERE r.checkInDate = :date")
    List<Reservation> findByCheckInDate(@Param("date") LocalDate date);

    /**
     * Find all reservations checking out on a specific date
     */
    @Query("SELECT r FROM Reservation r WHERE r.checkOutDate = :date")
    List<Reservation> findByCheckOutDate(@Param("date") LocalDate date);

    // ==================== GUEST QUERIES ====================

    /**
     * Find all reservations for a specific guest
     */
    @Query("SELECT r FROM Reservation r WHERE r.guest.guestId = :guestId ORDER BY r.checkInDate DESC")
    List<Reservation> findByGuestGuestId(@Param("guestId") String guestId);

    // ==================== BILLING AUTOMATION QUERIES ====================

    /**
     * Find checked-in reservations for a specific date (for daily charges)
     */
    @Query("SELECT r FROM Reservation r WHERE r.status = :status " +
            "AND r.checkInDate <= :date AND r.checkOutDate > :date")
    List<Reservation> findByStatusAndCheckInDateLessThanEqualAndCheckOutDateGreaterThan(
            @Param("status") ReservationStatus status,
            @Param("date") LocalDate date,
            @Param("date") LocalDate dateAgain);

    /**
     * Find no-show candidates (confirmed reservations past check-in date)
     */
    @Query("SELECT r FROM Reservation r WHERE r.status = 'CONFIRMED' " +
            "AND r.checkInDate < CURRENT_DATE")
    List<Reservation> findNoShowCandidates();

    /**
     * Find checkouts for a specific date (for sending invoices)
     */
    @Query("SELECT r FROM Reservation r WHERE r.checkOutDate = :date " +
            "AND r.status IN ('CHECKED_IN', 'CHECKED_OUT')")
    List<Reservation> findCheckoutsForDate(@Param("date") LocalDate date);

    // ==================== ROOM STATUS QUERIES ====================

    /**
     * Get room-reservation mapping with status information
     */
    @Query("""
           SELECT new map(
               rm.id as roomId, 
               rm.roomNumber as roomNumber, 
               r.reservationId as reservationId,
               r.checkInDate as checkInDate, 
               r.checkOutDate as checkOutDate, 
               r.status as status
           )
           FROM Reservation r JOIN r.rooms rm
           """)
    List<Map<String, Object>> findAllRoomReservationStatuses();

    /**
     * Find reservations by status and check-in date range
     * Used in: ReservationAutomationService.autoReleaseUnconfirmedReservations()
     */
    List<Reservation> findByStatusAndCheckInDateBetween(
            ReservationStatus status,
            LocalDate startDate,
            LocalDate endDate
    );

    /**
     * Find reservations by multiple statuses and check-out date before a specific date
     * Used in: ReservationAutomationService.autoCheckoutOverdueReservations()
     *         ReservationAutomationService.archiveOldReservations()
     */
    List<Reservation> findByStatusInAndCheckOutDateBefore(
            List<ReservationStatus> statuses,
            LocalDate beforeDate
    );

    /**
     * Find reservations by status and specific check-in date
     * Used in: ReservationAutomationService.autoUpdateArrivingGuests()
     *         ReservationAutomationService.sendArrivalReminders()
     */
    List<Reservation> findByStatusAndCheckInDate(
            ReservationStatus status,
            LocalDate checkInDate
    );

    /**
     * Find reservations by status and check-in date before a specific date
     * Used in: ReservationCleanupJobs.autoMarkNoShows()
     */
    List<Reservation> findByStatusAndCheckInDateBefore(
            ReservationStatus status,
            LocalDate beforeDate
    );

    /**
     * Find reservations by status and creation timestamp before a specific instant
     * Used in: ReservationCleanupJobs.autoReleaseStaleReservations()
     */
    List<Reservation> findByStatusAndCreatedAtBefore(
            ReservationStatus status,
            Instant beforeInstant
    );

    /**
     * OPTIONAL: More efficient query with JOIN FETCH to avoid N+1 queries
     * Use this if you need to access guest information in the results
     */
    @Query("SELECT r FROM Reservation r LEFT JOIN FETCH r.guest " +
            "WHERE r.status = :status AND r.checkInDate = :checkInDate")
    List<Reservation> findByStatusAndCheckInDateWithGuest(
            @Param("status") ReservationStatus status,
            @Param("checkInDate") LocalDate checkInDate
    );

    /**
     * OPTIONAL: Find reservations with room assignments
     * Useful for checking which reservations have rooms assigned
     */
    @Query("SELECT r FROM Reservation r LEFT JOIN FETCH r.rooms " +
            "WHERE r.status = :status AND r.checkInDate BETWEEN :startDate AND :endDate")
    List<Reservation> findByStatusAndCheckInDateBetweenWithRooms(
            @Param("status") ReservationStatus status,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate
    );

    /**
     * OPTIONAL: Count overdue reservations (for metrics/monitoring)
     */
    @Query("SELECT COUNT(r) FROM Reservation r " +
            "WHERE r.status IN :statuses AND r.checkOutDate < :today")
    long countOverdueReservations(
            @Param("statuses") List<ReservationStatus> statuses,
            @Param("today") LocalDate today
    );

    /**
     * OPTIONAL: Find reservations that need room assignment
     */
    @Query("SELECT r FROM Reservation r " +
            "WHERE r.status = :status AND r.rooms IS EMPTY")
    List<Reservation> findByStatusWithoutRooms(
            @Param("status") ReservationStatus status
    );
}package com.example.stayops.scheduling;

import com.example.stayops.service.PaymentService;
import com.example.stayops.service.ReservationHoldService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

/**
 * Scheduled jobs for reservation system background tasks
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class ReservationScheduledJobs {

    private final ReservationHoldService holdService;
    private final PaymentService paymentService;

    /**
     * Process expired holds every 5 minutes
     */
    @Scheduled(fixedRate = 300000) // 5 minutes
    public void processExpiredHolds() {
        log.info("Running scheduled job: Process expired holds");
        try {
            int processed = holdService.processExpiredHolds();
            log.info("Processed {} expired holds", processed);
        } catch (Exception e) {
            log.error("Error processing expired holds", e);
        }
    }

    /**
     * Process timeout payments every 10 minutes
     */
    @Scheduled(fixedRate = 600000) // 10 minutes
    public void processTimeoutPayments() {
        log.info("Running scheduled job: Process timeout payments");
        try {
            int processed = paymentService.processTimeoutPayments(30); // 30 minute timeout
            log.info("Processed {} timeout payments", processed);
        } catch (Exception e) {
            log.error("Error processing timeout payments", e);
        }
    }

    /**
     * Send arrival reminders - runs at 9 AM daily
     */
    @Scheduled(cron = "0 0 9 * * *") // 9 AM daily
    public void sendArrivalReminders() {
        log.info("Running scheduled job: Send arrival reminders");
        try {
            // TODO: Implement reminder sending for arrivals in next 24-48 hours
            log.info("Arrival reminders sent");
        } catch (Exception e) {
            log.error("Error sending arrival reminders", e);
        }
    }
}package com.example.stayops.service;

import com.example.stayops.dto.ReservationDetailsDTO;

public interface ReservationDetailsService {

    ReservationDetailsDTO saveReservationDetails(Long reservationId, ReservationDetailsDTO dto);

    ReservationDetailsDTO getReservationDetails(Long reservationId);

    ReservationDetailsDTO updateReservationDetails(Long reservationId, ReservationDetailsDTO dto);

    void deleteReservationDetails(Long reservationId);
}
package com.example.stayops.service;

import com.example.stayops.dto.ReservationHistoryDTO;

import java.util.List;

public interface ReservationHistoryService {
    ReservationHistoryDTO recordHistory(ReservationHistoryDTO dto);
    List<ReservationHistoryDTO> getHistoryByReservation(Long reservationId);
}
package com.example.stayops.service;

import com.example.stayops.dto.ReservationHoldRequestDTO;
import com.example.stayops.dto.ReservationHoldResponseDTO;

import java.util.List;

public interface ReservationHoldService {

    /**
     * Create a new reservation hold with TTL
     */
    ReservationHoldResponseDTO createHold(ReservationHoldRequestDTO request);

    /**
     * Get hold by token
     */
    ReservationHoldResponseDTO getHoldByToken(String holdToken);

    /**
     * Convert hold to confirmed reservation
     */
    Long convertHoldToReservation(String holdToken);

    /**
     * Cancel/release a hold manually
     */
    void cancelHold(String holdToken);

    /**
     * Extend hold expiry time
     */
    ReservationHoldResponseDTO extendHold(String holdToken, Integer additionalMinutes);

    /**
     * Process expired holds (called by scheduler)
     */
    int processExpiredHolds();

    /**
     * Get active holds for a guest
     */
    List<ReservationHoldResponseDTO> getActiveHoldsByGuest(String guestId);
}package com.example.stayops.service;

import com.example.stayops.dto.*;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;

public interface ReservationService {

    // CRUD Operations
    ReservationResponseDTO createReservation(ReservationRequestDTO requestDTO);
    ReservationResponseDTO updateReservation(Long reservationId, ReservationRequestDTO requestDTO);
    void deleteReservation(Long reservationId);
    ReservationResponseDTO getReservationById(Long reservationId);
    List<ReservationResponseDTO> getAllReservations();

    // Calendar & Date-based
    List<ReservationSummaryDTO> getMonthlySummary(int year, int month);
    List<ReservationDayDetailDTO> getReservationsForDate(LocalDate date);
    List<ReservationResponseDTO> getReservationsInDateRange(LocalDate startDate, LocalDate endDate);

    // Room Status
    List<Map<String, Object>> getAllRoomReservationStatuses();
    List<RoomStatusDTO> getRoomStatusForDate(LocalDate date);
    Map<Long, List<RoomStatusDTO>> getRoomStatusForDateRange(LocalDate startDate, LocalDate endDate);

    // Arrivals & Departures
    List<ReservationResponseDTO> getArrivalsForDate(LocalDate date);
    List<ReservationResponseDTO> getDeparturesForDate(LocalDate date);
    DailyOperationsSummaryDTO getDailyOperationsSummary(LocalDate date);

    // Status Management
    ReservationResponseDTO updateReservationStatus(Long reservationId, String status);
    ReservationResponseDTO checkInReservation(Long reservationId);
    ReservationResponseDTO checkOutReservation(Long reservationId);
    ReservationResponseDTO cancelReservation(Long reservationId);

    // Guest & Search
    List<ReservationResponseDTO> getReservationsByGuestId(String guestId);
    List<ReservationResponseDTO> searchReservations(String guestId, String status,
                                                    LocalDate checkInDate, LocalDate checkOutDate);

    // Occupancy
    OccupancyStatsDTO getCurrentOccupancyStats();
    OccupancyStatsDTO getOccupancyStatsForDate(LocalDate date);
}package com.example.stayops.service.impl;

import com.example.stayops.dto.ReservationDetailsDTO;
import com.example.stayops.entity.Reservation;
import com.example.stayops.entity.ReservationDetails;
import com.example.stayops.repository.ReservationDetailsRepository;
import com.example.stayops.repository.ReservationRepository;
import com.example.stayops.service.ReservationDetailsService;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Slf4j
@Service
@RequiredArgsConstructor
public class ReservationDetailsServiceImpl implements ReservationDetailsService {

    private final ReservationDetailsRepository reservationDetailsRepository;
    private final ReservationRepository reservationRepository;

    @Override
    @Transactional
    public ReservationDetailsDTO saveReservationDetails(Long reservationId, ReservationDetailsDTO dto) {
        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new EntityNotFoundException("Reservation not found: " + reservationId));

        ReservationDetails existingDetails = reservationDetailsRepository.findById(reservationId).orElse(null);

        ReservationDetails details;

        if (existingDetails != null) {
            details = existingDetails;
        } else {
            details = new ReservationDetails();
            details.setReservationId(reservationId);  // Set the ID explicitly
            details.setReservation(reservation);
        }

        details.setAdults(dto.getAdults() != null ? dto.getAdults() : 1);
        details.setKids(dto.getKids() != null ? dto.getKids() : 0);
        details.setMealPlan(dto.getMealPlan());
        details.setAmenities(dto.getAmenities());
        details.setSpecialRequests(dto.getSpecialRequests());
        details.setAdditionalNotes(dto.getAdditionalNotes());

        ReservationDetails saved = reservationDetailsRepository.save(details);

        return mapToDTO(saved);
    }

    @Override
    @Transactional(readOnly = true)
    public ReservationDetailsDTO getReservationDetails(Long reservationId) {
        ReservationDetails details = reservationDetailsRepository.findById(reservationId)
                .orElseThrow(() -> new EntityNotFoundException(
                        "Reservation details not found for reservation: " + reservationId));

        return mapToDTO(details);
    }

    @Override
    @Transactional
    public ReservationDetailsDTO updateReservationDetails(Long reservationId, ReservationDetailsDTO dto) {
        ReservationDetails details = reservationDetailsRepository.findById(reservationId)
                .orElseThrow(() -> new EntityNotFoundException(
                        "Reservation details not found for reservation: " + reservationId));

        details.setAdults(dto.getAdults() != null ? dto.getAdults() : details.getAdults());
        details.setKids(dto.getKids() != null ? dto.getKids() : details.getKids());
        details.setMealPlan(dto.getMealPlan() != null ? dto.getMealPlan() : details.getMealPlan());
        details.setAmenities(dto.getAmenities() != null ? dto.getAmenities() : details.getAmenities());
        details.setSpecialRequests(dto.getSpecialRequests() != null ? dto.getSpecialRequests() : details.getSpecialRequests());
        details.setAdditionalNotes(dto.getAdditionalNotes() != null ? dto.getAdditionalNotes() : details.getAdditionalNotes());

        ReservationDetails saved = reservationDetailsRepository.save(details);

        return mapToDTO(saved);
    }

    @Override
    @Transactional
    public void deleteReservationDetails(Long reservationId) {
        if (reservationDetailsRepository.existsById(reservationId)) {
            reservationDetailsRepository.deleteById(reservationId);
        }
    }

    private ReservationDetailsDTO mapToDTO(ReservationDetails details) {
        return ReservationDetailsDTO.builder()
                .id(details.getReservationId())  // Use reservationId as the id in DTO
                .reservationId(details.getReservationId())
                .adults(details.getAdults())
                .kids(details.getKids())
                .mealPlan(details.getMealPlan())
                .amenities(details.getAmenities())
                .specialRequests(details.getSpecialRequests())
                .additionalNotes(details.getAdditionalNotes())
                .build();
    }
}
package com.example.stayops.service.impl;

import com.example.stayops.dto.ReservationHistoryDTO;
import com.example.stayops.entity.Reservation;
import com.example.stayops.entity.ReservationHistory;
import com.example.stayops.repository.ReservationHistoryRepository;
import com.example.stayops.repository.ReservationRepository;
import com.example.stayops.service.ReservationHistoryService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ReservationHistoryServiceImpl implements ReservationHistoryService {

    private final ReservationHistoryRepository historyRepository;
    private final ReservationRepository reservationRepository;

    @Override
    public ReservationHistoryDTO recordHistory(ReservationHistoryDTO dto) {
        Reservation reservation = reservationRepository.findById(dto.getReservationId())
                .orElseThrow(() -> new RuntimeException("Reservation not found"));

        ReservationHistory history = ReservationHistory.builder()
                .reservation(reservation)
                .previousStatus(dto.getPreviousStatus())
                .newStatus(dto.getNewStatus())
                .changedBy(dto.getChangedBy())
                .notes(dto.getNotes())
                .build();

        return toDTO(historyRepository.save(history));
    }

    @Override
    public List<ReservationHistoryDTO> getHistoryByReservation(Long reservationId) {
        return historyRepository.findByReservation_ReservationId(reservationId)
                .stream().map(this::toDTO).collect(Collectors.toList());
    }

    private ReservationHistoryDTO toDTO(ReservationHistory entity) {
        return ReservationHistoryDTO.builder()
                .historyId(entity.getHistoryId())
                .reservationId(entity.getReservation().getReservationId())
                .previousStatus(entity.getPreviousStatus())
                .newStatus(entity.getNewStatus())
                .changedBy(entity.getChangedBy())
                .notes(entity.getNotes())
                .changedAt(entity.getChangedAt())
                .build();
    }
}
package com.example.stayops.service.impl;

import com.example.stayops.dto.ReservationHoldRequestDTO;
import com.example.stayops.dto.ReservationHoldResponseDTO;
import com.example.stayops.dto.ReservationRequestDTO;
import com.example.stayops.entity.Guest;
import com.example.stayops.entity.ReservationHold;
import com.example.stayops.entity.Room;
import com.example.stayops.enums.HoldStatus;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.repository.GuestRepository;
import com.example.stayops.repository.ReservationHoldRepository;
import com.example.stayops.repository.ReservationRepository;
import com.example.stayops.repository.RoomRepository;
import com.example.stayops.service.ReservationHoldService;
import com.example.stayops.service.ReservationService;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class ReservationHoldServiceImpl implements ReservationHoldService {

    private final ReservationHoldRepository holdRepository;
    private final RoomRepository roomRepository;
    private final GuestRepository guestRepository;
    private final ReservationRepository reservationRepository;
    private final ReservationService reservationService;

    private static final int DEFAULT_TTL_MINUTES = 15;

    @Override
    @Transactional
    public ReservationHoldResponseDTO createHold(ReservationHoldRequestDTO request) {
        log.info("Creating reservation hold for guest: {}", request.getGuestId());

        // Validate request
        if (request.getCheckInDate() == null || request.getCheckOutDate() == null) {
            throw new IllegalArgumentException("Check-in and check-out dates are required");
        }
        if (request.getCheckOutDate().isBefore(request.getCheckInDate()) ||
                request.getCheckOutDate().equals(request.getCheckInDate())) {
            throw new IllegalArgumentException("Check-out date must be after check-in date");
        }

        // Fetch guest if provided
        Guest guest = null;
        if (request.getGuestId() != null) {
            guest = guestRepository.findById(request.getGuestId())
                    .orElseThrow(() -> new EntityNotFoundException("Guest not found: " + request.getGuestId()));
        }

        // Fetch and validate rooms
        Set<Room> rooms = new HashSet<>();
        if (request.getRoomIds() != null && !request.getRoomIds().isEmpty()) {
            List<Room> roomList = roomRepository.findAllById(request.getRoomIds());
            if (roomList.size() != request.getRoomIds().size()) {
                throw new EntityNotFoundException("Some rooms not found");
            }

            // Check room availability (considering existing holds and reservations)
            for (Room room : roomList) {
                if (!isRoomAvailable(room.getId(), request.getCheckInDate(), request.getCheckOutDate())) {
                    throw new IllegalStateException("Room " + room.getRoomNumber() +
                            " is not available for the selected dates");
                }
            }
            rooms.addAll(roomList);
        }

        // Generate hold token (idempotency key)
        String holdToken = UUID.randomUUID().toString();

        // Calculate expiry time
        int ttlMinutes = request.getTtlMinutes() != null ? request.getTtlMinutes() : DEFAULT_TTL_MINUTES;
        Instant expiresAt = Instant.now().plus(Duration.ofMinutes(ttlMinutes));

        // Create hold
        ReservationHold hold = ReservationHold.builder()
                .holdToken(holdToken)
                .sessionId(request.getSessionId())
                .guest(guest)
                .rooms(rooms)
                .checkInDate(request.getCheckInDate())
                .checkOutDate(request.getCheckOutDate())
                .status(HoldStatus.ACTIVE)
                .expiresAt(expiresAt)
                .roomType(request.getRoomType())
                .numberOfRooms(request.getNumberOfRooms())
                .numberOfGuests(request.getNumberOfGuests())
                .notes(request.getNotes())
                .build();

        ReservationHold savedHold = holdRepository.save(hold);

        log.info("Hold created successfully with token: {} (expires at: {})", holdToken, expiresAt);

        return mapToResponseDTO(savedHold);
    }

    @Override
    @Transactional(readOnly = true)
    public ReservationHoldResponseDTO getHoldByToken(String holdToken) {
        ReservationHold hold = holdRepository.findByHoldToken(holdToken)
                .orElseThrow(() -> new EntityNotFoundException("Hold not found: " + holdToken));
        return mapToResponseDTO(hold);
    }

    @Override
    @Transactional
    public Long convertHoldToReservation(String holdToken) {
        log.info("Converting hold to reservation: {}", holdToken);

        ReservationHold hold = holdRepository.findByHoldToken(holdToken)
                .orElseThrow(() -> new EntityNotFoundException("Hold not found: " + holdToken));

        // Validate hold is still active
        if (hold.getStatus() != HoldStatus.ACTIVE) {
            throw new IllegalStateException("Hold is not active: " + hold.getStatus());
        }
        if (hold.isExpired()) {
            throw new IllegalStateException("Hold has expired");
        }

        // Double-check room availability
        for (Room room : hold.getRooms()) {
            if (!isRoomAvailable(room.getId(), hold.getCheckInDate(), hold.getCheckOutDate())) {
                throw new IllegalStateException("Room " + room.getRoomNumber() +
                        " is no longer available");
            }
        }

        // Create reservation from hold
        ReservationRequestDTO reservationRequest = ReservationRequestDTO.builder()
                .guestId(hold.getGuest() != null ? hold.getGuest().getGuestId() : null)
                .roomIds(hold.getRooms().stream().map(Room::getId).collect(Collectors.toSet()))
                .checkInDate(hold.getCheckInDate())
                .checkOutDate(hold.getCheckOutDate())
                .status(ReservationStatus.PENDING)  // Start as PENDING until payment
                .build();

        var reservation = reservationService.createReservation(reservationRequest);

        // Update hold status
        hold.setStatus(HoldStatus.CONVERTED);
        holdRepository.save(hold);

        log.info("Hold {} converted to reservation {}", holdToken, reservation.getReservationId());

        return reservation.getReservationId();
    }

    @Override
    @Transactional
    public void cancelHold(String holdToken) {
        log.info("Cancelling hold: {}", holdToken);

        ReservationHold hold = holdRepository.findByHoldToken(holdToken)
                .orElseThrow(() -> new EntityNotFoundException("Hold not found: " + holdToken));

        if (hold.getStatus() != HoldStatus.ACTIVE) {
            throw new IllegalStateException("Hold is not active");
        }

        hold.setStatus(HoldStatus.CANCELLED);
        holdRepository.save(hold);

        log.info("Hold {} cancelled successfully", holdToken);
    }

    @Override
    @Transactional
    public ReservationHoldResponseDTO extendHold(String holdToken, Integer additionalMinutes) {
        log.info("Extending hold {} by {} minutes", holdToken, additionalMinutes);

        ReservationHold hold = holdRepository.findByHoldToken(holdToken)
                .orElseThrow(() -> new EntityNotFoundException("Hold not found: " + holdToken));

        if (hold.getStatus() != HoldStatus.ACTIVE) {
            throw new IllegalStateException("Hold is not active");
        }

        Instant newExpiresAt = hold.getExpiresAt().plus(Duration.ofMinutes(additionalMinutes));
        hold.setExpiresAt(newExpiresAt);

        ReservationHold updated = holdRepository.save(hold);

        log.info("Hold {} extended, new expiry: {}", holdToken, newExpiresAt);

        return mapToResponseDTO(updated);
    }

    @Override
    @Transactional
    public int processExpiredHolds() {
        log.info("Processing expired holds...");

        List<ReservationHold> expiredHolds = holdRepository.findExpiredActiveHolds(Instant.now());

        for (ReservationHold hold : expiredHolds) {
            hold.setStatus(HoldStatus.EXPIRED);
            log.info("Expired hold: {} (token: {})", hold.getHoldId(), hold.getHoldToken());
        }

        holdRepository.saveAll(expiredHolds);

        log.info("Processed {} expired holds", expiredHolds.size());
        return expiredHolds.size();
    }

    @Override
    @Transactional(readOnly = true)
    public List<ReservationHoldResponseDTO> getActiveHoldsByGuest(String guestId) {
        List<ReservationHold> holds = holdRepository.findByGuestGuestIdAndStatus(guestId, HoldStatus.ACTIVE);
        return holds.stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    // Helper methods

    private boolean isRoomAvailable(Long roomId, java.time.LocalDate checkIn, java.time.LocalDate checkOut) {
        // Check for overlapping active holds
        List<ReservationHold> conflictingHolds = holdRepository.findActiveHoldsForRoom(
                roomId, checkIn, checkOut);

        if (!conflictingHolds.isEmpty()) {
            return false;
        }

        // Check for overlapping reservations
        var conflictingReservations = reservationRepository
                .findOverlappingReservationsForRoom(roomId, checkIn, checkOut);

        boolean hasActiveReservation = conflictingReservations.stream()
                .anyMatch(r -> r.getStatus() != ReservationStatus.CANCELLED &&
                        r.getStatus() != ReservationStatus.CHECKED_OUT);

        return !hasActiveReservation;
    }

    private ReservationHoldResponseDTO mapToResponseDTO(ReservationHold hold) {
        long secondsRemaining = 0;
        if (hold.getStatus() == HoldStatus.ACTIVE) {
            Duration remaining = Duration.between(Instant.now(), hold.getExpiresAt());
            secondsRemaining = Math.max(0, remaining.getSeconds());
        }

        return ReservationHoldResponseDTO.builder()
                .holdId(hold.getHoldId())
                .holdToken(hold.getHoldToken())
                .sessionId(hold.getSessionId())
                .guestId(hold.getGuest() != null ? hold.getGuest().getGuestId() : null)
                .roomIds(hold.getRooms() != null
                        ? hold.getRooms().stream().map(Room::getId).collect(Collectors.toSet())
                        : Collections.emptySet())
                .roomType(hold.getRoomType())
                .numberOfRooms(hold.getNumberOfRooms())
                .checkInDate(hold.getCheckInDate())
                .checkOutDate(hold.getCheckOutDate())
                .status(hold.getStatus())
                .expiresAt(hold.getExpiresAt())
                .secondsRemaining(secondsRemaining)
                .createdAt(hold.getCreatedAt())
                .build();
    }
}package com.example.stayops.service.impl;

import com.example.stayops.dto.*;
import com.example.stayops.entity.Guest;
import com.example.stayops.entity.Reservation;
import com.example.stayops.entity.ReservationDetails;
import com.example.stayops.entity.ReservationHistory;
import com.example.stayops.entity.Room;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.exception.ResourceNotFoundException;
import com.example.stayops.exception.ValidationException;
import com.example.stayops.repository.GuestRepository;
import com.example.stayops.repository.ReservationDetailsRepository;
import com.example.stayops.repository.ReservationHistoryRepository;
import com.example.stayops.repository.ReservationRepository;
import com.example.stayops.repository.RoomRepository;
import com.example.stayops.service.ReservationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.time.LocalDate;
import java.time.YearMonth;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional
public class ReservationServiceImpl implements ReservationService {

    private final ReservationRepository reservationRepository;
    private final GuestRepository guestRepository;
    private final RoomRepository roomRepository;
    private final ReservationDetailsRepository reservationDetailsRepository;
    private final ReservationHistoryRepository reservationHistoryRepository;

    // ==================== CRUD OPERATIONS ====================

    @Override
    public ReservationResponseDTO createReservation(ReservationRequestDTO requestDTO) {
        log.info("Creating new reservation for guest: {}", requestDTO.getGuestId());

        // Validate dates
        validateDates(requestDTO.getCheckInDate(), requestDTO.getCheckOutDate());

        // Find guest
        Guest guest = guestRepository.findByGuestId(requestDTO.getGuestId())
                .orElseThrow(() -> new ResourceNotFoundException("Guest not found with ID: " + requestDTO.getGuestId()));

        // Find and validate rooms
        List<Room> rooms = validateAndGetRooms(requestDTO.getRoomIds());

        // Check room availability
        checkRoomAvailability(rooms, requestDTO.getCheckInDate(), requestDTO.getCheckOutDate(), null);

        // Create reservation
        Reservation reservation = new Reservation();
        reservation.setGuest(guest);

        // Use the proper method to set rooms with bidirectional relationship
        reservation.setRooms(new HashSet<>(rooms));

        reservation.setCheckInDate(requestDTO.getCheckInDate());
        reservation.setCheckOutDate(requestDTO.getCheckOutDate());

        // Use status from DTO if provided, otherwise default to CONFIRMED
        if (requestDTO.getStatus() != null) {
            reservation.setStatus(requestDTO.getStatus());
        } else {
            reservation.setStatus(ReservationStatus.CONFIRMED);
        }

        // Save reservation first to get the ID
        Reservation savedReservation = reservationRepository.save(reservation);

        // Create reservation details
        createReservationDetails(savedReservation, requestDTO);

        // Add history entry
        addHistoryEntry(savedReservation, "Reservation created", null, savedReservation.getStatus());

        log.info("Reservation created successfully with ID: {}", savedReservation.getReservationId());
        return mapToResponseDTO(savedReservation);
    }

    @Override
    public ReservationResponseDTO updateReservation(Long reservationId, ReservationRequestDTO requestDTO) {
        log.info("Updating reservation: {}", reservationId);

        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new ResourceNotFoundException("Reservation not found with ID: " + reservationId));

        // Validate dates
        validateDates(requestDTO.getCheckInDate(), requestDTO.getCheckOutDate());

        // Find and validate rooms
        List<Room> rooms = validateAndGetRooms(requestDTO.getRoomIds());

        // Check room availability (excluding current reservation)
        checkRoomAvailability(rooms, requestDTO.getCheckInDate(), requestDTO.getCheckOutDate(), reservationId);

        // Update reservation fields
        ReservationStatus oldStatus = reservation.getStatus();

        // Update rooms collection
        reservation.setRooms(new HashSet<>(rooms));

        reservation.setCheckInDate(requestDTO.getCheckInDate());
        reservation.setCheckOutDate(requestDTO.getCheckOutDate());

        // Update status if provided
        if (requestDTO.getStatus() != null) {
            reservation.setStatus(requestDTO.getStatus());
        }

        // Save updated reservation
        Reservation updatedReservation = reservationRepository.save(reservation);

        // Update reservation details
        updateReservationDetails(updatedReservation, requestDTO);

        // Add history entry
        addHistoryEntry(updatedReservation, "Reservation updated", oldStatus, reservation.getStatus());

        log.info("Reservation updated successfully: {}", reservationId);
        return mapToResponseDTO(updatedReservation);
    }

    @Override
    public void deleteReservation(Long reservationId) {
        log.info("Deleting reservation: {}", reservationId);

        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new ResourceNotFoundException("Reservation not found with ID: " + reservationId));

        reservationRepository.delete(reservation);
        log.info("Reservation deleted successfully: {}", reservationId);
    }

    @Override
    public ReservationResponseDTO getReservationById(Long reservationId) {
        log.info("Fetching reservation: {}", reservationId);

        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new ResourceNotFoundException("Reservation not found with ID: " + reservationId));

        return mapToResponseDTO(reservation);
    }

    @Override
    public List<ReservationResponseDTO> getAllReservations() {
        log.info("Fetching all reservations");

        List<Reservation> reservations = reservationRepository.findAll();
        return reservations.stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    // ==================== CALENDAR & DATE-BASED ====================

    @Override
    public List<ReservationSummaryDTO> getMonthlySummary(int year, int month) {
        log.info("Fetching monthly summary for {}-{}", year, month);

        YearMonth yearMonth = YearMonth.of(year, month);
        LocalDate startDate = yearMonth.atDay(1);
        LocalDate endDate = yearMonth.atEndOfMonth();

        Map<LocalDate, ReservationSummaryDTO> summaryMap = new LinkedHashMap<>();

        // Initialize all days in the month
        LocalDate currentDate = startDate;
        while (!currentDate.isAfter(endDate)) {
            ReservationSummaryDTO summary = ReservationSummaryDTO.builder()
                    .date(currentDate)
                    .checkIns(0)
                    .checkOuts(0)
                    .totalReservations(0)
                    .build();
            summaryMap.put(currentDate, summary);
            currentDate = currentDate.plusDays(1);
        }

        // Get all reservations for the month
        List<Reservation> reservations = reservationRepository.findReservationsOverlapping(startDate, endDate);

        // Count check-ins, check-outs, and total reservations per day
        for (Reservation reservation : reservations) {
            // Count check-ins
            if (!reservation.getCheckInDate().isBefore(startDate) &&
                    !reservation.getCheckInDate().isAfter(endDate)) {
                ReservationSummaryDTO summary = summaryMap.get(reservation.getCheckInDate());
                if (summary != null) {
                    summary.incrementCheckIns();
                }
            }

            // Count check-outs
            if (!reservation.getCheckOutDate().isBefore(startDate) &&
                    !reservation.getCheckOutDate().isAfter(endDate)) {
                ReservationSummaryDTO summary = summaryMap.get(reservation.getCheckOutDate());
                if (summary != null) {
                    summary.incrementCheckOuts();
                }
            }

            // Count total reservations for each day
            currentDate = startDate;
            while (!currentDate.isAfter(endDate)) {
                if (!currentDate.isBefore(reservation.getCheckInDate()) &&
                        currentDate.isBefore(reservation.getCheckOutDate())) {
                    ReservationSummaryDTO summary = summaryMap.get(currentDate);
                    if (summary != null) {
                        summary.incrementTotalReservations();
                    }
                }
                currentDate = currentDate.plusDays(1);
            }
        }

        return new ArrayList<>(summaryMap.values());
    }

    @Override
    public List<ReservationDayDetailDTO> getReservationsForDate(LocalDate date) {
        log.info("Fetching reservations for date: {}", date);

        List<Reservation> reservations = reservationRepository.findReservationsOverlapping(date, date);
        return reservations.stream()
                .map(this::mapToDayDetailDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<ReservationResponseDTO> getReservationsInDateRange(LocalDate startDate, LocalDate endDate) {
        log.info("Fetching reservations in date range: {} to {}", startDate, endDate);

        validateDates(startDate, endDate);

        List<Reservation> reservations = reservationRepository.findReservationsOverlapping(startDate, endDate);
        return reservations.stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    // ==================== ROOM STATUS ====================

    @Override
    public List<Map<String, Object>> getAllRoomReservationStatuses() {
        log.info("Fetching all room reservation statuses");
        return reservationRepository.findAllRoomReservationStatuses();
    }

    @Override
    public List<RoomStatusDTO> getRoomStatusForDate(LocalDate date) {
        log.info("Fetching room status for date: {}", date);

        List<Room> allRooms = roomRepository.findAll();
        List<Reservation> reservations = reservationRepository.findReservationsOverlapping(date, date);

        return allRooms.stream()
                .map(room -> buildRoomStatusDTO(room, reservations, date))
                .collect(Collectors.toList());
    }

    @Override
    public Map<Long, List<RoomStatusDTO>> getRoomStatusForDateRange(LocalDate startDate, LocalDate endDate) {
        log.info("Fetching room status for date range: {} to {}", startDate, endDate);

        validateDates(startDate, endDate);

        Map<Long, List<RoomStatusDTO>> roomStatusMap = new LinkedHashMap<>();
        List<Room> allRooms = roomRepository.findAll();

        // Initialize map with all rooms
        for (Room room : allRooms) {
            roomStatusMap.put(room.getId(), new ArrayList<>());
        }

        // Iterate through each date in the range
        LocalDate currentDate = startDate;
        while (!currentDate.isAfter(endDate)) {
            List<Reservation> reservations = reservationRepository.findReservationsOverlapping(currentDate, currentDate);

            for (Room room : allRooms) {
                RoomStatusDTO statusDTO = buildRoomStatusDTO(room, reservations, currentDate);
                roomStatusMap.get(room.getId()).add(statusDTO);
            }

            currentDate = currentDate.plusDays(1);
        }

        return roomStatusMap;
    }

    // ==================== ARRIVALS & DEPARTURES ====================

    @Override
    public List<ReservationResponseDTO> getArrivalsForDate(LocalDate date) {
        log.info("Fetching arrivals for date: {}", date);

        List<Reservation> reservations = reservationRepository.findByCheckInDate(date);
        return reservations.stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<ReservationResponseDTO> getDeparturesForDate(LocalDate date) {
        log.info("Fetching departures for date: {}", date);

        List<Reservation> reservations = reservationRepository.findByCheckOutDate(date);
        return reservations.stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    public DailyOperationsSummaryDTO getDailyOperationsSummary(LocalDate date) {
        log.info("Fetching daily operations summary for date: {}", date);

        // Get all rooms
        List<Room> allRooms = roomRepository.findAll();
        int totalRooms = allRooms.size();

        // Get reservations for the date
        List<Reservation> reservations = reservationRepository.findReservationsOverlapping(date, date);

        // Count occupied rooms (only confirmed and checked-in reservations)
        Set<Long> occupiedRoomIds = new HashSet<>();
        int inHouseGuests = 0;

        for (Reservation reservation : reservations) {
            if (reservation.getStatus() == ReservationStatus.CONFIRMED ||
                    reservation.getStatus() == ReservationStatus.CHECKED_IN) {
                if (reservation.getRooms() != null) {
                    for (Room room : reservation.getRooms()) {
                        occupiedRoomIds.add(room.getId());
                    }
                }
                // Count guests from reservation details
                if (reservation.getReservationDetails() != null) {
                    ReservationDetails details = reservation.getReservationDetails();
                    inHouseGuests += (details.getAdults() != null ? details.getAdults() : 0) +
                            (details.getKids() != null ? details.getKids() : 0);
                }
            }
        }

        int occupiedRooms = occupiedRoomIds.size();
        int availableRooms = totalRooms - occupiedRooms;
        double occupancyRate = totalRooms > 0 ? (double) occupiedRooms / totalRooms * 100 : 0.0;

        // Count arrivals and departures
        int expectedArrivals = (int) reservations.stream()
                .filter(r -> r.getCheckInDate().equals(date))
                .count();

        int expectedDepartures = (int) reservations.stream()
                .filter(r -> r.getCheckOutDate().equals(date))
                .count();

        // Count pending and confirmed reservations
        int pendingReservations = (int) reservations.stream()
                .filter(r -> r.getStatus() == ReservationStatus.PENDING)
                .count();

        int confirmedReservations = (int) reservations.stream()
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED)
                .count();

        DailyOperationsSummaryDTO summary = new DailyOperationsSummaryDTO();
        summary.setDate(date);
        summary.setTotalRooms(totalRooms);
        summary.setOccupiedRooms(occupiedRooms);
        summary.setAvailableRooms(availableRooms);
        summary.setExpectedArrivals(expectedArrivals);
        summary.setExpectedDepartures(expectedDepartures);
        summary.setInHouseGuests(inHouseGuests);
        summary.setOccupancyRate(Math.round(occupancyRate * 100.0) / 100.0);
        summary.setPendingReservations(pendingReservations);
        summary.setConfirmedReservations(confirmedReservations);

        return summary;
    }

    // ==================== STATUS MANAGEMENT ====================

    @Override
    public ReservationResponseDTO updateReservationStatus(Long reservationId, String status) {
        log.info("Updating reservation status: {} to {}", reservationId, status);

        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new ResourceNotFoundException("Reservation not found with ID: " + reservationId));

        ReservationStatus oldStatus = reservation.getStatus();
        ReservationStatus newStatus;

        try {
            newStatus = ReservationStatus.valueOf(status.toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new ValidationException("Invalid reservation status: " + status);
        }

        reservation.setStatus(newStatus);

        Reservation updatedReservation = reservationRepository.save(reservation);

        // Add history entry
        addHistoryEntry(updatedReservation, "Status changed to " + newStatus, oldStatus, newStatus);

        return mapToResponseDTO(updatedReservation);
    }

    @Override
    public ReservationResponseDTO checkInReservation(Long reservationId) {
        log.info("Checking in reservation: {}", reservationId);

        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new ResourceNotFoundException("Reservation not found with ID: " + reservationId));

        if (reservation.getStatus() != ReservationStatus.CONFIRMED) {
            throw new ValidationException("Only confirmed reservations can be checked in. Current status: " + reservation.getStatus());
        }

        ReservationStatus oldStatus = reservation.getStatus();
        reservation.setStatus(ReservationStatus.CHECKED_IN);

        Reservation updatedReservation = reservationRepository.save(reservation);

        // Add history entry
        addHistoryEntry(updatedReservation, "Guest checked in", oldStatus, ReservationStatus.CHECKED_IN);

        return mapToResponseDTO(updatedReservation);
    }

    @Override
    public ReservationResponseDTO checkOutReservation(Long reservationId) {
        log.info("Checking out reservation: {}", reservationId);

        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new ResourceNotFoundException("Reservation not found with ID: " + reservationId));

        if (reservation.getStatus() != ReservationStatus.CHECKED_IN) {
            throw new ValidationException("Only checked-in reservations can be checked out. Current status: " + reservation.getStatus());
        }

        ReservationStatus oldStatus = reservation.getStatus();
        reservation.setStatus(ReservationStatus.CHECKED_OUT);

        Reservation updatedReservation = reservationRepository.save(reservation);

        // Add history entry
        addHistoryEntry(updatedReservation, "Guest checked out", oldStatus, ReservationStatus.CHECKED_OUT);

        return mapToResponseDTO(updatedReservation);
    }

    @Override
    public ReservationResponseDTO cancelReservation(Long reservationId) {
        log.info("Cancelling reservation: {}", reservationId);

        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new ResourceNotFoundException("Reservation not found with ID: " + reservationId));

        if (reservation.getStatus() == ReservationStatus.CHECKED_OUT) {
            throw new ValidationException("Cannot cancel a checked-out reservation");
        }

        if (reservation.getStatus() == ReservationStatus.CANCELLED) {
            throw new ValidationException("Reservation is already cancelled");
        }

        ReservationStatus oldStatus = reservation.getStatus();
        reservation.setStatus(ReservationStatus.CANCELLED);

        Reservation updatedReservation = reservationRepository.save(reservation);

        // Add history entry
        addHistoryEntry(updatedReservation, "Reservation cancelled", oldStatus, ReservationStatus.CANCELLED);

        return mapToResponseDTO(updatedReservation);
    }

    // ==================== GUEST & SEARCH ====================

    @Override
    public List<ReservationResponseDTO> getReservationsByGuestId(String guestId) {
        log.info("Fetching reservations for guest: {}", guestId);

        List<Reservation> reservations = reservationRepository.findByGuestGuestId(guestId);
        return reservations.stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<ReservationResponseDTO> searchReservations(String guestId, String status, LocalDate checkInDate, LocalDate checkOutDate) {
        log.info("Searching reservations with filters - guestId: {}, status: {}, checkIn: {}, checkOut: {}",
                guestId, status, checkInDate, checkOutDate);

        List<Reservation> reservations = reservationRepository.findAll();

        return reservations.stream()
                .filter(r -> guestId == null || guestId.trim().isEmpty() ||
                        (r.getGuest() != null && r.getGuest().getGuestId().equals(guestId)))
                .filter(r -> status == null || status.trim().isEmpty() ||
                        r.getStatus().name().equalsIgnoreCase(status))
                .filter(r -> checkInDate == null || !r.getCheckInDate().isBefore(checkInDate))
                .filter(r -> checkOutDate == null || !r.getCheckOutDate().isAfter(checkOutDate))
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    // ==================== OCCUPANCY ====================

    @Override
    public OccupancyStatsDTO getCurrentOccupancyStats() {
        log.info("Fetching current occupancy stats");
        return getOccupancyStatsForDate(LocalDate.now());
    }

    @Override
    public OccupancyStatsDTO getOccupancyStatsForDate(LocalDate date) {
        log.info("Fetching occupancy stats for date: {}", date);

        // Get all rooms
        List<Room> allRooms = roomRepository.findAll();
        int totalRooms = allRooms.size();

        if (totalRooms == 0) {
            OccupancyStatsDTO stats = new OccupancyStatsDTO();
            stats.setDate(date);
            stats.setTotalRooms(0);
            stats.setOccupiedRooms(0);
            stats.setAvailableRooms(0);
            stats.setReservedRooms(0);
            stats.setOccupancyRate(0.0);
            stats.setTotalGuests(0);
            return stats;
        }

        // Get reservations for the date
        List<Reservation> reservations = reservationRepository.findReservationsOverlapping(date, date);

        // Count occupied rooms (only confirmed and checked-in reservations)
        Set<Long> occupiedRoomIds = new HashSet<>();
        Set<Long> reservedRoomIds = new HashSet<>();
        int totalGuests = 0;

        for (Reservation reservation : reservations) {
            if (reservation.getStatus() == ReservationStatus.CHECKED_IN) {
                if (reservation.getRooms() != null) {
                    for (Room room : reservation.getRooms()) {
                        occupiedRoomIds.add(room.getId());
                    }
                }
                // Count guests
                if (reservation.getReservationDetails() != null) {
                    ReservationDetails details = reservation.getReservationDetails();
                    totalGuests += (details.getAdults() != null ? details.getAdults() : 0) +
                            (details.getKids() != null ? details.getKids() : 0);
                }
            } else if (reservation.getStatus() == ReservationStatus.CONFIRMED) {
                if (reservation.getRooms() != null) {
                    for (Room room : reservation.getRooms()) {
                        reservedRoomIds.add(room.getId());
                    }
                }
            }
        }

        int occupiedRooms = occupiedRoomIds.size();
        int reservedRooms = reservedRoomIds.size();
        int availableRooms = totalRooms - occupiedRooms - reservedRooms;
        double occupancyRate = (double) occupiedRooms / totalRooms * 100;

        OccupancyStatsDTO stats = new OccupancyStatsDTO();
        stats.setDate(date);
        stats.setTotalRooms(totalRooms);
        stats.setOccupiedRooms(occupiedRooms);
        stats.setAvailableRooms(availableRooms);
        stats.setReservedRooms(reservedRooms);
        stats.setOccupancyRate(Math.round(occupancyRate * 100.0) / 100.0);
        stats.setTotalGuests(totalGuests);

        return stats;
    }

    // ==================== HELPER METHODS ====================

    private void validateDates(LocalDate checkInDate, LocalDate checkOutDate) {
        if (checkInDate == null || checkOutDate == null) {
            throw new ValidationException("Check-in and check-out dates are required");
        }
        if (checkOutDate.isBefore(checkInDate) || checkOutDate.equals(checkInDate)) {
            throw new ValidationException("Check-out date must be after check-in date");
        }
    }

    private List<Room> validateAndGetRooms(Set<Long> roomIds) {
        if (roomIds == null || roomIds.isEmpty()) {
            throw new ValidationException("At least one room must be selected");
        }

        List<Room> rooms = roomRepository.findAllById(roomIds);
        if (rooms.size() != roomIds.size()) {
            throw new ResourceNotFoundException("One or more rooms not found");
        }

        return rooms;
    }

    private void checkRoomAvailability(List<Room> rooms, LocalDate checkInDate,
                                       LocalDate checkOutDate, Long excludeReservationId) {
        for (Room room : rooms) {
            List<Reservation> overlappingReservations;

            if (excludeReservationId != null) {
                overlappingReservations = reservationRepository
                        .findOverlappingReservationsForRoomExcludingReservation(
                                room.getId(), excludeReservationId, checkInDate, checkOutDate);
            } else {
                overlappingReservations = reservationRepository
                        .findOverlappingReservationsForRoom(room.getId(), checkInDate, checkOutDate);
            }

            // Filter out cancelled reservations
            overlappingReservations = overlappingReservations.stream()
                    .filter(r -> r.getStatus() != ReservationStatus.CANCELLED)
                    .collect(Collectors.toList());

            if (!overlappingReservations.isEmpty()) {
                throw new ValidationException("Room " + room.getRoomNumber() +
                        " is not available for the selected dates");
            }
        }
    }

    private void createReservationDetails(Reservation reservation, ReservationRequestDTO requestDTO) {
        try {
            ReservationDetails details = new ReservationDetails();
            details.setReservationId(reservation.getReservationId());
            details.setReservation(reservation);

            // Set the fields matching ReservationRequestDTO
            if (requestDTO.getAdults() != null) {
                details.setAdults(requestDTO.getAdults());
            }
            if (requestDTO.getKids() != null) {
                details.setKids(requestDTO.getKids());
            }
            if (requestDTO.getMealPlan() != null) {
                details.setMealPlan(requestDTO.getMealPlan());
            }
            if (requestDTO.getAmenities() != null) {
                details.setAmenities(requestDTO.getAmenities());
            }
            if (requestDTO.getSpecialRequests() != null) {
                details.setSpecialRequests(requestDTO.getSpecialRequests());
            }
            if (requestDTO.getAdditionalNotes() != null) {
                details.setAdditionalNotes(requestDTO.getAdditionalNotes());
            }

            reservationDetailsRepository.save(details);
        } catch (Exception e) {
            log.error("Error creating reservation details: {}", e.getMessage(), e);
            // Don't throw exception - reservation details are supplementary
        }
    }

    private void updateReservationDetails(Reservation reservation, ReservationRequestDTO requestDTO) {
        try {
            ReservationDetails details = reservationDetailsRepository.findById(reservation.getReservationId())
                    .orElseGet(() -> {
                        ReservationDetails newDetails = new ReservationDetails();
                        newDetails.setReservationId(reservation.getReservationId());
                        newDetails.setReservation(reservation);
                        return newDetails;
                    });

            // Update the fields matching ReservationRequestDTO
            if (requestDTO.getAdults() != null) {
                details.setAdults(requestDTO.getAdults());
            }
            if (requestDTO.getKids() != null) {
                details.setKids(requestDTO.getKids());
            }
            if (requestDTO.getMealPlan() != null) {
                details.setMealPlan(requestDTO.getMealPlan());
            }
            if (requestDTO.getAmenities() != null) {
                details.setAmenities(requestDTO.getAmenities());
            }
            if (requestDTO.getSpecialRequests() != null) {
                details.setSpecialRequests(requestDTO.getSpecialRequests());
            }
            if (requestDTO.getAdditionalNotes() != null) {
                details.setAdditionalNotes(requestDTO.getAdditionalNotes());
            }

            reservationDetailsRepository.save(details);
        } catch (Exception e) {
            log.error("Error updating reservation details: {}", e.getMessage(), e);
            // Don't throw exception - reservation details are supplementary
        }
    }

    private void addHistoryEntry(Reservation reservation, String changeDescription,
                                 ReservationStatus oldStatus, ReservationStatus newStatus) {
        try {
            ReservationHistory history = new ReservationHistory();
            history.setReservation(reservation);
            history.setNotes(changeDescription);
            history.setPreviousStatus(oldStatus);
            history.setNewStatus(newStatus);
            history.setChangedBy("SYSTEM"); // TODO: Get actual user from security context

            reservationHistoryRepository.save(history);
        } catch (Exception e) {
            log.error("Error adding history entry: {}", e.getMessage(), e);
            // Don't throw exception - history is supplementary
        }
    }

    private RoomStatusDTO buildRoomStatusDTO(Room room, List<Reservation> reservations, LocalDate date) {
        RoomStatusDTO dto = new RoomStatusDTO();
        dto.setRoomId(room.getId());
        dto.setRoomNumber(room.getRoomNumber());
        dto.setDate(date);

        // Room.type is a String, not an enum
        dto.setRoomType(room.getType() != null ? room.getType() : "UNKNOWN");

        // Find if room has a reservation for this date
        Optional<Reservation> activeReservation = reservations.stream()
                .filter(r -> r.getRooms() != null && r.getRooms().stream().anyMatch(rm -> rm.getId().equals(room.getId())))
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED ||
                        r.getStatus() == ReservationStatus.CHECKED_IN)
                .findFirst();

        if (activeReservation.isPresent()) {
            Reservation reservation = activeReservation.get();
            dto.setStatus("OCCUPIED");
            dto.setReservationId(reservation.getReservationId());
            dto.setReservationStatus(reservation.getStatus().name());

            Guest guest = reservation.getGuest();
            if (guest != null) {
                dto.setGuestId(guest.getGuestId());
                String firstName = guest.getFirstName() != null ? guest.getFirstName() : "";
                String lastName = guest.getLastName() != null ? guest.getLastName() : "";
                dto.setGuestName((firstName + " " + lastName).trim());
            } else {
                dto.setGuestId(null);
                dto.setGuestName("Unknown Guest");
            }

            dto.setCheckInDate(reservation.getCheckInDate());
            dto.setCheckOutDate(reservation.getCheckOutDate());
        } else {
            dto.setStatus("AVAILABLE");
            dto.setReservationId(null);
            dto.setReservationStatus(null);
            dto.setGuestId(null);
            dto.setGuestName(null);
            dto.setCheckInDate(null);
            dto.setCheckOutDate(null);
        }

        return dto;
    }

    private ReservationResponseDTO mapToResponseDTO(Reservation reservation) {
        ReservationResponseDTO dto = new ReservationResponseDTO();
        dto.setReservationId(reservation.getReservationId());

        // Set guestId
        Guest guest = reservation.getGuest();
        if (guest != null) {
            dto.setGuestId(guest.getGuestId());
        } else {
            dto.setGuestId(null);
        }

        // Convert Set<Room> to Set<Long> for roomIds
        if (reservation.getRooms() != null && !reservation.getRooms().isEmpty()) {
            Set<Long> roomIds = reservation.getRooms().stream()
                    .map(Room::getId)
                    .collect(Collectors.toSet());
            dto.setRoomIds(roomIds);
        } else {
            dto.setRoomIds(new HashSet<>());
        }

        dto.setCheckInDate(reservation.getCheckInDate());
        dto.setCheckOutDate(reservation.getCheckOutDate());
        dto.setStatus(reservation.getStatus());
        dto.setCreatedAt(reservation.getCreatedAt());
        dto.setUpdatedAt(reservation.getUpdatedAt());

        return dto;
    }

    private ReservationDayDetailDTO mapToDayDetailDTO(Reservation reservation) {
        ReservationDayDetailDTO dto = new ReservationDayDetailDTO();
        dto.setReservationId(reservation.getReservationId());

        // Set guestId
        Guest guest = reservation.getGuest();
        if (guest != null) {
            dto.setGuestId(guest.getGuestId());
        } else {
            dto.setGuestId(null);
        }

        // Convert Set<Room> to Set<Long> for roomIds
        if (reservation.getRooms() != null && !reservation.getRooms().isEmpty()) {
            Set<Long> roomIds = reservation.getRooms().stream()
                    .map(Room::getId)
                    .collect(Collectors.toSet());
            dto.setRoomIds(roomIds);
        } else {
            dto.setRoomIds(new HashSet<>());
        }

        dto.setCheckInDate(reservation.getCheckInDate());
        dto.setCheckOutDate(reservation.getCheckOutDate());
        dto.setStatus(reservation.getStatus());

        return dto;
    }
}