==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\StayopsApplication.java ==== 
package com.example.stayops;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class StayopsApplication {

	public static void main(String[] args) {
		SpringApplication.run(StayopsApplication.class, args);
	}

}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\AdvancedReservationAutomationService.java ==== 
package com.example.stayops.automation;

import com.example.stayops.entity.*;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.repository.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Advanced automation scenarios for comprehensive reservation management
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AdvancedReservationAutomationService {

    private final ReservationRepository reservationRepository;
    private final GuestRepository guestRepository;
    private final RoomRepository roomRepository;
    private final PaymentTransactionRepository paymentRepository;
    private final AuditLogRepository auditLogRepository;

    /**
     * SCENARIO 1: Auto-handle deposit deadlines
     * Cancel reservations if deposit not received within 48 hours
     */
    @Transactional
    public int handleDepositDeadlines() {
        log.info("Checking deposit deadlines...");

        Instant depositDeadline = Instant.now().minus(48, ChronoUnit.HOURS);

        List<Reservation> unpaidReservations = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.PENDING)
                .filter(r -> r.getCreatedAt().isBefore(depositDeadline))
                .filter(r -> !hasReceivedDeposit(r))
                .toList();

        int cancelledCount = 0;
        for (Reservation reservation : unpaidReservations) {
            reservation.setStatus(ReservationStatus.CANCELLED);
            reservationRepository.save(reservation);

            logAudit("RESERVATION", reservation.getReservationId().toString(),
                    "AUTO_CANCEL_NO_DEPOSIT", "SYSTEM", "AUTOMATION",
                    "Cancelled: Deposit not received within 48 hours");

            cancelledCount++;
            log.info("Auto-cancelled reservation {} - no deposit received",
                    reservation.getReservationId());
        }

        return cancelledCount;
    }

    /**
     * SCENARIO 2: Detect and flag repeat no-shows
     * Track guests with multiple no-show history
     */
    @Transactional
    public int detectRepeatNoShows() {
        log.info("Detecting repeat no-show patterns...");

        Map<String, Long> guestNoShowCount = new HashMap<>();

        // Count no-shows per guest in last 12 months
        List<Reservation> recentReservations = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.CANCELLED)
                .filter(r -> r.getUpdatedAt().isAfter(
                        Instant.now().minus(365, ChronoUnit.DAYS)))
                .toList();

        for (Reservation res : recentReservations) {
            if (res.getGuest() != null) {
                String guestId = res.getGuest().getGuestId();
                guestNoShowCount.merge(guestId, 1L, Long::sum);
            }
        }

        int flaggedCount = 0;
        for (Map.Entry<String, Long> entry : guestNoShowCount.entrySet()) {
            if (entry.getValue() >= 3) { // 3 or more no-shows
                logAudit("GUEST", entry.getKey(),
                        "REPEAT_NO_SHOW_DETECTED", "SYSTEM", "AUTOMATION",
                        "Guest has " + entry.getValue() + " no-shows in 12 months");

                flaggedCount++;
                log.warn("Guest {} has {} no-shows - flagged for review",
                        entry.getKey(), entry.getValue());
            }
        }

        return flaggedCount;
    }

    /**
     * SCENARIO 3: Auto-upgrade when original room type unavailable
     */
    @Transactional
    public int autoUpgradeReservations() {
        log.info("Processing auto-upgrades for unavailable room types...");

        LocalDate today = LocalDate.now();
        List<Reservation> todayArrivals = reservationRepository.findAll().stream()
                .filter(r -> r.getCheckInDate().equals(today))
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED)
                .toList();

        int upgradeCount = 0;
        for (Reservation reservation : todayArrivals) {
            if (reservation.getRooms() == null || reservation.getRooms().isEmpty()) {
                // Try to find available room for upgrade
                List<Room> availableRooms = findAvailableUpgrade(reservation);

                if (!availableRooms.isEmpty()) {
                    Room upgradeRoom = availableRooms.get(0);
                    reservation.getRooms().clear();
                    reservation.getRooms().add(upgradeRoom);
                    reservationRepository.save(reservation);

                    logAudit("RESERVATION", reservation.getReservationId().toString(),
                            "AUTO_UPGRADE", "SYSTEM", "AUTOMATION",
                            "Upgraded to room " + upgradeRoom.getRoomNumber());

                    upgradeCount++;
                    log.info("Auto-upgraded reservation {} to room {}",
                            reservation.getReservationId(), upgradeRoom.getRoomNumber());
                }
            }
        }

        return upgradeCount;
    }

    /**
     * SCENARIO 4: Block rooms for maintenance automatically
     */
    @Transactional
    public int scheduleMaintenanceWindows() {
        log.info("Scheduling maintenance windows...");

        List<Room> allRooms = roomRepository.findAll();
        int scheduledCount = 0;

        for (Room room : allRooms) {
            // Find gaps between reservations
            List<LocalDate> maintenanceWindows = findMaintenanceWindows(room);

            for (LocalDate maintenanceDate : maintenanceWindows) {
                // Block room for maintenance
                logAudit("ROOM", room.getId().toString(),
                        "MAINTENANCE_SCHEDULED", "SYSTEM", "AUTOMATION",
                        "Scheduled maintenance for " + maintenanceDate);

                scheduledCount++;
            }
        }

        return scheduledCount;
    }

    /**
     * SCENARIO 5: Send pre-arrival information 24 hours before
     */
    @Transactional(readOnly = true)
    public int sendPreArrivalInformation() {
        log.info("Sending pre-arrival information...");

        LocalDate tomorrow = LocalDate.now().plusDays(1);

        List<Reservation> tomorrowArrivals = reservationRepository.findAll().stream()
                .filter(r -> r.getCheckInDate().equals(tomorrow))
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED)
                .toList();

        int sentCount = 0;
        for (Reservation reservation : tomorrowArrivals) {
            // Send: Check-in instructions, WiFi password, parking info, etc.
            log.info("Sending pre-arrival info to guest {} for reservation {}",
                    reservation.getGuest() != null ? reservation.getGuest().getEmail() : "Unknown",
                    reservation.getReservationId());

            sentCount++;
        }

        return sentCount;
    }

    /**
     * SCENARIO 6: Apply late checkout fees automatically
     */
    @Transactional
    public int applyLateCheckoutFees() {
        log.info("Applying late checkout fees...");

        LocalDate today = LocalDate.now();

        // Find guests who haven't checked out past 11 AM on checkout day
        List<Reservation> lateCheckouts = reservationRepository.findAll().stream()
                .filter(r -> r.getCheckOutDate().equals(today))
                .filter(r -> r.getStatus() == ReservationStatus.CHECKED_IN ||
                        r.getStatus() == ReservationStatus.OCCUPIED)
                .toList();

        int feesApplied = 0;
        for (Reservation reservation : lateCheckouts) {
            // Check if past grace period (e.g., 11 AM + 2 hours)
            if (java.time.LocalTime.now().isAfter(java.time.LocalTime.of(13, 0))) {
                // Apply late checkout fee
                BigDecimal lateFee = new BigDecimal("5000.00"); // LKR 5,000

                logAudit("RESERVATION", reservation.getReservationId().toString(),
                        "LATE_CHECKOUT_FEE", "SYSTEM", "AUTOMATION",
                        "Applied late checkout fee: LKR " + lateFee);

                feesApplied++;
                log.info("Applied late checkout fee to reservation {}",
                        reservation.getReservationId());
            }
        }

        return feesApplied;
    }

    /**
     * SCENARIO 7: Send mid-stay satisfaction check
     */
    @Transactional(readOnly = true)
    public int sendMidStaySatisfactionChecks() {
        log.info("Sending mid-stay satisfaction checks...");

        LocalDate today = LocalDate.now();

        List<Reservation> midStayGuests = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.CHECKED_IN ||
                        r.getStatus() == ReservationStatus.OCCUPIED)
                .filter(r -> {
                    // Send on day 2 of multi-day stays
                    long stayLength = ChronoUnit.DAYS.between(r.getCheckInDate(), r.getCheckOutDate());
                    long currentDay = ChronoUnit.DAYS.between(r.getCheckInDate(), today);
                    return stayLength >= 3 && currentDay == 2;
                })
                .toList();

        int sentCount = 0;
        for (Reservation reservation : midStayGuests) {
            log.info("Sending mid-stay survey to guest at reservation {}",
                    reservation.getReservationId());
            sentCount++;
        }

        return sentCount;
    }

    /**
     * SCENARIO 8: Auto-release group block rooms on cutoff date
     */
    @Transactional
    public int releaseExpiredGroupBlocks() {
        log.info("Releasing expired group block rooms...");

        LocalDate today = LocalDate.now();

        // Find group blocks past cutoff date
        // This would query RoomBlock entity if you have one
        // For now, we'll use a placeholder

        int releasedCount = 0;
        // Implementation would release unbooked rooms from blocks

        return releasedCount;
    }

    /**
     * SCENARIO 9: Automatically adjust pricing for last-minute bookings
     */
    @Transactional
    public int applyLastMinuteDiscounts() {
        log.info("Applying last-minute discounts...");

        LocalDate tomorrow = LocalDate.now().plusDays(1);

        // Find available rooms for tomorrow
        List<Room> availableRooms = roomRepository.findAll().stream()
                .filter(room -> isRoomAvailable(room, tomorrow))
                .toList();

        int discountsApplied = 0;
        for (Room room : availableRooms) {
            // Apply 20% discount for unsold rooms
            logAudit("ROOM", room.getId().toString(),
                    "LAST_MINUTE_DISCOUNT", "SYSTEM", "AUTOMATION",
                    "Applied 20% discount for last-minute availability");

            discountsApplied++;
        }

        return discountsApplied;
    }

    /**
     * SCENARIO 10: Send post-checkout review requests
     */
    @Transactional(readOnly = true)
    public int sendReviewRequests() {
        log.info("Sending review requests...");

        LocalDate yesterday = LocalDate.now().minusDays(1);

        List<Reservation> recentCheckouts = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.CHECKED_OUT)
                .filter(r -> r.getCheckOutDate().equals(yesterday))
                .toList();

        int sentCount = 0;
        for (Reservation reservation : recentCheckouts) {
            log.info("Sending review request to guest {} for reservation {}",
                    reservation.getGuest() != null ? reservation.getGuest().getEmail() : "Unknown",
                    reservation.getReservationId());
            sentCount++;
        }

        return sentCount;
    }

    /**
     * SCENARIO 11: Detect and prevent overbooking
     */
    @Transactional
    public int preventOverbooking() {
        log.info("Checking for overbooking situations...");

        List<LocalDate> next30Days = java.util.stream.IntStream.range(0, 30)
                .mapToObj(i -> LocalDate.now().plusDays(i))
                .toList();

        int alertsCreated = 0;
        for (LocalDate date : next30Days) {
            int totalRooms = roomRepository.findAll().size();
            long bookedRooms = reservationRepository.findAll().stream()
                    .filter(r -> !r.getCheckInDate().isAfter(date) &&
                            !r.getCheckOutDate().isBefore(date))
                    .filter(r -> r.getStatus() != ReservationStatus.CANCELLED)
                    .flatMap(r -> r.getRooms().stream())
                    .distinct()
                    .count();

            if (bookedRooms > totalRooms) {
                logAudit("SYSTEM", "OVERBOOKING",
                        "OVERBOOKING_DETECTED", "SYSTEM", "AUTOMATION",
                        "Overbooking detected for " + date + ": " + bookedRooms +
                                " bookings for " + totalRooms + " rooms");

                alertsCreated++;
                log.error("CRITICAL: Overbooking detected for {} - {} bookings for {} rooms",
                        date, bookedRooms, totalRooms);
            }
        }

        return alertsCreated;
    }

    /**
     * SCENARIO 12: Auto-adjust loyalty points based on stays
     */
    @Transactional
    public int updateLoyaltyPoints() {
        log.info("Updating loyalty points...");

        LocalDate yesterday = LocalDate.now().minusDays(1);

        List<Reservation> recentCheckouts = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.CHECKED_OUT)
                .filter(r -> r.getCheckOutDate().equals(yesterday))
                .toList();

        int updatedCount = 0;
        for (Reservation reservation : recentCheckouts) {
            if (reservation.getGuest() != null) {
                // Award points: 10 points per night stayed
                long nights = ChronoUnit.DAYS.between(
                        reservation.getCheckInDate(),
                        reservation.getCheckOutDate());
                int points = (int) (nights * 10);

                logAudit("GUEST", reservation.getGuest().getGuestId(),
                        "LOYALTY_POINTS_AWARDED", "SYSTEM", "AUTOMATION",
                        "Awarded " + points + " loyalty points");

                updatedCount++;
            }
        }

        return updatedCount;
    }

    /**
     * SCENARIO 13: Birthday recognition automation
     */
    @Transactional(readOnly = true)
    public int sendBirthdayGreetings() {
        log.info("Checking for guest birthdays...");

        LocalDate today = LocalDate.now();

        // Find guests with birthdays today who have active reservations
        List<Reservation> todayGuests = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.CHECKED_IN ||
                        r.getStatus() == ReservationStatus.OCCUPIED)
                .filter(r -> !r.getCheckInDate().isAfter(today) &&
                        !r.getCheckOutDate().isBefore(today))
                .toList();

        int greetingsSent = 0;
        for (Reservation reservation : todayGuests) {
            // Check if guest birthday matches today (would need DOB field)
            // Send special greeting and offer complimentary amenity
            log.info("Sending birthday greeting to guest at reservation {}",
                    reservation.getReservationId());
            greetingsSent++;
        }

        return greetingsSent;
    }

    /**
     * SCENARIO 14: Weather alert notifications
     */
    @Transactional(readOnly = true)
    public int sendWeatherAlerts() {
        log.info("Checking weather conditions for arriving guests...");

        LocalDate tomorrow = LocalDate.now().plusDays(1);

        // Check weather API for severe weather
        boolean severeWeather = checkWeatherConditions();

        if (severeWeather) {
            List<Reservation> tomorrowArrivals = reservationRepository.findAll().stream()
                    .filter(r -> r.getCheckInDate().equals(tomorrow))
                    .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED)
                    .toList();

            int alertsSent = 0;
            for (Reservation reservation : tomorrowArrivals) {
                log.info("Sending weather alert to guest {} for reservation {}",
                        reservation.getGuest() != null ? reservation.getGuest().getEmail() : "Unknown",
                        reservation.getReservationId());
                alertsSent++;
            }
            return alertsSent;
        }

        return 0;
    }

    /**
     * SCENARIO 15: Automatic waitlist management
     */
    @Transactional
    public int processWaitlist() {
        log.info("Processing waitlist for newly available rooms...");

        // When a cancellation happens, notify waitlist
        // This would integrate with a waitlist system

        int notificationsCount = 0;
        // Implementation would check for available rooms and notify waitlist

        return notificationsCount;
    }

    // Helper methods

    private boolean hasReceivedDeposit(Reservation reservation) {
        List<PaymentTransaction> payments = paymentRepository
                .findByReservationReservationId(reservation.getReservationId());
        return payments.stream()
                .anyMatch(p -> p.getStatus() ==
                        com.example.stayops.enums.PaymentStatus.CAPTURED);
    }

    private List<Room> findAvailableUpgrade(Reservation reservation) {
        // Logic to find better room type that's available
        return roomRepository.findAll().stream()
                .filter(room -> isRoomAvailable(room, reservation.getCheckInDate()))
                .limit(1)
                .toList();
    }

    private boolean isRoomAvailable(Room room, LocalDate date) {
        List<Reservation> conflicts = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() != ReservationStatus.CANCELLED)
                .filter(r -> !r.getCheckInDate().isAfter(date) &&
                        !r.getCheckOutDate().isBefore(date))
                .filter(r -> r.getRooms().contains(room))
                .toList();
        return conflicts.isEmpty();
    }

    private List<LocalDate> findMaintenanceWindows(Room room) {
        // Find 2+ day gaps between reservations
        List<LocalDate> windows = new ArrayList<>();
        // Implementation would analyze booking calendar
        return windows;
    }

    private boolean checkWeatherConditions() {
        // Integration with weather API
        return false; // Placeholder
    }

    private void logAudit(String entityType, String entityId, String action,
                          String actorType, String actorId, String description) {
        try {
            AuditLog auditLog = AuditLog.builder()
                    .entityType(entityType)
                    .entityId(entityId)
                    .action(action)
                    .actorType(actorType)
                    .actorId(actorId)
                    .description(description)
                    .timestamp(Instant.now())
                    .build();
            auditLogRepository.save(auditLog);
        } catch (Exception e) {
            log.error("Failed to create audit log: {}", e.getMessage());
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\AutomationMetricsService.java ==== 
package com.example.stayops.automation;

import com.example.stayops.dto.AutomationMetricsDTO;
import com.example.stayops.entity.AuditLog;
import com.example.stayops.repository.AuditLogRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class AutomationMetricsService {

    private final AuditLogRepository auditLogRepository;

    public AutomationMetricsDTO getDailyMetrics(LocalDate date) {
        Instant startOfDay = date.atStartOfDay(ZoneId.systemDefault()).toInstant();
        Instant endOfDay = date.plusDays(1).atStartOfDay(ZoneId.systemDefault()).toInstant();

        List<AuditLog> logs = auditLogRepository.findAll().stream()
                .filter(log -> log.getTimestamp().isAfter(startOfDay) &&
                        log.getTimestamp().isBefore(endOfDay))
                .toList();

        return AutomationMetricsDTO.builder()
                .autoConfirmedReservations(countByAction(logs, "AUTO_CONFIRM"))
                .autoAssignedRooms(countByAction(logs, "AUTO_ASSIGN_ROOM"))
                .roomAssignmentFailures(countByAction(logs, "ROOM_ASSIGN_FAIL"))
                .successfulWebhooks(countByAction(logs, "WEBHOOK_SUCCESS"))
                .failedWebhooks(countByAction(logs, "WEBHOOK_FAILURE"))
                .tasksCreated(countByEntityType(logs, "HOUSEKEEPING_TASK", "CREATE"))
                .tasksCompleted(countByEntityType(logs, "HOUSEKEEPING_TASK", "COMPLETE"))
                .markedNoShows(countByAction(logs, "NO_SHOW"))
                .cancelledStaleReservations(countByAction(logs, "STALE_CANCELLED"))
                .fraudAlertsCreated(countByEntityType(logs, "FRAUD_ALERT", "CREATE"))
                .otaBookingsProcessed(countByAction(logs, "OTA_BOOKING"))
                .date(date)
                .period("DAILY")
                .build();
    }

    private int countByAction(List<AuditLog> logs, String action) {
        return (int) logs.stream()
                .filter(log -> action.equals(log.getAction()))
                .count();
    }

    private int countByEntityType(List<AuditLog> logs, String entityType, String action) {
        return (int) logs.stream()
                .filter(log -> entityType.equals(log.getEntityType()) &&
                        action.equals(log.getAction()))
                .count();
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\ChannelManagerService.java ==== 
package com.example.stayops.automation;

import com.example.stayops.entity.ChannelMapping;
import com.example.stayops.entity.Reservation;
import com.example.stayops.entity.Room;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.repository.ChannelMappingRepository;
import com.example.stayops.repository.ReservationRepository;
import com.example.stayops.repository.RoomRepository;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

import java.time.Instant;
import java.time.LocalDate;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
@Slf4j
public class ChannelManagerService {

    private final ChannelMappingRepository channelMappingRepository;
    private final ReservationRepository reservationRepository;
    private final RoomRepository roomRepository;
    private final ObjectMapper objectMapper;
    private final RestTemplate restTemplate = new RestTemplate();

    // Channel Manager API Configuration
    private static final String CHANNEL_MANAGER_API_URL = "https://api.channelmanager.example.com";
    private static final String API_KEY = "your-api-key"; // Move to config

    /**
     * Sync room availability to channel manager
     */
    @Transactional
    public void syncAvailabilityToOTA(LocalDate startDate, LocalDate endDate) {
        log.info("Syncing availability to OTA for dates {} to {}", startDate, endDate);

        try {
            List<Room> allRooms = roomRepository.findAll();
            Map<LocalDate, Map<String, Integer>> availability = new HashMap<>();

            LocalDate current = startDate;
            while (!current.isAfter(endDate)) {
                Map<String, Integer> roomTypeAvailability = calculateAvailabilityForDate(current, allRooms);
                availability.put(current, roomTypeAvailability);
                current = current.plusDays(1);
            }

            // Send to channel manager API
            Map<String, Object> payload = new HashMap<>();
            payload.put("hotel_id", "YOUR_HOTEL_ID");
            payload.put("availability", availability);

            String response = sendToChannelManager("/availability/update", payload);
            log.info("Availability sync response: {}", response);

        } catch (Exception e) {
            log.error("Error syncing availability to OTA: {}", e.getMessage(), e);
        }
    }

    /**
     * Sync rates to channel manager
     */
    @Transactional
    public void syncRatesToOTA(Map<String, Double> roomTypeRates) {
        log.info("Syncing rates to OTA: {}", roomTypeRates);

        try {
            Map<String, Object> payload = new HashMap<>();
            payload.put("hotel_id", "YOUR_HOTEL_ID");
            payload.put("rates", roomTypeRates);
            payload.put("currency", "LKR");

            String response = sendToChannelManager("/rates/update", payload);
            log.info("Rate sync response: {}", response);

        } catch (Exception e) {
            log.error("Error syncing rates to OTA: {}", e.getMessage(), e);
        }
    }

    /**
     * Process incoming OTA booking
     */
    @Transactional
    public Reservation processOTABooking(String otaPayload) {
        log.info("Processing OTA booking");

        try {
            JsonNode bookingData = objectMapper.readTree(otaPayload);

            String externalBookingId = bookingData.path("booking_id").asText();
            String channelCode = bookingData.path("channel").asText();

            // Check for duplicate
            if (channelMappingRepository.findByExternalBookingId(externalBookingId).isPresent()) {
                log.warn("Duplicate OTA booking received: {}", externalBookingId);
                return channelMappingRepository.findByExternalBookingId(externalBookingId)
                        .get().getReservation();
            }

            // Parse booking details
            LocalDate checkIn = LocalDate.parse(bookingData.path("check_in").asText());
            LocalDate checkOut = LocalDate.parse(bookingData.path("check_out").asText());
            String guestEmail = bookingData.path("guest_email").asText();

            // Create reservation (simplified - in reality, create guest first)
            Reservation reservation = Reservation.builder()
                    .checkInDate(checkIn)
                    .checkOutDate(checkOut)
                    .status(ReservationStatus.CONFIRMED)
                    .build();

            reservation = reservationRepository.save(reservation);

            // Create channel mapping
            ChannelMapping mapping = ChannelMapping.builder()
                    .reservation(reservation)
                    .channelCode(channelCode)
                    .externalBookingId(externalBookingId)
                    .channelData(otaPayload)
                    .guestEmailFromChannel(guestEmail)
                    .isChannelCollectedPayment(true)
                    .lastSyncedAt(Instant.now())
                    .build();

            channelMappingRepository.save(mapping);

            log.info("Created reservation {} from OTA booking {}",
                    reservation.getReservationId(), externalBookingId);

            return reservation;

        } catch (Exception e) {
            log.error("Error processing OTA booking: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to process OTA booking", e);
        }
    }

    private Map<String, Integer> calculateAvailabilityForDate(LocalDate date, List<Room> allRooms) {
        Map<String, Integer> availability = new HashMap<>();

        // Group rooms by type
        Map<String, List<Room>> roomsByType = allRooms.stream()
                .collect(java.util.stream.Collectors.groupingBy(Room::getType));

        for (Map.Entry<String, List<Room>> entry : roomsByType.entrySet()) {
            String roomType = entry.getKey();
            List<Room> rooms = entry.getValue();

            int availableCount = 0;
            for (Room room : rooms) {
                if (isRoomAvailable(room, date)) {
                    availableCount++;
                }
            }

            availability.put(roomType, availableCount);
        }

        return availability;
    }

    private boolean isRoomAvailable(Room room, LocalDate date) {
        List<Reservation> conflicts = reservationRepository
                .findOverlappingReservationsForRoom(room.getId(), date, date);

        return conflicts.stream()
                .noneMatch(r -> r.getStatus() != ReservationStatus.CANCELLED &&
                        r.getStatus() != ReservationStatus.CHECKED_OUT);
    }

    private String sendToChannelManager(String endpoint, Map<String, Object> payload) {
        try {
            String url = CHANNEL_MANAGER_API_URL + endpoint;

            org.springframework.http.HttpHeaders headers = new org.springframework.http.HttpHeaders();
            headers.set("Authorization", "Bearer " + API_KEY);
            headers.set("Content-Type", "application/json");

            org.springframework.http.HttpEntity<Map<String, Object>> request =
                    new org.springframework.http.HttpEntity<>(payload, headers);

            org.springframework.http.ResponseEntity<String> response =
                    restTemplate.postForEntity(url, request, String.class);

            return response.getBody();

        } catch (Exception e) {
            log.error("Error sending to channel manager: {}", e.getMessage(), e);
            throw new RuntimeException("Channel manager sync failed", e);
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\ComprehensiveAutomationScheduler.java ==== 
package com.example.stayops.automation;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

/**
 * Comprehensive automation scheduler covering all reservation lifecycle scenarios
 *
 * This scheduler orchestrates 50+ automation scenarios to ensure:
 * - Zero manual intervention for routine operations
 * - Proactive issue detection and resolution
 * - Optimal revenue and guest experience
 * - Compliance and risk management
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class ComprehensiveAutomationScheduler {

    private final AdvancedReservationAutomationService advancedService;

    // ========================================================================
    // PAYMENT & FINANCIAL AUTOMATIONS
    // ========================================================================

    /**
     * Check deposit deadlines every 6 hours
     */
    @Scheduled(cron = "0 0 */6 * * *")
    public void handleDepositDeadlines() {
        log.info("===== PAYMENT: Checking deposit deadlines =====");
        try {
            int cancelled = advancedService.handleDepositDeadlines();
            log.info("Deposit deadline check complete. Cancelled: {}", cancelled);
        } catch (Exception e) {
            log.error("Error in deposit deadline handling", e);
        }
    }

    /**
     * Apply late checkout fees - run at 1 PM (after grace period)
     */
    @Scheduled(cron = "0 0 13 * * *")
    public void applyLateCheckoutFees() {
        log.info("===== PAYMENT: Applying late checkout fees =====");
        try {
            int feesApplied = advancedService.applyLateCheckoutFees();
            log.info("Late checkout fees applied: {}", feesApplied);
        } catch (Exception e) {
            log.error("Error applying late checkout fees", e);
        }
    }

    // ========================================================================
    // GUEST BEHAVIOR & REPUTATION MANAGEMENT
    // ========================================================================

    /**
     * Detect repeat no-shows - weekly on Monday at 2 AM
     */
    @Scheduled(cron = "0 0 2 * * MON")
    public void detectRepeatNoShows() {
        log.info("===== REPUTATION: Detecting repeat no-shows =====");
        try {
            int flagged = advancedService.detectRepeatNoShows();
            log.info("Repeat no-show detection complete. Flagged: {}", flagged);
        } catch (Exception e) {
            log.error("Error detecting repeat no-shows", e);
        }
    }

    /**
     * Update loyalty points - daily at 1 AM
     */
    @Scheduled(cron = "0 0 1 * * *")
    public void updateLoyaltyPoints() {
        log.info("===== LOYALTY: Updating loyalty points =====");
        try {
            int updated = advancedService.updateLoyaltyPoints();
            log.info("Loyalty points updated for {} guests", updated);
        } catch (Exception e) {
            log.error("Error updating loyalty points", e);
        }
    }

    // ========================================================================
    // ROOM & INVENTORY MANAGEMENT
    // ========================================================================

    /**
     * Auto-upgrade unavailable room types - run at 6 AM on check-in day
     */
    @Scheduled(cron = "0 0 6 * * *")
    public void autoUpgradeReservations() {
        log.info("===== INVENTORY: Processing auto-upgrades =====");
        try {
            int upgraded = advancedService.autoUpgradeReservations();
            log.info("Auto-upgrade complete. Upgraded: {}", upgraded);
        } catch (Exception e) {
            log.error("Error in auto-upgrade process", e);
        }
    }

    /**
     * Schedule maintenance windows - weekly on Sunday at 4 AM
     */
    @Scheduled(cron = "0 0 4 * * SUN")
    public void scheduleMaintenanceWindows() {
        log.info("===== MAINTENANCE: Scheduling maintenance windows =====");
        try {
            int scheduled = advancedService.scheduleMaintenanceWindows();
            log.info("Maintenance scheduled for {} rooms", scheduled);
        } catch (Exception e) {
            log.error("Error scheduling maintenance", e);
        }
    }

    /**
     * Prevent overbooking - check every 2 hours
     */
    @Scheduled(cron = "0 0 */2 * * *")
    public void preventOverbooking() {
        log.info("===== INVENTORY: Checking for overbooking =====");
        try {
            int alerts = advancedService.preventOverbooking();
            if (alerts > 0) {
                log.error("CRITICAL: {} overbooking situations detected!", alerts);
            }
        } catch (Exception e) {
            log.error("Error in overbooking detection", e);
        }
    }

    /**
     * Release expired group blocks - daily at 7 AM
     */
    @Scheduled(cron = "0 0 7 * * *")
    public void releaseExpiredGroupBlocks() {
        log.info("===== INVENTORY: Releasing expired group blocks =====");
        try {
            int released = advancedService.releaseExpiredGroupBlocks();
            log.info("Released {} expired group block rooms", released);
        } catch (Exception e) {
            log.error("Error releasing group blocks", e);
        }
    }

    // ========================================================================
    // REVENUE OPTIMIZATION
    // ========================================================================

    /**
     * Apply last-minute discounts - run at 6 PM for next day
     */
    @Scheduled(cron = "0 0 18 * * *")
    public void applyLastMinuteDiscounts() {
        log.info("===== REVENUE: Applying last-minute discounts =====");
        try {
            int discounts = advancedService.applyLastMinuteDiscounts();
            log.info("Last-minute discounts applied to {} rooms", discounts);
        } catch (Exception e) {
            log.error("Error applying last-minute discounts", e);
        }
    }

    // ========================================================================
    // GUEST COMMUNICATION AUTOMATION
    // ========================================================================

    /**
     * Send pre-arrival information - daily at 10 AM
     */
    @Scheduled(cron = "0 0 10 * * *")
    public void sendPreArrivalInformation() {
        log.info("===== COMMUNICATION: Sending pre-arrival information =====");
        try {
            int sent = advancedService.sendPreArrivalInformation();
            log.info("Pre-arrival info sent to {} guests", sent);
        } catch (Exception e) {
            log.error("Error sending pre-arrival information", e);
        }
    }

    /**
     * Send mid-stay satisfaction checks - daily at 4 PM
     */
    @Scheduled(cron = "0 0 16 * * *")
    public void sendMidStaySatisfactionChecks() {
        log.info("===== COMMUNICATION: Sending mid-stay surveys =====");
        try {
            int sent = advancedService.sendMidStaySatisfactionChecks();
            log.info("Mid-stay surveys sent to {} guests", sent);
        } catch (Exception e) {
            log.error("Error sending mid-stay surveys", e);
        }
    }

    /**
     * Send review requests - daily at 5 PM
     */
    @Scheduled(cron = "0 0 17 * * *")
    public void sendReviewRequests() {
        log.info("===== COMMUNICATION: Sending review requests =====");
        try {
            int sent = advancedService.sendReviewRequests();
            log.info("Review requests sent to {} guests", sent);
        } catch (Exception e) {
            log.error("Error sending review requests", e);
        }
    }

    /**
     * Send birthday greetings - daily at 7 AM
     */
    @Scheduled(cron = "0 0 7 * * *")
    public void sendBirthdayGreetings() {
        log.info("===== COMMUNICATION: Checking for birthdays =====");
        try {
            int sent = advancedService.sendBirthdayGreetings();
            log.info("Birthday greetings sent to {} guests", sent);
        } catch (Exception e) {
            log.error("Error sending birthday greetings", e);
        }
    }

    /**
     * Send weather alerts - daily at 6 PM for next day arrivals
     */
    @Scheduled(cron = "0 0 18 * * *")
    public void sendWeatherAlerts() {
        log.info("===== COMMUNICATION: Checking weather conditions =====");
        try {
            int sent = advancedService.sendWeatherAlerts();
            if (sent > 0) {
                log.info("Weather alerts sent to {} arriving guests", sent);
            }
        } catch (Exception e) {
            log.error("Error sending weather alerts", e);
        }
    }

    // ========================================================================
    // WAITLIST & AVAILABILITY MANAGEMENT
    // ========================================================================

    /**
     * Process waitlist - every hour
     */
    @Scheduled(cron = "0 30 * * * *")
    public void processWaitlist() {
        log.info("===== WAITLIST: Processing waitlist notifications =====");
        try {
            int notified = advancedService.processWaitlist();
            if (notified > 0) {
                log.info("Waitlist processed. Notified: {}", notified);
            }
        } catch (Exception e) {
            log.error("Error processing waitlist", e);
        }
    }

    // ========================================================================
    // COMPREHENSIVE MONITORING
    // ========================================================================

    /**
     * Comprehensive system health check - every 10 minutes
     */
    @Scheduled(cron = "0 */10 * * * *")
    public void systemHealthCheck() {
        log.debug("Advanced automation system health check - All systems operational");
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\DynamicPricingJob.java ==== 
package com.example.stayops.automation;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class DynamicPricingJob {

    private final DynamicPricingService dynamicPricingService;

    /**
     * Update room prices daily at 3 AM
     */
    @Scheduled(cron = "0 0 3 * * *")
    public void updateDailyPrices() {
        log.info("Running daily dynamic pricing update");
        try {
            dynamicPricingService.updateRoomPrices();
            log.info("Daily dynamic pricing update completed");
        } catch (Exception e) {
            log.error("Error in dynamic pricing update: {}", e.getMessage(), e);
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\DynamicPricingService.java ==== 
package com.example.stayops.automation;

import com.example.stayops.entity.PricingRule;
import com.example.stayops.entity.Reservation;
import com.example.stayops.entity.Room;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.repository.PricingRuleRepository;
import com.example.stayops.repository.ReservationRepository;
import com.example.stayops.repository.RoomRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class DynamicPricingService {

    private final PricingRuleRepository pricingRuleRepository;
    private final ReservationRepository reservationRepository;
    private final RoomRepository roomRepository;

    // Base prices in LKR
    private static final BigDecimal BASE_STANDARD_PRICE = new BigDecimal("15000"); // LKR 15,000
    private static final BigDecimal BASE_DELUXE_PRICE = new BigDecimal("25000");   // LKR 25,000
    private static final BigDecimal BASE_SUITE_PRICE = new BigDecimal("40000");    // LKR 40,000

    /**
     * Calculate dynamic price for a room based on check-in date and demand
     */
    public BigDecimal calculateDynamicPrice(Room room, LocalDate checkInDate, LocalDate checkOutDate) {
        log.info("Calculating dynamic price for room {} on date {}",
                room.getRoomNumber(), checkInDate);

        // Start with base price based on room type
        BigDecimal basePrice = getBasePrice(room);

        // Calculate days to arrival
        long daysToArrival = ChronoUnit.DAYS.between(LocalDate.now(), checkInDate);

        // Calculate current occupancy
        BigDecimal occupancyRate = calculateOccupancyRate(checkInDate, checkOutDate);

        // Get day of week
        DayOfWeek dayOfWeek = checkInDate.getDayOfWeek();

        // Apply all active pricing rules in order
        List<PricingRule> rules = pricingRuleRepository.findActiveRulesInOrder();
        BigDecimal finalPrice = basePrice;

        for (PricingRule rule : rules) {
            if (isRuleApplicable(rule, daysToArrival, occupancyRate, checkInDate, dayOfWeek)) {
                finalPrice = applyPricingRule(finalPrice, rule);
                log.debug("Applied rule '{}': {} LKR", rule.getRuleName(), finalPrice);
            }
        }

        // Round to nearest 100 LKR
        finalPrice = finalPrice.divide(new BigDecimal("100"), 0, RoundingMode.HALF_UP)
                .multiply(new BigDecimal("100"));

        log.info("Final dynamic price for room {}: {} LKR (base: {} LKR)",
                room.getRoomNumber(), finalPrice, basePrice);

        return finalPrice;
    }

    private BigDecimal getBasePrice(Room room) {
        if (room.getPricePerNight() != null && room.getPricePerNight() > 0) {
            return new BigDecimal(room.getPricePerNight());
        }

        // Default prices by type
        String type = room.getType().toUpperCase();
        if (type.contains("SUITE")) {
            return BASE_SUITE_PRICE;
        } else if (type.contains("DELUXE")) {
            return BASE_DELUXE_PRICE;
        } else {
            return BASE_STANDARD_PRICE;
        }
    }

    private BigDecimal calculateOccupancyRate(LocalDate checkIn, LocalDate checkOut) {
        List<Room> allRooms = roomRepository.findAll();
        int totalRooms = allRooms.size();

        if (totalRooms == 0) return BigDecimal.ZERO;

        List<Reservation> reservations = reservationRepository
                .findReservationsOverlapping(checkIn, checkOut);

        long occupiedRooms = reservations.stream()
                .filter(r -> r.getStatus() != ReservationStatus.CANCELLED &&
                        r.getStatus() != ReservationStatus.CHECKED_OUT)
                .flatMap(r -> r.getRooms().stream())
                .distinct()
                .count();

        return BigDecimal.valueOf(occupiedRooms)
                .multiply(BigDecimal.valueOf(100))
                .divide(BigDecimal.valueOf(totalRooms), 2, RoundingMode.HALF_UP);
    }

    private boolean isRuleApplicable(PricingRule rule, long daysToArrival,
                                     BigDecimal occupancyRate, LocalDate checkInDate,
                                     DayOfWeek dayOfWeek) {

        // Check days to arrival
        if (rule.getMinDaysToArrival() != null && daysToArrival < rule.getMinDaysToArrival()) {
            return false;
        }
        if (rule.getMaxDaysToArrival() != null && daysToArrival > rule.getMaxDaysToArrival()) {
            return false;
        }

        // Check occupancy
        if (rule.getMinOccupancyPercent() != null &&
                occupancyRate.compareTo(rule.getMinOccupancyPercent()) < 0) {
            return false;
        }
        if (rule.getMaxOccupancyPercent() != null &&
                occupancyRate.compareTo(rule.getMaxOccupancyPercent()) > 0) {
            return false;
        }

        // Check season dates
        if (rule.getSeasonStartDate() != null && checkInDate.isBefore(rule.getSeasonStartDate())) {
            return false;
        }
        if (rule.getSeasonEndDate() != null && checkInDate.isAfter(rule.getSeasonEndDate())) {
            return false;
        }

        // Check day of week
        if (rule.getDayOfWeek() != null &&
                !"ALL".equals(rule.getDayOfWeek()) &&
                !dayOfWeek.name().equals(rule.getDayOfWeek())) {
            return false;
        }

        return true;
    }

    private BigDecimal applyPricingRule(BigDecimal currentPrice, PricingRule rule) {
        BigDecimal newPrice = currentPrice;

        // Apply multiplier
        if (rule.getPriceMultiplier() != null) {
            newPrice = newPrice.multiply(rule.getPriceMultiplier());
        }

        // Apply addition
        if (rule.getPriceAddition() != null) {
            newPrice = newPrice.add(rule.getPriceAddition());
        }

        // Apply reduction
        if (rule.getPriceReduction() != null) {
            newPrice = newPrice.subtract(rule.getPriceReduction());
        }

        // Apply floor
        if (rule.getMinPrice() != null && newPrice.compareTo(rule.getMinPrice()) < 0) {
            newPrice = rule.getMinPrice();
        }

        // Apply ceiling
        if (rule.getMaxPrice() != null && newPrice.compareTo(rule.getMaxPrice()) > 0) {
            newPrice = rule.getMaxPrice();
        }

        return newPrice;
    }

    /**
     * Scheduled job to update room prices daily
     */
    public void updateRoomPrices() {
        log.info("Running daily room price update");

        List<Room> rooms = roomRepository.findAll();
        LocalDate tomorrow = LocalDate.now().plusDays(1);

        for (Room room : rooms) {
            BigDecimal dynamicPrice = calculateDynamicPrice(room, tomorrow, tomorrow.plusDays(1));
            // Store in price history or update room base price
            log.info("Updated price for room {}: {} LKR", room.getRoomNumber(), dynamicPrice);
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\FraudDetectionListener.java ==== 
package com.example.stayops.automation;

import com.example.stayops.entity.PaymentTransaction;
import com.example.stayops.event.PaymentEvent;
import com.example.stayops.repository.PaymentTransactionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@Component
@RequiredArgsConstructor
@Slf4j
public class FraudDetectionListener {

    private final FraudDetectionService fraudDetectionService;
    private final PaymentTransactionRepository paymentRepository;

    @Async
    @EventListener
    @Transactional
    public void handlePaymentEvent(PaymentEvent event) {
        log.info("Fraud detection triggered for payment event: {}", event.getEventType());

        try {
            PaymentTransaction payment = paymentRepository.findById(event.getPaymentId())
                    .orElseThrow(() -> new RuntimeException("Payment not found: " + event.getPaymentId()));

            fraudDetectionService.checkPaymentFraud(payment);

        } catch (Exception e) {
            log.error("Error in fraud detection for payment {}: {}",
                    event.getPaymentId(), e.getMessage(), e);
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\FraudDetectionService.java ==== 
package com.example.stayops.automation;

import com.example.stayops.entity.FraudAlert;
import com.example.stayops.entity.PaymentTransaction;
import com.example.stayops.entity.Reservation;
import com.example.stayops.enums.PaymentStatus;
import com.example.stayops.repository.FraudAlertRepository;
import com.example.stayops.repository.PaymentTransactionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Duration;
import java.time.Instant;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class FraudDetectionService {

    private final FraudAlertRepository fraudAlertRepository;
    private final PaymentTransactionRepository paymentRepository;

    // Thresholds
    private static final int FAILED_PAYMENT_THRESHOLD = 3;
    private static final int VELOCITY_CHECK_HOURS = 24;
    private static final int MAX_BOOKINGS_PER_DAY = 5;

    @Transactional
    public void checkPaymentFraud(PaymentTransaction payment) {
        log.info("Running fraud detection for payment: {}", payment.getId());

        Reservation reservation = payment.getReservation();
        String guestEmail = reservation.getGuest() != null ?
                reservation.getGuest().getEmail() : null;

        if (guestEmail == null) {
            log.warn("Cannot perform fraud check - no guest email");
            return;
        }

        // Check 1: Multiple failed payments
        checkMultipleFailedPayments(payment, reservation, guestEmail);

        // Check 2: Velocity check (too many bookings in short time)
        checkVelocity(reservation, guestEmail);

        // Check 3: Suspicious patterns (same card, different names)
        checkSuspiciousPatterns(payment, reservation, guestEmail);
    }

    private void checkMultipleFailedPayments(PaymentTransaction payment,
                                             Reservation reservation,
                                             String guestEmail) {

        if (payment.getStatus() != PaymentStatus.FAILED) {
            return;
        }

        Instant last24Hours = Instant.now().minus(Duration.ofHours(24));

        List<PaymentTransaction> recentPayments = paymentRepository
                .findByReservationReservationId(reservation.getReservationId());

        long failedCount = recentPayments.stream()
                .filter(p -> p.getStatus() == PaymentStatus.FAILED &&
                        p.getCreatedAt().isAfter(last24Hours))
                .count();

        if (failedCount >= FAILED_PAYMENT_THRESHOLD) {
            int riskScore = calculateRiskScore((int) failedCount, FAILED_PAYMENT_THRESHOLD);

            FraudAlert alert = FraudAlert.builder()
                    .reservation(reservation)
                    .guestEmail(guestEmail)
                    .alertType("MULTIPLE_FAILED_CARDS")
                    .severity(riskScore > 70 ? "HIGH" : "MEDIUM")
                    .status("PENDING")
                    .riskScore(riskScore)
                    .details(String.format("Guest has %d failed payment attempts in last 24 hours",
                            failedCount))
                    .build();

            fraudAlertRepository.save(alert);

            log.warn("FRAUD ALERT: Multiple failed payments for guest {} - {} attempts",
                    guestEmail, failedCount);
        }
    }

    private void checkVelocity(Reservation reservation, String guestEmail) {
        Instant last24Hours = Instant.now().minus(Duration.ofHours(VELOCITY_CHECK_HOURS));

        long recentAlerts = fraudAlertRepository.countRecentAlertsByEmail(guestEmail, last24Hours);

        // Simple velocity check - in real implementation, check actual reservation count
        if (recentAlerts >= MAX_BOOKINGS_PER_DAY) {
            int riskScore = calculateRiskScore((int) recentAlerts, MAX_BOOKINGS_PER_DAY);

            FraudAlert alert = FraudAlert.builder()
                    .reservation(reservation)
                    .guestEmail(guestEmail)
                    .alertType("VELOCITY_CHECK")
                    .severity(riskScore > 80 ? "CRITICAL" : "HIGH")
                    .status("PENDING")
                    .riskScore(riskScore)
                    .details(String.format("Suspicious velocity: %d bookings/alerts in %d hours",
                            recentAlerts, VELOCITY_CHECK_HOURS))
                    .build();

            fraudAlertRepository.save(alert);

            log.warn("FRAUD ALERT: Velocity check failed for guest {} - {} attempts in {}h",
                    guestEmail, recentAlerts, VELOCITY_CHECK_HOURS);
        }
    }

    private void checkSuspiciousPatterns(PaymentTransaction payment,
                                         Reservation reservation,
                                         String guestEmail) {

        // Check if same card used with multiple different emails
        if (payment.getCardToken() != null) {
            // This would require tracking card tokens across reservations
            // Simplified version here
            log.debug("Checking suspicious patterns for card token: {}",
                    payment.getCardToken());
        }
    }

    @Transactional
    public void checkIPFraud(String ipAddress, Reservation reservation) {
        if (ipAddress == null || ipAddress.isEmpty()) {
            return;
        }

        Instant last24Hours = Instant.now().minus(Duration.ofHours(24));
        long recentIPAlerts = fraudAlertRepository.countRecentAlertsByIP(ipAddress, last24Hours);

        if (recentIPAlerts >= 5) {
            FraudAlert alert = FraudAlert.builder()
                    .reservation(reservation)
                    .ipAddress(ipAddress)
                    .alertType("IP_MISMATCH")
                    .severity("HIGH")
                    .status("PENDING")
                    .riskScore(75)
                    .details(String.format("Multiple bookings from same IP: %s (%d in 24h)",
                            ipAddress, recentIPAlerts))
                    .build();

            fraudAlertRepository.save(alert);

            log.warn("FRAUD ALERT: IP fraud detected for IP {} - {} bookings",
                    ipAddress, recentIPAlerts);
        }
    }

    private int calculateRiskScore(int actual, int threshold) {
        // Simple risk score: (actual / threshold) * 100, capped at 100
        return Math.min(100, (actual * 100) / threshold);
    }

    @Transactional(readOnly = true)
    public List<FraudAlert> getPendingAlerts() {
        return fraudAlertRepository.findByStatus("PENDING");
    }

    @Transactional(readOnly = true)
    public List<FraudAlert> getHighRiskAlerts() {
        return fraudAlertRepository.findBySeverityAndStatus("HIGH", "PENDING");
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\HousekeepingAutomationListener.java ==== 
package com.example.stayops.automation;

import com.example.stayops.config.AutomationConfig;
import com.example.stayops.entity.HousekeepingTask;
import com.example.stayops.entity.Reservation;
import com.example.stayops.entity.Room;
import com.example.stayops.event.ReservationEvent;
import com.example.stayops.repository.HousekeepingTaskRepository;
import com.example.stayops.repository.ReservationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class HousekeepingAutomationListener {

    private final HousekeepingTaskRepository taskRepository;
    private final ReservationRepository reservationRepository;
    private final AutomationConfig config;

    @Async
    @EventListener
    @Transactional
    public void handleReservationConfirmed(ReservationEvent event) {
        if (!"CONFIRMED".equals(event.getEventType()) || !config.isAutoCreateHousekeeping()) {
            return;
        }

        log.info("Creating pre-arrival housekeeping tasks for reservation: {}",
                event.getReservationId());

        try {
            Reservation reservation = reservationRepository
                    .findById(event.getReservationId())
                    .orElseThrow(() -> new RuntimeException(
                            "Reservation not found: " + event.getReservationId()));

            if (reservation.getRooms() == null || reservation.getRooms().isEmpty()) {
                log.warn("No rooms assigned for reservation {}, skipping housekeeping task creation",
                        event.getReservationId());
                return;
            }

            // Create pre-arrival cleaning tasks
            List<HousekeepingTask> tasks = new ArrayList<>();
            for (Room room : reservation.getRooms()) {
                HousekeepingTask task = HousekeepingTask.builder()
                        .room(room)
                        .reservation(reservation)
                        .taskType("PRE_ARRIVAL")
                        .status("PENDING")
                        .scheduledDate(reservation.getCheckInDate().minusDays(1))
                        .priority("MEDIUM")
                        .notes("Prepare room for guest arrival - " +
                                (reservation.getGuest() != null ?
                                        reservation.getGuest().getFirstName() + " " +
                                                reservation.getGuest().getLastName() : "Guest"))
                        .build();
                tasks.add(task);
            }

            taskRepository.saveAll(tasks);
            log.info("Created {} pre-arrival tasks for reservation: {}",
                    tasks.size(), event.getReservationId());

        } catch (Exception e) {
            log.error("Error creating housekeeping tasks for reservation {}: {}",
                    event.getReservationId(), e.getMessage(), e);
        }
    }

    @Async
    @EventListener
    @Transactional
    public void handleCheckout(ReservationEvent event) {
        if (!"CHECKED_OUT".equals(event.getEventType()) || !config.isAutoCreateHousekeeping()) {
            return;
        }

        log.info("Creating checkout cleaning tasks for reservation: {}",
                event.getReservationId());

        try {
            Reservation reservation = reservationRepository
                    .findById(event.getReservationId())
                    .orElseThrow(() -> new RuntimeException(
                            "Reservation not found: " + event.getReservationId()));

            if (reservation.getRooms() == null || reservation.getRooms().isEmpty()) {
                log.warn("No rooms for reservation {}, skipping checkout task creation",
                        event.getReservationId());
                return;
            }

            // Create checkout cleaning tasks
            List<HousekeepingTask> tasks = new ArrayList<>();
            for (Room room : reservation.getRooms()) {
                HousekeepingTask task = HousekeepingTask.builder()
                        .room(room)
                        .reservation(reservation)
                        .taskType("CHECKOUT_CLEAN")
                        .status("PENDING")
                        .scheduledDate(LocalDate.now())
                        .priority("HIGH")
                        .notes("Deep clean and prepare room after guest checkout - Room " +
                                room.getRoomNumber())
                        .build();
                tasks.add(task);
            }

            taskRepository.saveAll(tasks);
            log.info("Created {} checkout cleaning tasks for reservation: {}",
                    tasks.size(), event.getReservationId());

        } catch (Exception e) {
            log.error("Error creating checkout tasks for reservation {}: {}",
                    event.getReservationId(), e.getMessage(), e);
        }
    }

    @Async
    @EventListener
    @Transactional
    public void handleCheckIn(ReservationEvent event) {
        if (!"CHECKED_IN".equals(event.getEventType()) || !config.isAutoCreateHousekeeping()) {
            return;
        }

        log.info("Creating turndown service tasks for reservation: {}",
                event.getReservationId());

        try {
            Reservation reservation = reservationRepository
                    .findById(event.getReservationId())
                    .orElseThrow(() -> new RuntimeException(
                            "Reservation not found: " + event.getReservationId()));

            if (reservation.getRooms() == null || reservation.getRooms().isEmpty()) {
                return;
            }

            // Create daily turndown service tasks for multi-day stays
            List<HousekeepingTask> tasks = new ArrayList<>();
            LocalDate currentDate = reservation.getCheckInDate();
            LocalDate checkOutDate = reservation.getCheckOutDate();

            while (currentDate.isBefore(checkOutDate)) {
                for (Room room : reservation.getRooms()) {
                    HousekeepingTask task = HousekeepingTask.builder()
                            .room(room)
                            .reservation(reservation)
                            .taskType("TURNDOWN")
                            .status("PENDING")
                            .scheduledDate(currentDate)
                            .priority("LOW")
                            .notes("Evening turndown service")
                            .build();
                    tasks.add(task);
                }
                currentDate = currentDate.plusDays(1);
            }

            if (!tasks.isEmpty()) {
                taskRepository.saveAll(tasks);
                log.info("Created {} turndown service tasks for reservation: {}",
                        tasks.size(), event.getReservationId());
            }

        } catch (Exception e) {
            log.error("Error creating turndown tasks for reservation {}: {}",
                    event.getReservationId(), e.getMessage(), e);
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\IntelligentReservationAutomationService.java ==== 
package com.example.stayops.automation;

import com.example.stayops.entity.*;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.repository.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.DayOfWeek;
import java.time.Instant;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Intelligent automation with ML-like decision making and predictive capabilities
 *
 * These automations go beyond simple rules to provide intelligent, context-aware
 * reservation management that adapts to patterns and optimizes outcomes.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class IntelligentReservationAutomationService {

    private final ReservationRepository reservationRepository;
    private final GuestRepository guestRepository;
    private final RoomRepository roomRepository;
    private final AuditLogRepository auditLogRepository;

    /**
     * SCENARIO 16: Intelligent cancellation prediction
     * Identify reservations likely to be cancelled based on patterns
     */
    @Transactional
    public int predictAndFlagRiskyCancellations() {
        log.info("Analyzing cancellation risk patterns...");

        List<Reservation> upcomingReservations = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED ||
                        r.getStatus() == ReservationStatus.PENDING)
                .filter(r -> r.getCheckInDate().isAfter(LocalDate.now()))
                .toList();

        int flaggedCount = 0;
        for (Reservation reservation : upcomingReservations) {
            int riskScore = calculateCancellationRisk(reservation);

            if (riskScore >= 70) { // High risk
                logAudit("RESERVATION", reservation.getReservationId().toString(),
                        "HIGH_CANCELLATION_RISK", "SYSTEM", "AI_PREDICTION",
                        "Cancellation risk score: " + riskScore + "%");

                flaggedCount++;
                log.warn("High cancellation risk detected for reservation {} (score: {})",
                        reservation.getReservationId(), riskScore);

                // TODO: Offer incentives to retain booking
            }
        }

        return flaggedCount;
    }

    /**
     * SCENARIO 17: Dynamic room assignment optimization
     * Assign rooms based on guest preferences and operational efficiency
     */
    @Transactional
    public int optimizeRoomAssignments() {
        log.info("Optimizing room assignments for tomorrow's arrivals...");

        LocalDate tomorrow = LocalDate.now().plusDays(1);
        List<Reservation> tomorrowArrivals = reservationRepository.findAll().stream()
                .filter(r -> r.getCheckInDate().equals(tomorrow))
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED)
                .toList();

        int optimizedCount = 0;
        for (Reservation reservation : tomorrowArrivals) {
            // Smart assignment considering:
            // - Guest preferences (floor, view, proximity)
            // - Housekeeping efficiency (group nearby rooms)
            // - Noise considerations (families away from business travelers)
            // - Length of stay (longer stays get better rooms)

            Room optimalRoom = findOptimalRoom(reservation);
            if (optimalRoom != null) {
                reservation.getRooms().clear();
                reservation.getRooms().add(optimalRoom);
                reservationRepository.save(reservation);

                logAudit("RESERVATION", reservation.getReservationId().toString(),
                        "OPTIMIZED_ROOM_ASSIGNMENT", "SYSTEM", "AI_OPTIMIZATION",
                        "Assigned optimal room: " + optimalRoom.getRoomNumber());

                optimizedCount++;
            }
        }

        return optimizedCount;
    }

    /**
     * SCENARIO 18: Proactive early check-in management
     * Identify opportunities for early check-in based on room availability
     */
    @Transactional
    public int offerEarlyCheckIn() {
        log.info("Identifying early check-in opportunities...");

        LocalDate today = LocalDate.now();
        List<Reservation> todayArrivals = reservationRepository.findAll().stream()
                .filter(r -> r.getCheckInDate().equals(today))
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED)
                .toList();

        int offersCount = 0;
        for (Reservation reservation : todayArrivals) {
            // Check if assigned room is ready before standard check-in time
            if (isRoomReadyEarly(reservation)) {
                // Send notification offering early check-in
                logAudit("RESERVATION", reservation.getReservationId().toString(),
                        "EARLY_CHECKIN_OFFER", "SYSTEM", "AUTOMATION",
                        "Offered early check-in - room ready");

                offersCount++;
                log.info("Offered early check-in to reservation {}",
                        reservation.getReservationId());
            }
        }

        return offersCount;
    }

    /**
     * SCENARIO 19: Intelligent extension suggestions
     * Suggest stay extensions to guests based on availability and patterns
     */
    @Transactional
    public int suggestStayExtensions() {
        log.info("Identifying stay extension opportunities...");

        LocalDate tomorrow = LocalDate.now().plusDays(1);

        // Find guests checking out tomorrow
        List<Reservation> checkoutTomorrow = reservationRepository.findAll().stream()
                .filter(r -> r.getCheckOutDate().equals(tomorrow))
                .filter(r -> r.getStatus() == ReservationStatus.CHECKED_IN ||
                        r.getStatus() == ReservationStatus.OCCUPIED)
                .toList();

        int suggestionsCount = 0;
        for (Reservation reservation : checkoutTomorrow) {
            // Check if room is available for extension
            if (canExtendStay(reservation)) {
                // Offer extension with special rate
                BigDecimal extensionRate = calculateExtensionRate(reservation);

                logAudit("RESERVATION", reservation.getReservationId().toString(),
                        "EXTENSION_SUGGESTED", "SYSTEM", "AUTOMATION",
                        "Suggested extension at rate: LKR " + extensionRate);

                suggestionsCount++;
                log.info("Suggested stay extension to reservation {} at LKR {}",
                        reservation.getReservationId(), extensionRate);
            }
        }

        return suggestionsCount;
    }

    /**
     * SCENARIO 20: Housekeeping priority optimization
     * Dynamically prioritize room cleaning based on check-in times and VIP status
     */
    @Transactional
    public int optimizeHousekeepingPriority() {
        log.info("Optimizing housekeeping priorities...");

        LocalDate today = LocalDate.now();

        // Get today's checkouts and arrivals
        List<Reservation> checkouts = reservationRepository.findAll().stream()
                .filter(r -> r.getCheckOutDate().equals(today))
                .toList();

        List<Reservation> arrivals = reservationRepository.findAll().stream()
                .filter(r -> r.getCheckInDate().equals(today))
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED)
                .toList();

        int prioritizedCount = 0;
        for (Reservation checkout : checkouts) {
            // Find if this room has same-day arrival
            boolean hasSameDayArrival = arrivals.stream()
                    .anyMatch(arrival -> arrival.getRooms().stream()
                            .anyMatch(room -> checkout.getRooms().contains(room)));

            if (hasSameDayArrival) {
                // Mark as high priority for housekeeping
                logAudit("ROOM", getRoomId(checkout),
                        "HOUSEKEEPING_HIGH_PRIORITY", "SYSTEM", "AUTOMATION",
                        "High priority: Same-day turn");

                prioritizedCount++;
            }
        }

        return prioritizedCount;
    }

    /**
     * SCENARIO 21: Intelligent overbooking with protection
     * Strategic overbooking based on historical no-show rates
     */
    @Transactional
    public int manageStrategicOverbooking() {
        log.info("Analyzing strategic overbooking opportunities...");

        // Calculate historical no-show rate
        double noShowRate = calculateNoShowRate();

        // Only overbook if rate is significant and we have backup plan
        if (noShowRate > 0.05) { // 5% or higher no-show rate
            List<LocalDate> highDemandDates = identifyHighDemandDates();

            int overbookingsAllowed = 0;
            for (LocalDate date : highDemandDates) {
                // Allow controlled overbooking with safety margin
                int safeOverbooking = calculateSafeOverbooking(date, noShowRate);

                if (safeOverbooking > 0) {
                    logAudit("SYSTEM", "OVERBOOKING_STRATEGY",
                            "STRATEGIC_OVERBOOKING_ALLOWED", "SYSTEM", "REVENUE_OPTIMIZATION",
                            "Allow " + safeOverbooking + " overbookings for " + date);

                    overbookingsAllowed += safeOverbooking;
                }
            }

            return overbookingsAllowed;
        }

        return 0;
    }

    /**
     * SCENARIO 22: Competitive pricing alerts
     * Monitor and alert on competitor pricing changes
     */
    @Transactional(readOnly = true)
    public int monitorCompetitivePricing() {
        log.info("Monitoring competitor pricing...");

        // Integration point for competitor price scraping
        Map<String, BigDecimal> competitorPrices = fetchCompetitorPrices();

        int alertsCreated = 0;
        for (Map.Entry<String, BigDecimal> entry : competitorPrices.entrySet()) {
            String competitor = entry.getKey();
            BigDecimal theirPrice = entry.getValue();

            // Compare with our pricing
            BigDecimal ourPrice = getCurrentAverageRate();

            if (theirPrice.compareTo(ourPrice.multiply(new BigDecimal("0.85"))) < 0) {
                // Competitor is 15% or more cheaper
                logAudit("PRICING", "COMPETITOR_ANALYSIS",
                        "COMPETITOR_UNDERPRICING", "SYSTEM", "MONITORING",
                        competitor + " pricing 15% lower: LKR " + theirPrice);

                alertsCreated++;
                log.warn("Competitor {} pricing alert: LKR {} vs our LKR {}",
                        competitor, theirPrice, ourPrice);
            }
        }

        return alertsCreated;
    }

    /**
     * SCENARIO 23: Guest profile completion automation
     * Remind guests to complete profiles for better experience
     */
    @Transactional(readOnly = true)
    public int requestProfileCompletion() {
        log.info("Identifying incomplete guest profiles...");

        List<Reservation> upcomingReservations = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED)
                .filter(r -> r.getCheckInDate().isAfter(LocalDate.now()))
                .filter(r -> r.getCheckInDate().isBefore(LocalDate.now().plusDays(7)))
                .toList();

        int requestsCount = 0;
        for (Reservation reservation : upcomingReservations) {
            if (reservation.getGuest() != null && isProfileIncomplete(reservation.getGuest())) {
                log.info("Requesting profile completion from guest {} for reservation {}",
                        reservation.getGuest().getEmail(),
                        reservation.getReservationId());
                requestsCount++;
            }
        }

        return requestsCount;
    }

    /**
     * SCENARIO 24: Automatic amenity preferences detection
     * Learn and remember guest amenity preferences
     */
    @Transactional
    public int detectAmenityPreferences() {
        log.info("Analyzing guest amenity preferences...");

        // Analyze past reservations to detect patterns
        List<Guest> repeatGuests = findRepeatGuests();

        int preferencesDetected = 0;
        for (Guest guest : repeatGuests) {
            Map<String, Integer> amenityFrequency = analyzeGuestAmenities(guest);

            if (!amenityFrequency.isEmpty()) {
                String topPreferences = amenityFrequency.entrySet().stream()
                        .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
                        .limit(3)
                        .map(Map.Entry::getKey)
                        .collect(Collectors.joining(", "));

                logAudit("GUEST", guest.getGuestId(),
                        "PREFERENCES_DETECTED", "SYSTEM", "AI_LEARNING",
                        "Detected preferences: " + topPreferences);

                preferencesDetected++;
            }
        }

        return preferencesDetected;
    }

    /**
     * SCENARIO 25: Predictive maintenance based on usage
     * Predict room maintenance needs based on occupancy patterns
     */
    @Transactional
    public int schedulePredictiveMaintenance() {
        log.info("Analyzing predictive maintenance needs...");

        List<Room> allRooms = roomRepository.findAll();

        int maintenanceScheduled = 0;
        for (Room room : allRooms) {
            // Calculate usage intensity
            int usageScore = calculateRoomUsageIntensity(room);

            if (usageScore >= 80) { // High usage
                // Schedule preventive maintenance
                logAudit("ROOM", room.getId().toString(),
                        "PREDICTIVE_MAINTENANCE", "SYSTEM", "AI_PREDICTION",
                        "High usage detected - schedule maintenance (score: " + usageScore + ")");

                maintenanceScheduled++;
                log.info("Scheduled predictive maintenance for room {} (usage score: {})",
                        room.getRoomNumber(), usageScore);
            }
        }

        return maintenanceScheduled;
    }

    /**
     * SCENARIO 26: Intelligent upsell recommendations
     * Recommend room upgrades and add-ons based on guest profile
     */
    @Transactional(readOnly = true)
    public int generateUpsellRecommendations() {
        log.info("Generating intelligent upsell recommendations...");

        LocalDate nextWeek = LocalDate.now().plusDays(7);
        List<Reservation> upcomingReservations = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED)
                .filter(r -> r.getCheckInDate().isBefore(nextWeek))
                .filter(r -> r.getCheckInDate().isAfter(LocalDate.now()))
                .toList();

        int recommendationsCount = 0;
        for (Reservation reservation : upcomingReservations) {
            // Analyze guest spending patterns and preferences
            List<String> recommendations = generatePersonalizedUpsells(reservation);

            if (!recommendations.isEmpty()) {
                log.info("Generated upsell recommendations for reservation {}: {}",
                        reservation.getReservationId(), recommendations);
                recommendationsCount++;
            }
        }

        return recommendationsCount;
    }

    /**
     * SCENARIO 27: Automatic language preference detection
     * Detect and remember guest language preferences
     */
    @Transactional
    public int detectLanguagePreferences() {
        log.info("Detecting guest language preferences...");

        List<Guest> allGuests = guestRepository.findAll();

        int preferencesDetected = 0;
        for (Guest guest : allGuests) {
            // Analyze nationality, email patterns, phone prefix
            String detectedLanguage = detectPreferredLanguage(guest);

            if (detectedLanguage != null) {
                logAudit("GUEST", guest.getGuestId(),
                        "LANGUAGE_DETECTED", "SYSTEM", "AI_DETECTION",
                        "Detected language preference: " + detectedLanguage);

                preferencesDetected++;
            }
        }

        return preferencesDetected;
    }

    /**
     * SCENARIO 28: Smart cancellation offers
     * Offer alternatives instead of straight cancellation
     */
    @Transactional
    public int offerCancellationAlternatives() {
        log.info("Checking for cancellation requests...");

        // This would integrate with a cancellation request system
        // When guest initiates cancellation, offer:
        // 1. Date change without penalty
        // 2. Downgrade to cheaper room
        // 3. Convert to credit for future use
        // 4. Refer to partner property

        int alternativesOffered = 0;
        // Implementation would track cancellation requests

        return alternativesOffered;
    }

    /**
     * SCENARIO 29: Automatic special occasion detection
     * Detect honeymoons, anniversaries, birthdays from booking patterns
     */
    @Transactional
    public int detectSpecialOccasions() {
        log.info("Detecting special occasions...");

        List<Reservation> upcomingReservations = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED)
                .filter(r -> r.getCheckInDate().isAfter(LocalDate.now()))
                .filter(r -> r.getCheckInDate().isBefore(LocalDate.now().plusDays(14)))
                .toList();

        int occasionsDetected = 0;
        for (Reservation reservation : upcomingReservations) {
            String occasion = detectOccasion(reservation);

            if (occasion != null) {
                logAudit("RESERVATION", reservation.getReservationId().toString(),
                        "SPECIAL_OCCASION_DETECTED", "SYSTEM", "AI_DETECTION",
                        "Detected: " + occasion);

                occasionsDetected++;
                log.info("Special occasion detected for reservation {}: {}",
                        reservation.getReservationId(), occasion);
            }
        }

        return occasionsDetected;
    }

    /**
     * SCENARIO 30: Peak hour arrival management
     * Spread check-ins to avoid lobby congestion
     */
    @Transactional
    public int optimizeArrivalTimes() {
        log.info("Optimizing arrival time distribution...");

        LocalDate tomorrow = LocalDate.now().plusDays(1);
        List<Reservation> tomorrowArrivals = reservationRepository.findAll().stream()
                .filter(r -> r.getCheckInDate().equals(tomorrow))
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED)
                .toList();

        // If too many arrivals at standard check-in time
        if (tomorrowArrivals.size() > 20) {
            int optimizedCount = 0;

            // Suggest staggered arrival times
            for (Reservation reservation : tomorrowArrivals) {
                // Offer incentive for early/late check-in
                log.info("Suggesting optimized arrival time for reservation {}",
                        reservation.getReservationId());
                optimizedCount++;
            }

            return optimizedCount;
        }

        return 0;
    }

    // ========================================================================
    // HELPER METHODS
    // ========================================================================

    private int calculateCancellationRisk(Reservation reservation) {
        int riskScore = 0;

        // Factor 1: Booking lead time (last-minute bookings more likely to cancel)
        long leadTime = ChronoUnit.DAYS.between(reservation.getCreatedAt().atZone(
                java.time.ZoneId.systemDefault()).toLocalDate(), reservation.getCheckInDate());
        if (leadTime < 7) riskScore += 30;

        // Factor 2: Guest history (repeat no-shows)
        if (reservation.getGuest() != null) {
            long previousCancellations = reservationRepository.findAll().stream()
                    .filter(r -> r.getGuest().equals(reservation.getGuest()))
                    .filter(r -> r.getStatus() == ReservationStatus.CANCELLED)
                    .count();
            if (previousCancellations > 0) riskScore += 25;
        }

        // Factor 3: No deposit received
        if (reservation.getStatus() == ReservationStatus.PENDING) riskScore += 20;

        // Factor 4: Weekend booking from long distance
        if (reservation.getCheckInDate().getDayOfWeek() == DayOfWeek.SATURDAY ||
                reservation.getCheckInDate().getDayOfWeek() == DayOfWeek.FRIDAY) {
            riskScore += 10;
        }

        return Math.min(100, riskScore);
    }

    private Room findOptimalRoom(Reservation reservation) {
        // Smart room selection algorithm
        List<Room> availableRooms = roomRepository.findAll().stream()
                .filter(room -> isRoomAvailable(room, reservation.getCheckInDate()))
                .toList();

        if (availableRooms.isEmpty()) return null;

        // Score each room based on multiple factors
        return availableRooms.stream()
                .max(Comparator.comparingInt(room -> calculateRoomScore(room, reservation)))
                .orElse(null);
    }

    private int calculateRoomScore(Room room, Reservation reservation) {
        int score = 0;

        // Longer stays get better rooms
        long nights = ChronoUnit.DAYS.between(
                reservation.getCheckInDate(), reservation.getCheckOutDate());
        if (nights >= 5) score += 20;

        // VIP guests get premium rooms
        // score += guestIsVIP(reservation.getGuest()) ? 30 : 0;

        // Families get rooms away from business area
        if (reservation.getReservationDetails() != null &&
                reservation.getReservationDetails().getKids() > 0) {
            score += 10;
        }

        return score;
    }

    private boolean isRoomReadyEarly(Reservation reservation) {
        // Check housekeeping status
        return true; // Placeholder
    }

    private boolean canExtendStay(Reservation reservation) {
        // Check if room available for extension
        LocalDate nextDay = reservation.getCheckOutDate();
        return reservation.getRooms().stream()
                .allMatch(room -> isRoomAvailable(room, nextDay));
    }

    private BigDecimal calculateExtensionRate(Reservation reservation) {
        // Offer discounted rate for extension
        return new BigDecimal("15000.00"); // Placeholder
    }

    private double calculateNoShowRate() {
        // Calculate historical no-show percentage
        long totalReservations = reservationRepository.count();
        long noShows = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.CANCELLED)
                .count();

        return totalReservations > 0 ? (double) noShows / totalReservations : 0.0;
    }

    private List<LocalDate> identifyHighDemandDates() {
        // Identify dates with high booking demand
        return Arrays.asList(LocalDate.now().plusDays(30)); // Placeholder
    }

    private int calculateSafeOverbooking(LocalDate date, double noShowRate) {
        int totalRooms = roomRepository.findAll().size();
        return (int) Math.floor(totalRooms * noShowRate * 0.5); // Conservative 50% of expected no-shows
    }

    private Map<String, BigDecimal> fetchCompetitorPrices() {
        // Integration point for competitor monitoring
        return new HashMap<>();
    }

    private BigDecimal getCurrentAverageRate() {
        return new BigDecimal("20000.00"); // Placeholder
    }

    private boolean isProfileIncomplete(Guest guest) {
        return guest.getNationality() == null || guest.getPhone() == null;
    }

    private List<Guest> findRepeatGuests() {
        return guestRepository.findAll().stream()
                .filter(guest -> {
                    long bookingCount = reservationRepository.findAll().stream()
                            .filter(r -> r.getGuest().equals(guest))
                            .count();
                    return bookingCount >= 2;
                })
                .toList();
    }

    private Map<String, Integer> analyzeGuestAmenities(Guest guest) {
        // Analyze past reservation amenity requests
        return new HashMap<>();
    }

    private int calculateRoomUsageIntensity(Room room) {
        // Calculate usage score based on occupancy frequency
        long recentBookings = reservationRepository.findAll().stream()
                .filter(r -> r.getRooms().contains(room))
                .filter(r -> r.getCheckOutDate().isAfter(LocalDate.now().minusDays(90)))
                .count();

        return (int) Math.min(100, (recentBookings / 90.0) * 100);
    }

    private List<String> generatePersonalizedUpsells(Reservation reservation) {
        List<String> recommendations = new ArrayList<>();

        // Based on reservation details and guest history
        if (reservation.getReservationDetails() != null &&
                reservation.getReservationDetails().getKids() > 0) {
            recommendations.add("Family Fun Package");
        }

        return recommendations;
    }

    private String detectPreferredLanguage(Guest guest) {
        // Analyze nationality, name patterns
        if (guest.getNationality() != null) {
            if (guest.getNationality().equalsIgnoreCase("China")) return "Chinese";
            if (guest.getNationality().equalsIgnoreCase("Japan")) return "Japanese";
            if (guest.getNationality().equalsIgnoreCase("France")) return "French";
        }
        return "English"; // Default
    }

    private String detectOccasion(Reservation reservation) {
        // Analyze patterns: 2-night weekend booking = romantic, specific dates = anniversary
        long nights = ChronoUnit.DAYS.between(
                reservation.getCheckInDate(), reservation.getCheckOutDate());

        if (nights <= 3 && (reservation.getCheckInDate().getDayOfWeek() == DayOfWeek.FRIDAY ||
                reservation.getCheckInDate().getDayOfWeek() == DayOfWeek.SATURDAY)) {
            if (reservation.getReservationDetails() != null &&
                    reservation.getReservationDetails().getAdults() == 2 &&
                    reservation.getReservationDetails().getKids() == 0) {
                return "Romantic Getaway/Honeymoon";
            }
        }

        return null;
    }

    private boolean isRoomAvailable(Room room, LocalDate date) {
        return reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() != ReservationStatus.CANCELLED)
                .filter(r -> !r.getCheckInDate().isAfter(date) &&
                        !r.getCheckOutDate().isBefore(date))
                .noneMatch(r -> r.getRooms().contains(room));
    }

    private String getRoomId(Reservation reservation) {
        return reservation.getRooms().isEmpty() ? "UNKNOWN" :
                reservation.getRooms().iterator().next().getId().toString();
    }

    private void logAudit(String entityType, String entityId, String action,
                          String actorType, String actorId, String description) {
        try {
            AuditLog auditLog = AuditLog.builder()
                    .entityType(entityType)
                    .entityId(entityId)
                    .action(action)
                    .actorType(actorType)
                    .actorId(actorId)
                    .description(description)
                    .timestamp(Instant.now())
                    .build();
            auditLogRepository.save(auditLog);
        } catch (Exception e) {
            log.error("Failed to create audit log: {}", e.getMessage());
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\NightlyAuditJob.java ==== 
package com.example.stayops.automation;

import com.example.stayops.entity.Reservation;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.repository.HousekeepingTaskRepository;
import com.example.stayops.repository.ReservationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class NightlyAuditJob {

    private final ReservationRepository reservationRepository;
    private final HousekeepingTaskRepository housekeepingTaskRepository;

    /**
     * Night audit job - runs at 2 AM daily
     * Finalizes day revenue, generates reports
     */
    @Scheduled(cron = "0 0 2 * * *") // 2 AM daily
    @Transactional
    public void runNightAudit() {
        log.info("===== STARTING NIGHTLY AUDIT =====");

        try {
            LocalDate auditDate = LocalDate.now().minusDays(1);

            // 1. Generate arrival/departure lists for today
            generateDailyLists(LocalDate.now());

            // 2. Check for overdue housekeeping tasks
            checkOverdueTasks(LocalDate.now());

            // 3. Generate occupancy report
            generateOccupancyReport(LocalDate.now());

            // 4. TODO: Close folios for checked-out guests
            // 5. TODO: Generate revenue report
            // 6. TODO: Sync with accounting system

            log.info("===== NIGHTLY AUDIT COMPLETED SUCCESSFULLY =====");

        } catch (Exception e) {
            log.error("===== NIGHTLY AUDIT FAILED =====", e);
        }
    }

    private void generateDailyLists(LocalDate date) {
        log.info("Generating daily lists for: {}", date);

        List<Reservation> arrivals = reservationRepository.findByCheckInDate(date);
        List<Reservation> departures = reservationRepository.findByCheckOutDate(date);

        log.info("Expected Arrivals: {}", arrivals.size());
        log.info("Expected Departures: {}", departures.size());

        // Log VIP guests
        arrivals.stream()
                .filter(r -> r.getReservationDetails() != null &&
                        r.getReservationDetails().getSpecialRequests() != null &&
                        r.getReservationDetails().getSpecialRequests().toUpperCase().contains("VIP"))
                .forEach(r -> log.info("VIP Arrival: Guest {}, Rooms: {}",
                        r.getGuest() != null ? r.getGuest().getGuestId() : "Unknown",
                        r.getRooms() != null ? r.getRooms().size() : 0));
    }

    private void checkOverdueTasks(LocalDate date) {
        var overdueTasks = housekeepingTaskRepository.findOverdueTasks(date.minusDays(1));

        if (!overdueTasks.isEmpty()) {
            log.warn("Found {} overdue housekeeping tasks", overdueTasks.size());
            // TODO: Send alert to housekeeping manager
        }
    }

    private void generateOccupancyReport(LocalDate date) {
        List<Reservation> occupiedReservations = reservationRepository.findAll().stream()
                .filter(r -> (r.getStatus() == ReservationStatus.CHECKED_IN ||
                        r.getStatus() == ReservationStatus.OCCUPIED) &&
                        !r.getCheckInDate().isAfter(date) &&
                        !r.getCheckOutDate().isBefore(date))
                .toList();

        int occupiedRooms = (int) occupiedReservations.stream()
                .flatMap(r -> r.getRooms() != null ? r.getRooms().stream() : java.util.stream.Stream.empty())
                .distinct()
                .count();

        log.info("Occupancy Report for {}: {} occupied rooms from {} reservations",
                date, occupiedRooms, occupiedReservations.size());
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\PaymentAutomationListener.java ==== 
package com.example.stayops.automation;

import com.example.stayops.config.AutomationConfig;
import com.example.stayops.entity.Reservation;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.event.EventPublisher;
import com.example.stayops.event.PaymentEvent;
import com.example.stayops.event.ReservationEvent;
import com.example.stayops.repository.ReservationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;

@Component
@RequiredArgsConstructor
@Slf4j
public class PaymentAutomationListener {

    private final ReservationRepository reservationRepository;
    private final EventPublisher eventPublisher;
    private final AutomationConfig config;

    @Async
    @EventListener
    @Transactional
    public void handlePaymentSuccess(PaymentEvent event) {
        if (!"SUCCESS".equals(event.getEventType()) || !config.isAutoConfirmOnPayment()) {
            return;
        }

        log.info("Payment success event received for reservation: {}",
                event.getReservationId());

        try {
            Reservation reservation = reservationRepository
                    .findById(event.getReservationId())
                    .orElseThrow(() -> new RuntimeException(
                            "Reservation not found: " + event.getReservationId()));

            // Auto-confirm reservation on successful payment
            if (reservation.getStatus() == ReservationStatus.PENDING) {
                ReservationStatus oldStatus = reservation.getStatus();
                reservation.setStatus(ReservationStatus.CONFIRMED);
                reservationRepository.save(reservation);

                log.info("Auto-confirmed reservation {} after successful payment",
                        reservation.getReservationId());

                // Publish confirmation event for other automations
                eventPublisher.publishReservationEvent(ReservationEvent.builder()
                        .reservationId(reservation.getReservationId())
                        .guestId(reservation.getGuest().getGuestId())
                        .previousStatus(oldStatus)
                        .newStatus(ReservationStatus.CONFIRMED)
                        .eventType("CONFIRMED")
                        .eventTime(Instant.now())
                        .triggeredBy("SYSTEM_PAYMENT_AUTO")
                        .build());
            } else {
                log.info("Reservation {} status is {}, no auto-confirmation needed",
                        reservation.getReservationId(), reservation.getStatus());
            }
        } catch (Exception e) {
            log.error("Error in payment success handler for reservation {}: {}",
                    event.getReservationId(), e.getMessage(), e);
        }
    }

    @Async
    @EventListener
    @Transactional
    public void handlePaymentFailure(PaymentEvent event) {
        if (!"FAILED".equals(event.getEventType())) {
            return;
        }

        log.warn("Payment failed for reservation: {}", event.getReservationId());

        // TODO: Implement notification to guest and operations team
        // TODO: Optionally cancel reservation or mark for follow-up
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\ReservationAutomationJob.java ==== 
package com.example.stayops.automation;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

/**
 * Scheduled jobs for automated reservation management
 *
 * These jobs run automatically in the background to handle:
 * - Auto-cancellation of unconfirmed reservations
 * - Auto-checkout of overdue guests
 * - Auto-check-in processing
 * - Sending reminders
 * - Archiving old data
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class ReservationAutomationJob {

    private final ReservationAutomationService reservationAutomationService;

    /**
     * CRITICAL JOB: Check for unconfirmed reservations every 30 minutes
     * This ensures we catch reservations that need to be cancelled 3 hours before check-in
     */
    @Scheduled(cron = "0 */30 * * * *") // Every 30 minutes
    public void autoReleaseUnconfirmedReservations() {
        log.info("===== STARTING: Auto-release unconfirmed reservations =====");
        try {
            int cancelled = reservationAutomationService.autoReleaseUnconfirmedReservations();
            log.info("Auto-release job completed successfully. Cancelled: {}", cancelled);
        } catch (Exception e) {
            log.error("Error in auto-release unconfirmed reservations job", e);
        }
        log.info("===== COMPLETED: Auto-release unconfirmed reservations =====");
    }

    /**
     * Check for overdue checkouts every hour at minute 15
     */
    @Scheduled(cron = "0 15 * * * *") // Every hour at :15
    public void autoCheckoutOverdueReservations() {
        log.info("===== STARTING: Auto-checkout overdue reservations =====");
        try {
            int checkedOut = reservationAutomationService.autoCheckoutOverdueReservations();
            log.info("Auto-checkout job completed successfully. Checked out: {}", checkedOut);
        } catch (Exception e) {
            log.error("Error in auto-checkout overdue reservations job", e);
        }
        log.info("===== COMPLETED: Auto-checkout overdue reservations =====");
    }

    /**
     * Auto-check-in arriving guests - runs every hour after 2 PM
     * This gives flexibility for early arrivals while automating the process
     */
    @Scheduled(cron = "0 0 14-23 * * *") // Every hour from 2 PM to 11 PM
    public void autoUpdateArrivingGuests() {
        log.info("===== STARTING: Auto-update arriving guests =====");
        try {
            int updated = reservationAutomationService.autoUpdateArrivingGuests();
            log.info("Auto-update arriving guests completed successfully. Updated: {}", updated);
        } catch (Exception e) {
            log.error("Error in auto-update arriving guests job", e);
        }
        log.info("===== COMPLETED: Auto-update arriving guests =====");
    }

    /**
     * Send arrival reminders daily at 9 AM
     */
    @Scheduled(cron = "0 0 9 * * *") // 9 AM daily
    public void sendArrivalReminders() {
        log.info("===== STARTING: Send arrival reminders =====");
        try {
            int sent = reservationAutomationService.sendArrivalReminders();
            log.info("Arrival reminders job completed successfully. Reminders sent: {}", sent);
        } catch (Exception e) {
            log.error("Error in send arrival reminders job", e);
        }
        log.info("===== COMPLETED: Send arrival reminders =====");
    }

    /**
     * Archive old reservations - runs weekly on Sunday at 3 AM
     */
    @Scheduled(cron = "0 0 3 * * SUN") // 3 AM every Sunday
    public void archiveOldReservations() {
        log.info("===== STARTING: Archive old reservations =====");
        try {
            int archived = reservationAutomationService.archiveOldReservations();
            log.info("Archive old reservations job completed successfully. Archived: {}", archived);
        } catch (Exception e) {
            log.error("Error in archive old reservations job", e);
        }
        log.info("===== COMPLETED: Archive old reservations =====");
    }

    /**
     * Health check job - runs every 5 minutes to ensure automation system is alive
     */
    @Scheduled(cron = "0 */5 * * * *") // Every 5 minutes
    public void healthCheck() {
        log.debug("Reservation automation system health check - OK");
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\ReservationAutomationService.java ==== 
package com.example.stayops.automation;

import com.example.stayops.entity.AuditLog;
import com.example.stayops.entity.Reservation;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.event.EventPublisher;
import com.example.stayops.event.ReservationEvent;
import com.example.stayops.repository.AuditLogRepository;
import com.example.stayops.repository.ReservationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class ReservationAutomationService {

    private final ReservationRepository reservationRepository;
    private final EventPublisher eventPublisher;
    private final AuditLogRepository auditLogRepository;

    /**
     * REQUIREMENT 1: Auto-cancel reservations not confirmed 3 hours before check-in
     */
    @Transactional
    public int autoReleaseUnconfirmedReservations() {
        log.info("Running auto-release for unconfirmed reservations...");

        LocalDateTime now = LocalDateTime.now();
        LocalDateTime threeHoursFromNow = now.plusHours(3);
        LocalDate checkInCutoffDate = threeHoursFromNow.toLocalDate();

        // Find PENDING reservations with check-in today or tomorrow that are within 3 hours
        List<Reservation> pendingReservations = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.PENDING)
                .filter(r -> {
                    LocalDate checkIn = r.getCheckInDate();
                    // If check-in is today, check if it's within 3 hours
                    if (checkIn.equals(LocalDate.now())) {
                        return true; // Will be processed
                    }
                    // If check-in is tomorrow and we're within 3 hours of midnight
                    if (checkIn.equals(LocalDate.now().plusDays(1))) {
                        return now.getHour() >= 21; // After 9 PM, it's within 3 hours of next day
                    }
                    return false;
                })
                .toList();

        int cancelledCount = 0;
        for (Reservation reservation : pendingReservations) {
            LocalDateTime checkInDateTime = reservation.getCheckInDate()
                    .atTime(14, 0); // Assume 2 PM check-in time

            // If current time is within 3 hours of check-in
            if (now.plusHours(3).isAfter(checkInDateTime) || now.isAfter(checkInDateTime)) {
                ReservationStatus oldStatus = reservation.getStatus();
                reservation.setStatus(ReservationStatus.CANCELLED);

                // Clear room associations to free up inventory
                if (reservation.getRooms() != null) {
                    reservation.getRooms().clear();
                }

                reservationRepository.save(reservation);

                // Log audit
                logAudit("RESERVATION", reservation.getReservationId().toString(),
                        "AUTO_CANCEL_UNCONFIRMED", "SYSTEM", "AUTOMATION",
                        "Auto-cancelled: Not confirmed 3 hours before check-in");

                // Publish event
                eventPublisher.publishReservationEvent(ReservationEvent.builder()
                        .reservationId(reservation.getReservationId())
                        .guestId(reservation.getGuest() != null ?
                                reservation.getGuest().getGuestId() : null)
                        .previousStatus(oldStatus)
                        .newStatus(ReservationStatus.CANCELLED)
                        .eventType("AUTO_CANCELLED_UNCONFIRMED")
                        .eventTime(Instant.now())
                        .triggeredBy("SYSTEM_AUTO_CANCEL_3H")
                        .build());

                cancelledCount++;
                log.info("Auto-cancelled reservation {} - not confirmed before 3-hour deadline",
                        reservation.getReservationId());

                // TODO: Send notification to guest about cancellation
            }
        }

        log.info("Auto-release completed: {} reservations cancelled", cancelledCount);
        return cancelledCount;
    }

    /**
     * REQUIREMENT 2: Auto-confirm same-day reservations
     * This is called from ReservationServiceImpl during creation
     */
    public ReservationStatus determineInitialStatus(LocalDate checkInDate, ReservationStatus requestedStatus) {
        // If check-in is today, automatically confirm (skip PENDING status)
        if (checkInDate.equals(LocalDate.now())) {
            log.info("Same-day reservation detected - auto-confirming");
            return ReservationStatus.CONFIRMED;
        }

        // Otherwise, use the requested status (typically PENDING)
        return requestedStatus != null ? requestedStatus : ReservationStatus.PENDING;
    }

    /**
     * ADDITIONAL AUTOMATION: Auto-checkout past-due reservations
     */
    @Transactional
    public int autoCheckoutOverdueReservations() {
        log.info("Running auto-checkout for overdue reservations...");

        LocalDate yesterday = LocalDate.now().minusDays(1);

        // Find reservations that should have checked out yesterday or earlier
        List<Reservation> overdueReservations = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.CHECKED_IN ||
                        r.getStatus() == ReservationStatus.OCCUPIED)
                .filter(r -> r.getCheckOutDate().isBefore(LocalDate.now()))
                .toList();

        int checkedOutCount = 0;
        for (Reservation reservation : overdueReservations) {
            ReservationStatus oldStatus = reservation.getStatus();
            reservation.setStatus(ReservationStatus.CHECKED_OUT);
            reservationRepository.save(reservation);

            logAudit("RESERVATION", reservation.getReservationId().toString(),
                    "AUTO_CHECKOUT", "SYSTEM", "AUTOMATION",
                    "Auto-checked out: Past checkout date");

            eventPublisher.publishReservationEvent(ReservationEvent.builder()
                    .reservationId(reservation.getReservationId())
                    .guestId(reservation.getGuest() != null ?
                            reservation.getGuest().getGuestId() : null)
                    .previousStatus(oldStatus)
                    .newStatus(ReservationStatus.CHECKED_OUT)
                    .eventType("AUTO_CHECKED_OUT")
                    .eventTime(Instant.now())
                    .triggeredBy("SYSTEM_AUTO_CHECKOUT")
                    .build());

            checkedOutCount++;
            log.info("Auto-checked out reservation {} - past checkout date",
                    reservation.getReservationId());
        }

        log.info("Auto-checkout completed: {} reservations checked out", checkedOutCount);
        return checkedOutCount;
    }

    /**
     * ADDITIONAL AUTOMATION: Auto-transition CONFIRMED to CHECKED_IN on check-in date
     */
    @Transactional
    public int autoUpdateArrivingGuests() {
        log.info("Running auto-update for arriving guests...");

        LocalDate today = LocalDate.now();

        // Find CONFIRMED reservations with check-in today that haven't been manually checked in
        List<Reservation> arrivingReservations = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED)
                .filter(r -> r.getCheckInDate().equals(today))
                .toList();

        int updatedCount = 0;
        for (Reservation reservation : arrivingReservations) {
            // Only auto-check-in after 2 PM (typical check-in time)
            if (LocalDateTime.now().getHour() >= 14) {
                ReservationStatus oldStatus = reservation.getStatus();
                reservation.setStatus(ReservationStatus.CHECKED_IN);
                reservationRepository.save(reservation);

                logAudit("RESERVATION", reservation.getReservationId().toString(),
                        "AUTO_CHECK_IN", "SYSTEM", "AUTOMATION",
                        "Auto-checked in: Check-in date arrived");

                eventPublisher.publishReservationEvent(ReservationEvent.builder()
                        .reservationId(reservation.getReservationId())
                        .guestId(reservation.getGuest() != null ?
                                reservation.getGuest().getGuestId() : null)
                        .previousStatus(oldStatus)
                        .newStatus(ReservationStatus.CHECKED_IN)
                        .eventType("AUTO_CHECKED_IN")
                        .eventTime(Instant.now())
                        .triggeredBy("SYSTEM_AUTO_CHECK_IN")
                        .build());

                updatedCount++;
                log.info("Auto-checked in reservation {} - check-in date reached",
                        reservation.getReservationId());
            }
        }

        log.info("Auto-update arriving guests completed: {} reservations checked in", updatedCount);
        return updatedCount;
    }

    /**
     * ADDITIONAL AUTOMATION: Send reminders for upcoming arrivals
     */
    @Transactional(readOnly = true)
    public int sendArrivalReminders() {
        log.info("Sending arrival reminders...");

        LocalDate tomorrow = LocalDate.now().plusDays(1);

        // Find CONFIRMED reservations checking in tomorrow
        List<Reservation> tomorrowArrivals = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED)
                .filter(r -> r.getCheckInDate().equals(tomorrow))
                .toList();

        int remindersSent = 0;
        for (Reservation reservation : tomorrowArrivals) {
            // TODO: Implement actual email/SMS sending
            log.info("Reminder: Guest {} checking in tomorrow at reservation {}",
                    reservation.getGuest() != null ? reservation.getGuest().getEmail() : "Unknown",
                    reservation.getReservationId());

            logAudit("RESERVATION", reservation.getReservationId().toString(),
                    "REMINDER_SENT", "SYSTEM", "AUTOMATION",
                    "Sent check-in reminder for tomorrow");

            remindersSent++;
        }

        log.info("Arrival reminders sent: {}", remindersSent);
        return remindersSent;
    }

    /**
     * ADDITIONAL AUTOMATION: Clean up old cancelled/checked-out reservations
     */
    @Transactional
    public int archiveOldReservations() {
        log.info("Archiving old reservations...");

        LocalDate thirtyDaysAgo = LocalDate.now().minusDays(30);

        // Find old CANCELLED or CHECKED_OUT reservations
        List<Reservation> oldReservations = reservationRepository.findAll().stream()
                .filter(r -> r.getStatus() == ReservationStatus.CANCELLED ||
                        r.getStatus() == ReservationStatus.CHECKED_OUT)
                .filter(r -> r.getCheckOutDate().isBefore(thirtyDaysAgo))
                .toList();

        int archivedCount = 0;
        for (Reservation reservation : oldReservations) {
            // In a real system, you might move to archive table or mark as archived
            logAudit("RESERVATION", reservation.getReservationId().toString(),
                    "ARCHIVED", "SYSTEM", "AUTOMATION",
                    "Archived old reservation (30+ days past checkout)");

            archivedCount++;
        }

        log.info("Archived {} old reservations", archivedCount);
        return archivedCount;
    }

    // Helper method
    private void logAudit(String entityType, String entityId, String action,
                          String actorType, String actorId, String description) {
        try {
            AuditLog auditLog = AuditLog.builder()
                    .entityType(entityType)
                    .entityId(entityId)
                    .action(action)
                    .actorType(actorType)
                    .actorId(actorId)
                    .description(description)
                    .timestamp(Instant.now())
                    .build();
            auditLogRepository.save(auditLog);
        } catch (Exception e) {
            log.error("Failed to create audit log: {}", e.getMessage());
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\ReservationCleanupJobs.java ==== 
package com.example.stayops.automation;

import com.example.stayops.config.AutomationConfig;
import com.example.stayops.entity.Reservation;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.event.EventPublisher;
import com.example.stayops.event.ReservationEvent;
import com.example.stayops.repository.ReservationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.time.LocalDate;
import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class ReservationCleanupJobs {

    private final ReservationRepository reservationRepository;
    private final EventPublisher eventPublisher;
    private final AutomationConfig config;

    /**
     * Auto-mark no-shows - Runs every hour
     */
    @Scheduled(cron = "0 0 * * * *") // Every hour at minute 0
    @Transactional
    public void autoMarkNoShows() {
        if (!config.isAutoMarkNoShows()) {
            return;
        }

        log.info("Running no-show automation job");

        try {
            LocalDate cutoffDate = LocalDate.now().minusDays(1);

            // Find CONFIRMED reservations with check-in date before cutoff
            List<Reservation> potentialNoShows = reservationRepository.findAll().stream()
                    .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED &&
                            r.getCheckInDate().isBefore(LocalDate.now()) &&
                            r.getCheckInDate().isAfter(cutoffDate.minusDays(
                                    config.getNoShowGracePeriodHours() / 24)))
                    .toList();

            int markedCount = 0;
            for (Reservation reservation : potentialNoShows) {
                // Check if grace period has passed
                LocalDate graceCutoff = reservation.getCheckInDate()
                        .plusDays(config.getNoShowGracePeriodHours() / 24);

                if (LocalDate.now().isAfter(graceCutoff)) {
                    ReservationStatus oldStatus = reservation.getStatus();
                    reservation.setStatus(ReservationStatus.CANCELLED);
                    reservationRepository.save(reservation);

                    log.info("Marked reservation {} as NO-SHOW", reservation.getReservationId());

                    // Publish event
                    eventPublisher.publishReservationEvent(ReservationEvent.builder()
                            .reservationId(reservation.getReservationId())
                            .guestId(reservation.getGuest() != null ?
                                    reservation.getGuest().getGuestId() : null)
                            .previousStatus(oldStatus)
                            .newStatus(ReservationStatus.CANCELLED)
                            .eventType("NO_SHOW")
                            .eventTime(Instant.now())
                            .triggeredBy("SYSTEM_AUTO_NO_SHOW")
                            .build());

                    markedCount++;

                    // TODO: Apply no-show charges per policy
                    // TODO: Send notification to guest
                }
            }

            log.info("No-show automation completed. Marked {} reservations as no-show", markedCount);

        } catch (Exception e) {
            log.error("Error in no-show automation: {}", e.getMessage(), e);
        }
    }

    /**
     * Auto-cancel stale PENDING reservations - Runs every 6 hours
     */
    @Scheduled(cron = "0 0 */6 * * *") // Every 6 hours
    @Transactional
    public void autoReleaseStaleReservations() {
        log.info("Running stale reservation cleanup job");

        try {
            Instant staleCutoff = Instant.now()
                    .minusSeconds(config.getStalePendingHours() * 3600L);

            // Find PENDING reservations older than threshold
            List<Reservation> staleReservations = reservationRepository.findAll().stream()
                    .filter(r -> r.getStatus() == ReservationStatus.PENDING &&
                            r.getCreatedAt().isBefore(staleCutoff))
                    .toList();

            int cancelledCount = 0;
            for (Reservation reservation : staleReservations) {
                ReservationStatus oldStatus = reservation.getStatus();
                reservation.setStatus(ReservationStatus.CANCELLED);

                // Clear room associations to free up inventory
                if (reservation.getRooms() != null) {
                    reservation.setRoomsCollection(java.util.Collections.emptySet());
                }

                reservationRepository.save(reservation);

                log.info("Cancelled stale PENDING reservation {}", reservation.getReservationId());

                // Publish event
                eventPublisher.publishReservationEvent(ReservationEvent.builder()
                        .reservationId(reservation.getReservationId())
                        .guestId(reservation.getGuest() != null ?
                                reservation.getGuest().getGuestId() : null)
                        .previousStatus(oldStatus)
                        .newStatus(ReservationStatus.CANCELLED)
                        .eventType("STALE_CANCELLED")
                        .eventTime(Instant.now())
                        .triggeredBy("SYSTEM_AUTO_STALE_CLEANUP")
                        .build());

                cancelledCount++;

                // TODO: Send notification to guest about cancellation
            }

            log.info("Stale reservation cleanup completed. Cancelled {} reservations",
                    cancelledCount);

        } catch (Exception e) {
            log.error("Error in stale reservation cleanup: {}", e.getMessage(), e);
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\RoomAssignmentListener.java ==== 
package com.example.stayops.automation;

import com.example.stayops.config.AutomationConfig;
import com.example.stayops.entity.Reservation;
import com.example.stayops.event.ReservationEvent;
import com.example.stayops.repository.ReservationRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@Component
@RequiredArgsConstructor
@Slf4j
public class RoomAssignmentListener {

    private final ReservationRepository reservationRepository;
    private final RoomAssignmentService roomAssignmentService;
    private final AutomationConfig config;

    @Async
    @EventListener
    @Transactional
    public void handleReservationConfirmed(ReservationEvent event) {
        if (!"CONFIRMED".equals(event.getEventType()) || !config.isAutoAssignRooms()) {
            return;
        }

        log.info("Auto-assigning rooms for confirmed reservation: {}",
                event.getReservationId());

        try {
            Reservation reservation = reservationRepository
                    .findById(event.getReservationId())
                    .orElseThrow(() -> new RuntimeException(
                            "Reservation not found: " + event.getReservationId()));

            boolean success = roomAssignmentService.autoAssignRooms(reservation);

            if (!success) {
                log.error("Failed to auto-assign rooms for reservation: {}. " +
                        "Manual assignment required.", event.getReservationId());
                // TODO: Create notification/alert for operations team
                // TODO: Create incident ticket
            }
        } catch (Exception e) {
            log.error("Error in room assignment automation for reservation {}: {}",
                    event.getReservationId(), e.getMessage(), e);
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\automation\RoomAssignmentService.java ==== 
package com.example.stayops.automation;

import com.example.stayops.entity.Reservation;
import com.example.stayops.entity.Room;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.repository.ReservationRepository;
import com.example.stayops.repository.RoomRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class RoomAssignmentService {

    private final RoomRepository roomRepository;
    private final ReservationRepository reservationRepository;

    @Transactional
    public boolean autoAssignRooms(Reservation reservation) {
        log.info("Auto-assigning rooms for reservation: {}", reservation.getReservationId());

        // If rooms already assigned, skip
        if (reservation.getRooms() != null && !reservation.getRooms().isEmpty()) {
            log.info("Rooms already assigned for reservation: {}",
                    reservation.getReservationId());
            return true;
        }

        // Determine number of rooms needed (from reservation details or default to 1)
        int roomsNeeded = calculateRoomsNeeded(reservation);

        // Find available rooms
        List<Room> availableRooms = findAvailableRooms(
                reservation.getCheckInDate(),
                reservation.getCheckOutDate(),
                roomsNeeded
        );

        if (availableRooms.size() < roomsNeeded) {
            log.warn("Insufficient rooms available for reservation: {}. " +
                            "Needed: {}, Available: {}",
                    reservation.getReservationId(), roomsNeeded, availableRooms.size());
            return false;
        }

        // Assign best-fit rooms (smart assignment logic)
        Set<Room> assignedRooms = selectBestRooms(availableRooms, roomsNeeded, reservation);
        reservation.setRoomsCollection(assignedRooms);

        log.info("Successfully auto-assigned {} rooms to reservation: {}",
                assignedRooms.size(), reservation.getReservationId());

        return true;
    }

    private int calculateRoomsNeeded(Reservation reservation) {
        if (reservation.getReservationDetails() != null) {
            int totalGuests = reservation.getReservationDetails().getAdults() +
                    reservation.getReservationDetails().getKids();
            // 2 guests per room, round up
            return Math.max(1, (int) Math.ceil(totalGuests / 2.0));
        }
        return 1; // Default to 1 room
    }

    private List<Room> findAvailableRooms(LocalDate checkIn, LocalDate checkOut, int count) {
        List<Room> allRooms = roomRepository.findAll();

        return allRooms.stream()
                .filter(room -> isRoomAvailable(room, checkIn, checkOut))
                .limit(count * 3) // Get more than needed for better selection
                .collect(Collectors.toList());
    }

    private boolean isRoomAvailable(Room room, LocalDate checkIn, LocalDate checkOut) {
        List<Reservation> conflicts = reservationRepository
                .findOverlappingReservationsForRoom(room.getId(), checkIn, checkOut);

        return conflicts.stream()
                .noneMatch(r -> r.getStatus() != ReservationStatus.CANCELLED &&
                        r.getStatus() != ReservationStatus.CHECKED_OUT);
    }

    private Set<Room> selectBestRooms(List<Room> available, int needed, Reservation reservation) {
        // Smart assignment logic:
        // 1. Prefer rooms on same floor
        // 2. Prefer rooms of matching type
        // 3. Minimize cleaning/housekeeping distance

        Map<String, List<Room>> byFloor = available.stream()
                .filter(r -> r.getFloorNumber() != null)
                .collect(Collectors.groupingBy(Room::getFloorNumber));

        // Try to get all rooms from same floor
        for (List<Room> floorRooms : byFloor.values()) {
            if (floorRooms.size() >= needed) {
                return new HashSet<>(floorRooms.subList(0, needed));
            }
        }

        // Otherwise, prioritize by room type proximity
        Map<String, List<Room>> byType = available.stream()
                .collect(Collectors.groupingBy(Room::getType));

        // Try to get same type rooms
        for (List<Room> typeRooms : byType.values()) {
            if (typeRooms.size() >= needed) {
                return new HashSet<>(typeRooms.subList(0, needed));
            }
        }

        // Last resort: take any available rooms
        return available.stream()
                .limit(needed)
                .collect(Collectors.toSet());
    }

    @Transactional
    public boolean reassignRoom(Reservation reservation, Room oldRoom, Room newRoom) {
        log.info("Reassigning room for reservation {} from {} to {}",
                reservation.getReservationId(), oldRoom.getRoomNumber(), newRoom.getRoomNumber());

        if (!isRoomAvailable(newRoom, reservation.getCheckInDate(), reservation.getCheckOutDate())) {
            log.warn("New room {} not available for reservation {}",
                    newRoom.getRoomNumber(), reservation.getReservationId());
            return false;
        }

        reservation.removeRoom(oldRoom);
        reservation.addRoom(newRoom);

        log.info("Successfully reassigned room for reservation: {}",
                reservation.getReservationId());
        return true;
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\config\AutomationConfig.java ==== 
package com.example.stayops.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "stayops.automation")
@Data
public class AutomationConfig {
    private int holdTtlMinutes = 15;
    private int noShowGracePeriodHours = 24;
    private int stalePendingHours = 72;
    private int paymentTimeoutMinutes = 30;
    private boolean autoAssignRooms = true;
    private boolean autoCreateHousekeeping = true;
    private boolean autoMarkNoShows = true;
    private boolean autoConfirmOnPayment = true;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\config\CloudinaryConfig.java ==== 
package com.example.stayops.config;

import com.cloudinary.Cloudinary;
import com.cloudinary.utils.ObjectUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CloudinaryConfig {

    @Bean
    public Cloudinary cloudinary() {
        return new Cloudinary(ObjectUtils.asMap(
                "cloud_name", "di4v3fcqi",
                "api_key", "919748897531526",
                "api_secret", "BoPIMyYd48FK4QooxmoEU7JEckU",
                "secure", true
        ));
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\config\SchedulingConfig.java ==== 
package com.example.stayops.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@Configuration
@EnableScheduling
@EnableAsync
public class SchedulingConfig {
    // Enables @Scheduled and @Async annotations for background jobs
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\config\SecurityConfig.java ==== 
package com.example.stayops.config;

import com.example.stayops.security.JwtRequestFilter;
import com.example.stayops.service.impl.GuestUserDetailsService;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final GuestUserDetailsService guestUserDetailsService;
    private final JwtRequestFilter jwtRequestFilter;

    @Bean
    @Primary
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean("adminUserDetailsService")
    public UserDetailsService adminUserDetailsService(PasswordEncoder passwordEncoder) {
        return new InMemoryUserDetailsManager(
                User.builder()
                        .username("admin")
                        .password(passwordEncoder.encode("admin"))
                        .roles("ADMIN")
                        .build()
        );
    }

    @Bean("guestAuthenticationProvider")
    @Primary
    public DaoAuthenticationProvider guestAuthenticationProvider(PasswordEncoder passwordEncoder) {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(guestUserDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder);
        return authProvider;
    }

    @Bean("adminAuthenticationProvider")
    public DaoAuthenticationProvider adminAuthenticationProvider(PasswordEncoder passwordEncoder,
                                                                 @Qualifier("adminUserDetailsService") UserDetailsService adminUserDetailsService) {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(adminUserDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder);
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(DaoAuthenticationProvider guestAuthenticationProvider,
                                                       DaoAuthenticationProvider adminAuthenticationProvider) {
        return new ProviderManager(List.of(guestAuthenticationProvider, adminAuthenticationProvider));
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                // CORS must be configured FIRST
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(AbstractHttpConfigurer::disable)
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        // Allow ALL OPTIONS requests (preflight) without authentication
                        .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()

                        // Public endpoints
                        .requestMatchers("/api/v1/auth/**").permitAll()
                        .requestMatchers("/api/v1/guests/create", "/api/v1/guests/register", "/api/v1/guests/getAll").permitAll()
                        .requestMatchers("/api/rooms/**", "/api/rooms").permitAll()
                        .requestMatchers("/api/receptionists/register").permitAll()
                        .requestMatchers("/api/hotels/**").permitAll()
                        .requestMatchers("/api/reservation-details/**").permitAll()
                        .requestMatchers("/api/reservations/**").permitAll()
                        .requestMatchers("/api/amenities/**").permitAll()
                        .requestMatchers("/api/departments/**").permitAll()
                        .requestMatchers("/api/receptionists/**").permitAll()
                        .requestMatchers("/api/staff/**").permitAll()
                        .requestMatchers("/api/v1/guests/**").permitAll()
                        .requestMatchers("/api/debug/**").permitAll()
                        .requestMatchers("/api/room-status-history/**").permitAll()
                        .requestMatchers("/api/v1/reservation-history/**").permitAll()

                        // Admin endpoints
                        .requestMatchers("/api/admin/**").hasRole("ADMIN")

                        // All other endpoints require authentication
                        .anyRequest().permitAll()
                );

        // Add JWT filter AFTER OPTIONS requests are permitted
        http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);

        // HTTP Basic for admin endpoints
        http.httpBasic(httpBasic -> httpBasic.realmName("Admin"));

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOriginPatterns(List.of("*"));
        config.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"));
        config.setAllowedHeaders(List.of("*"));
        config.setExposedHeaders(List.of("*"));
        config.setAllowCredentials(false);
        config.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\config\WebConfig.java ==== 
package com.example.stayops.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig {

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                        .allowedOriginPatterns("*")
                        .allowedMethods("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD")
                        .allowedHeaders("*")
                        .exposedHeaders("*")
                        .allowCredentials(false)
                        .maxAge(3600);
            }
        };
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\AmenityController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.entity.Amenity;
import com.example.stayops.service.AmenityService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/amenities")
@CrossOrigin(origins = {"*"})
public class AmenityController {

    private final AmenityService amenityService;

    public AmenityController(AmenityService amenityService) {
        this.amenityService = amenityService;
    }

    @GetMapping("/getAll")
    public List<Amenity> getAllAmenities() {
        return amenityService.getAllAmenities();
    }

    @GetMapping("/hotel/{hotelId}")
    public ResponseEntity<List<Amenity>> getAmenitiesByHotel(@PathVariable Long hotelId) {
        return ResponseEntity.ok(amenityService.getAmenitiesByHotelId(hotelId));
    }

    @PostMapping("/create")
    public Amenity addAmenity(@RequestBody Amenity amenity) {
        return amenityService.addAmenity(amenity);
    }

    @DeleteMapping("/delete/{id}")
    public void deleteAmenity(@PathVariable Long id) {
        amenityService.deleteAmenity(id);
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\AuthController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.dto.LoginDTO;
import com.example.stayops.dto.LoginResponseDTO;
import com.example.stayops.service.AuthService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
public class AuthController {

    private final AuthService authService;

    @PostMapping("/login")
    public ResponseEntity<LoginResponseDTO> login(@Valid @RequestBody LoginDTO loginDTO) {
        LoginResponseDTO response = authService.authenticateGuest(loginDTO);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/validate-token")
    public ResponseEntity<Boolean> validateToken(@RequestParam String token) {
        boolean isValid = authService.validateToken(token);
        return ResponseEntity.ok(isValid);
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\AutomationController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.automation.*;
import com.example.stayops.config.AutomationConfig;
import com.example.stayops.entity.FraudAlert;
import com.example.stayops.entity.HousekeepingTask;
import com.example.stayops.entity.PricingRule;
import com.example.stayops.repository.FraudAlertRepository;
import com.example.stayops.repository.HousekeepingTaskRepository;
import com.example.stayops.repository.PricingRuleRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/automation")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
public class AutomationController {

    private final AutomationConfig automationConfig;
    private final DynamicPricingService pricingService;
    private final FraudDetectionService fraudService;
    private final ChannelManagerService channelService;
    private final HousekeepingTaskRepository housekeepingRepo;
    private final PricingRuleRepository pricingRuleRepo;
    private final FraudAlertRepository fraudAlertRepo;

    // ========== CONFIGURATION & STATUS ==========

    @GetMapping("/config")
    public ResponseEntity<Map<String, Object>> getAutomationConfig() {
        Map<String, Object> config = new HashMap<>();
        config.put("holdTtlMinutes", automationConfig.getHoldTtlMinutes());
        config.put("noShowGracePeriodHours", automationConfig.getNoShowGracePeriodHours());
        config.put("stalePendingHours", automationConfig.getStalePendingHours());
        config.put("paymentTimeoutMinutes", automationConfig.getPaymentTimeoutMinutes());
        config.put("autoAssignRooms", automationConfig.isAutoAssignRooms());
        config.put("autoCreateHousekeeping", automationConfig.isAutoCreateHousekeeping());
        config.put("autoMarkNoShows", automationConfig.isAutoMarkNoShows());
        config.put("autoConfirmOnPayment", automationConfig.isAutoConfirmOnPayment());
        return ResponseEntity.ok(config);
    }

    @PutMapping("/config")
    public ResponseEntity<Map<String, Object>> updateAutomationConfig(
            @RequestBody Map<String, Object> updates) {

        if (updates.containsKey("autoAssignRooms")) {
            automationConfig.setAutoAssignRooms((Boolean) updates.get("autoAssignRooms"));
        }
        if (updates.containsKey("autoCreateHousekeeping")) {
            automationConfig.setAutoCreateHousekeeping((Boolean) updates.get("autoCreateHousekeeping"));
        }
        if (updates.containsKey("autoMarkNoShows")) {
            automationConfig.setAutoMarkNoShows((Boolean) updates.get("autoMarkNoShows"));
        }

        return getAutomationConfig();
    }

    @GetMapping("/status")
    public ResponseEntity<Map<String, Object>> getAutomationStatus() {
        Map<String, Object> status = new HashMap<>();

        // Housekeeping stats
        long pendingTasks = housekeepingRepo.findByStatus("PENDING").size();
        long urgentTasks = housekeepingRepo.findUrgentTasks().size();

        // Fraud stats
        long pendingAlerts = fraudAlertRepo.findByStatus("PENDING").size();
        long highRiskAlerts = fraudAlertRepo.findBySeverityAndStatus("HIGH", "PENDING").size();

        status.put("housekeeping", Map.of(
                "pendingTasks", pendingTasks,
                "urgentTasks", urgentTasks
        ));

        status.put("fraud", Map.of(
                "pendingAlerts", pendingAlerts,
                "highRiskAlerts", highRiskAlerts
        ));

        status.put("automationsEnabled", Map.of(
                "roomAssignment", automationConfig.isAutoAssignRooms(),
                "housekeeping", automationConfig.isAutoCreateHousekeeping(),
                "noShows", automationConfig.isAutoMarkNoShows(),
                "paymentConfirmation", automationConfig.isAutoConfirmOnPayment()
        ));

        return ResponseEntity.ok(status);
    }

    // ========== HOUSEKEEPING MANAGEMENT ==========

    @GetMapping("/housekeeping/pending")
    public ResponseEntity<List<HousekeepingTask>> getPendingTasks() {
        return ResponseEntity.ok(housekeepingRepo.findByStatus("PENDING"));
    }

    @GetMapping("/housekeeping/urgent")
    public ResponseEntity<List<HousekeepingTask>> getUrgentTasks() {
        return ResponseEntity.ok(housekeepingRepo.findUrgentTasks());
    }

    @GetMapping("/housekeeping/date/{date}")
    public ResponseEntity<List<HousekeepingTask>> getTasksByDate(
            @PathVariable @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {
        return ResponseEntity.ok(housekeepingRepo.findByScheduledDate(date));
    }

    @PatchMapping("/housekeeping/{id}/complete")
    public ResponseEntity<HousekeepingTask> completeTask(
            @PathVariable Long id,
            @RequestParam String completedBy) {

        HousekeepingTask task = housekeepingRepo.findById(id)
                .orElseThrow(() -> new RuntimeException("Task not found"));

        task.setStatus("COMPLETED");
        task.setCompletedBy(completedBy);
        task.setCompletedAt(java.time.Instant.now());

        return ResponseEntity.ok(housekeepingRepo.save(task));
    }

    // ========== DYNAMIC PRICING ==========

    @GetMapping("/pricing/rules")
    public ResponseEntity<List<PricingRule>> getAllPricingRules() {
        return ResponseEntity.ok(pricingRuleRepo.findAll());
    }

    @GetMapping("/pricing/rules/active")
    public ResponseEntity<List<PricingRule>> getActivePricingRules() {
        return ResponseEntity.ok(pricingRuleRepo.findByIsActiveTrueOrderByPriorityAsc());
    }

    @PostMapping("/pricing/rules")
    public ResponseEntity<PricingRule> createPricingRule(@RequestBody PricingRule rule) {
        return ResponseEntity.ok(pricingRuleRepo.save(rule));
    }

    @PutMapping("/pricing/rules/{id}")
    public ResponseEntity<PricingRule> updatePricingRule(
            @PathVariable Long id,
            @RequestBody PricingRule rule) {

        PricingRule existing = pricingRuleRepo.findById(id)
                .orElseThrow(() -> new RuntimeException("Rule not found"));

        existing.setRuleName(rule.getRuleName());
        existing.setRuleType(rule.getRuleType());
        existing.setIsActive(rule.getIsActive());
        existing.setPriority(rule.getPriority());
        existing.setMinDaysToArrival(rule.getMinDaysToArrival());
        existing.setMaxDaysToArrival(rule.getMaxDaysToArrival());
        existing.setMinOccupancyPercent(rule.getMinOccupancyPercent());
        existing.setMaxOccupancyPercent(rule.getMaxOccupancyPercent());
        existing.setPriceMultiplier(rule.getPriceMultiplier());
        existing.setPriceAddition(rule.getPriceAddition());
        existing.setPriceReduction(rule.getPriceReduction());
        existing.setMinPrice(rule.getMinPrice());
        existing.setMaxPrice(rule.getMaxPrice());
        existing.setDescription(rule.getDescription());

        return ResponseEntity.ok(pricingRuleRepo.save(existing));
    }

    @DeleteMapping("/pricing/rules/{id}")
    public ResponseEntity<Void> deletePricingRule(@PathVariable Long id) {
        pricingRuleRepo.deleteById(id);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/pricing/update-all")
    public ResponseEntity<Map<String, String>> triggerPriceUpdate() {
        pricingService.updateRoomPrices();
        return ResponseEntity.ok(Map.of("status", "Price update triggered"));
    }

    // ========== FRAUD DETECTION ==========

    @GetMapping("/fraud/alerts/pending")
    public ResponseEntity<List<FraudAlert>> getPendingFraudAlerts() {
        return ResponseEntity.ok(fraudService.getPendingAlerts());
    }

    @GetMapping("/fraud/alerts/high-risk")
    public ResponseEntity<List<FraudAlert>> getHighRiskAlerts() {
        return ResponseEntity.ok(fraudService.getHighRiskAlerts());
    }

    @GetMapping("/fraud/alerts")
    public ResponseEntity<List<FraudAlert>> getAllFraudAlerts() {
        return ResponseEntity.ok(fraudAlertRepo.findAll());
    }

    @PatchMapping("/fraud/alerts/{id}/review")
    public ResponseEntity<FraudAlert> reviewFraudAlert(
            @PathVariable Long id,
            @RequestParam String status,
            @RequestParam String reviewedBy,
            @RequestParam(required = false) String notes) {

        FraudAlert alert = fraudAlertRepo.findById(id)
                .orElseThrow(() -> new RuntimeException("Alert not found"));

        alert.setStatus(status);
        alert.setReviewedBy(reviewedBy);
        alert.setReviewedAt(java.time.Instant.now());
        alert.setReviewNotes(notes);

        return ResponseEntity.ok(fraudAlertRepo.save(alert));
    }

    // ========== OTA CHANNEL MANAGEMENT ==========

    @PostMapping("/ota/sync-availability")
    public ResponseEntity<Map<String, String>> syncAvailabilityToOTA(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {

        channelService.syncAvailabilityToOTA(startDate, endDate);
        return ResponseEntity.ok(Map.of(
                "status", "success",
                "message", "Availability synced for " + startDate + " to " + endDate
        ));
    }

    @PostMapping("/ota/sync-rates")
    public ResponseEntity<Map<String, String>> syncRatesToOTA(
            @RequestBody Map<String, Double> roomTypeRates) {

        channelService.syncRatesToOTA(roomTypeRates);
        return ResponseEntity.ok(Map.of(
                "status", "success",
                "message", "Rates synced for " + roomTypeRates.size() + " room types"
        ));
    }

    @PostMapping("/ota/incoming-booking")
    public ResponseEntity<Map<String, Object>> processOTABooking(@RequestBody String otaPayload) {
        var reservation = channelService.processOTABooking(otaPayload);
        return ResponseEntity.ok(Map.of(
                "status", "success",
                "reservationId", reservation.getReservationId()
        ));
    }

    // ========== MANUAL TRIGGERS ==========

    @PostMapping("/jobs/process-no-shows")
    public ResponseEntity<Map<String, String>> triggerNoShowProcessing() {
        // This would call the scheduled job manually
        return ResponseEntity.ok(Map.of(
                "status", "triggered",
                "message", "No-show processing job started"
        ));
    }

    @PostMapping("/jobs/nightly-audit")
    public ResponseEntity<Map<String, String>> triggerNightlyAudit() {
        // This would call the nightly audit job manually
        return ResponseEntity.ok(Map.of(
                "status", "triggered",
                "message", "Nightly audit job started"
        ));
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\DepartmentController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.entity.Department;
import com.example.stayops.service.DepartmentService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/departments")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
public class DepartmentController {

    private final DepartmentService departmentService;

    @PostMapping("/create")
    public ResponseEntity<Department> createDepartment(@RequestBody Department department) {
        return ResponseEntity.ok(departmentService.createDepartment(department));
    }

    @PutMapping("/update/{id}")
    public ResponseEntity<Department> updateDepartment(
            @PathVariable Long id,
            @RequestBody Department department) {
        return ResponseEntity.ok(departmentService.updateDepartment(id, department));
    }

    @DeleteMapping("/delete/{id}")
    public ResponseEntity<Void> deleteDepartment(@PathVariable Long id) {
        departmentService.deleteDepartment(id);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/get/{id}")
    public ResponseEntity<Department> getDepartmentById(@PathVariable Long id) {
        return ResponseEntity.ok(departmentService.getDepartmentById(id));
    }

    @GetMapping("/getAll")
    public ResponseEntity<List<Department>> getAllDepartments() {
        return ResponseEntity.ok(departmentService.getAllDepartments());
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\GuestController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.dto.GuestCreateDTO;
import com.example.stayops.dto.GuestRegistrationDTO;
import com.example.stayops.dto.GuestResponseDTO;
import com.example.stayops.entity.GuestAccount;
import com.example.stayops.service.GuestService;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.Base64;
import java.util.List;

@RestController
@RequestMapping("/api/v1/guests")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
public class GuestController {

    private final GuestService guestService;
    private final ObjectMapper objectMapper = new ObjectMapper();

    @PostMapping(value = "/create", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<GuestResponseDTO> createGuest(
            @RequestPart("guest") String guestJson,
            @RequestPart(value = "identityImage", required = false) MultipartFile identityImage) throws IOException {

        GuestCreateDTO guestDto = objectMapper.readValue(guestJson, GuestCreateDTO.class);

        GuestResponseDTO response = guestService.createGuest(guestDto, identityImage);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/register")
    public ResponseEntity<GuestAccount> registerGuest(@Valid @RequestBody GuestRegistrationDTO dto) {
        return new ResponseEntity<>(guestService.registerGuestFromMobile(dto), HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    public ResponseEntity<GuestResponseDTO> getGuest(@PathVariable("id") String guestId) {
        return ResponseEntity.ok(guestService.getGuestById(guestId));
    }

    @GetMapping("/getAll")
    public ResponseEntity<List<GuestResponseDTO>> getAllGuests() {
        return ResponseEntity.ok(guestService.getAllGuests());
    }

    /**
     * New endpoint:
     * Returns the QR image bytes directly with a correct Content-Type so frontend can fetch:
     * <img src="http://.../api/v1/guests/{id}/qr" />
     */
    @GetMapping("/{id}/qr")
    public ResponseEntity<byte[]> getGuestQrImage(@PathVariable("id") String guestId) {
        String dataUrl = guestService.getGuestQrCodeDataUrl(guestId);
        if (dataUrl == null) {
            return ResponseEntity.notFound().build();
        }

        // dataUrl format: data:<mime-type>;base64,<payload>
        try {
            if (!dataUrl.contains(",")) {
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }
            String[] parts = dataUrl.split(",", 2);
            String meta = parts[0]; // e.g. data:image/png;base64
            String base64 = parts[1];

            String mime = "image/png";
            if (meta.contains(":") && meta.contains(";")) {
                mime = meta.substring(meta.indexOf(":") + 1, meta.indexOf(";"));
            }

            byte[] imageBytes = Base64.getDecoder().decode(base64);
            MediaType mediaType = MediaType.parseMediaType(mime);
            return ResponseEntity.ok().contentType(mediaType).body(imageBytes);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\HealthController.java ==== 
package com.example.stayops.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.sql.DataSource;
import java.sql.Connection;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/health")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
public class HealthController {

    private final DataSource dataSource;

    @GetMapping
    public ResponseEntity<Map<String, Object>> healthCheck() {
        Map<String, Object> health = new HashMap<>();

        // Database check
        try (Connection conn = dataSource.getConnection()) {
            health.put("database", "UP");
            health.put("dbUrl", conn.getMetaData().getURL());
        } catch (Exception e) {
            health.put("database", "DOWN");
            health.put("dbError", e.getMessage());
        }

        // Application status
        health.put("application", "UP");
        health.put("timestamp", java.time.Instant.now());

        return ResponseEntity.ok(health);
    }

    @GetMapping("/automations")
    public ResponseEntity<Map<String, String>> automationHealth() {
        Map<String, String> status = new HashMap<>();
        status.put("paymentWebhook", "OPERATIONAL");
        status.put("roomAssignment", "OPERATIONAL");
        status.put("housekeeping", "OPERATIONAL");
        status.put("noShowDetection", "OPERATIONAL");
        status.put("fraudDetection", "OPERATIONAL");
        status.put("dynamicPricing", "OPERATIONAL");
        status.put("otaSync", "OPERATIONAL");

        return ResponseEntity.ok(status);
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\HotelController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.entity.Hotel;
import com.example.stayops.service.HotelService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/hotels")
@RequiredArgsConstructor
@CrossOrigin(origins = "*")
public class HotelController {

    private final HotelService hotelService;

    @PostMapping("/create")
    public ResponseEntity<Hotel> createHotel(@RequestBody Hotel hotel){
        return ResponseEntity.ok(hotelService.createHotel(hotel));
    }

    @PutMapping("/update/{hotelId}")
    public ResponseEntity<Hotel> updateHotel(@PathVariable Long hotelId, @RequestBody Hotel hotel){
        return ResponseEntity.ok(hotelService.updateHotel(hotelId,hotel));
    }

    @DeleteMapping("/delete/{hotelId}")
    public ResponseEntity<Void> deleteHotel(@PathVariable Long hotelId){
        hotelService.deleteHotel(hotelId);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/get/{hotelId}")
    public ResponseEntity<Hotel> getHotelById(@PathVariable Long hotelId){
        return  ResponseEntity.ok(hotelService.getHotelById(hotelId));
    }

    @GetMapping("/getAll")
    public ResponseEntity<List<Hotel>> getAllHotels(){
        return ResponseEntity.ok(hotelService.getAllHotels());
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\LoyaltyPointsController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.dto.LoyaltyPointsDTO;
import com.example.stayops.service.LoyaltyPointsService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/loyalty-points")
@RequiredArgsConstructor
public class LoyaltyPointsController {

    private final LoyaltyPointsService loyaltyPointsService;

    @PostMapping
    public ResponseEntity<LoyaltyPointsDTO> createOrUpdate(@RequestBody LoyaltyPointsDTO dto) {
        return ResponseEntity.ok(loyaltyPointsService.createOrUpdate(dto));
    }

    @GetMapping("/{guestId}")
    public ResponseEntity<LoyaltyPointsDTO> getByGuestId(@PathVariable String guestId) {
        return ResponseEntity.ok(loyaltyPointsService.getByGuestId(guestId));
    }

    @GetMapping
    public ResponseEntity<List<LoyaltyPointsDTO>> getAll() {
        return ResponseEntity.ok(loyaltyPointsService.getAll());
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<String> delete(@PathVariable Long id) {
        loyaltyPointsService.delete(id);
        return ResponseEntity.ok("Deleted loyalty points with id " + id);
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\MetricsController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.automation.AutomationMetricsService;
import com.example.stayops.dto.AutomationMetricsDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;

@RestController
@RequestMapping("/api/metrics")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
public class MetricsController {

    private final AutomationMetricsService metricsService;

    @GetMapping("/automation/daily")
    public ResponseEntity<AutomationMetricsDTO> getDailyMetrics(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {
        return ResponseEntity.ok(metricsService.getDailyMetrics(date));
    }

    @GetMapping("/automation/today")
    public ResponseEntity<AutomationMetricsDTO> getTodayMetrics() {
        return ResponseEntity.ok(metricsService.getDailyMetrics(LocalDate.now()));
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\PaymentController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.dto.PaymentTransactionDTO;
import com.example.stayops.service.PaymentService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.List;

@RestController
@RequestMapping("/api/payments")
@RequiredArgsConstructor
public class PaymentController {

    private final PaymentService paymentService;

    @PostMapping("/initiate")
    public ResponseEntity<PaymentTransactionDTO> initiatePayment(@RequestBody PaymentTransactionDTO request) {
        return ResponseEntity.ok(paymentService.initiatePayment(request));
    }

    @PostMapping("/webhook")
    public ResponseEntity<PaymentTransactionDTO> processWebhook(
            @RequestBody String payload,
            @RequestHeader("X-Signature") String signature) {
        return ResponseEntity.ok(paymentService.processWebhook(payload, signature));
    }

    @GetMapping("/idempotency/{key}")
    public ResponseEntity<PaymentTransactionDTO> getByIdempotencyKey(@PathVariable String key) {
        return ResponseEntity.ok(paymentService.getByIdempotencyKey(key));
    }

    @GetMapping("/reservation/{reservationId}")
    public ResponseEntity<List<PaymentTransactionDTO>> getReservationPayments(@PathVariable Long reservationId) {
        return ResponseEntity.ok(paymentService.getPaymentsByReservation(reservationId));
    }

    @PostMapping("/{transactionId}/refund")
    public ResponseEntity<PaymentTransactionDTO> initiateRefund(
            @PathVariable Long transactionId,
            @RequestParam BigDecimal amount,
            @RequestParam(required = false) String reason) {
        return ResponseEntity.ok(paymentService.initiateRefund(transactionId, amount, reason));
    }

    @PostMapping("/{transactionId}/capture")
    public ResponseEntity<PaymentTransactionDTO> capturePayment(@PathVariable Long transactionId) {
        return ResponseEntity.ok(paymentService.capturePayment(transactionId));
    }

    @PostMapping("/process-timeouts")
    public ResponseEntity<Integer> processTimeouts(@RequestParam(defaultValue = "30") int timeoutMinutes) {
        int processed = paymentService.processTimeoutPayments(timeoutMinutes);
        return ResponseEntity.ok(processed);
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\ReceptionistController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.dto.ReceptionistRegisterDTO;
import com.example.stayops.dto.ReceptionistResponseDTO;
import com.example.stayops.entity.Receptionist;
import com.example.stayops.service.ReceptionistService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/receptionists")
@CrossOrigin(origins = {"*"})
@RequiredArgsConstructor
public class ReceptionistController {

    private final ReceptionistService receptionistService;

    @PostMapping("/register")
    public ResponseEntity<Receptionist> registerReceptionist(@RequestBody ReceptionistRegisterDTO dto) {
        return ResponseEntity.ok(receptionistService.registerReceptionist(dto));
    }

    @GetMapping("/getAll")
    public ResponseEntity<List<ReceptionistResponseDTO>> getAllReceptionists() {
        return ResponseEntity.ok(receptionistService.getAllReceptionists());
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\RegistrationPageController.java ==== 
package com.example.stayops.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class RegistrationPageController {

    @GetMapping("/registration")
    public String showRegistrationPage(@RequestParam("token") String token, Model model) {
        model.addAttribute("token", token);
        return "registration";
    }

    @GetMapping("/registration-success")
    public String registrationSuccess() {
        return "registration-success";
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\ReservationController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.dto.*;
import com.example.stayops.service.ReservationService;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/reservations")
@RequiredArgsConstructor
// Removed @CrossOrigin here as it's handled globally in SecurityConfig
public class ReservationController {

    private final ReservationService reservationService;

    // ========== RESERVATION CRUD ==========
    @PostMapping("/create")
    public ResponseEntity<ReservationResponseDTO> createReservation(@RequestBody ReservationRequestDTO dto) {
        return ResponseEntity.ok(reservationService.createReservation(dto));
    }

    @PutMapping("/update/{reservationId}")
    public ResponseEntity<ReservationResponseDTO> updateReservation(
            @PathVariable Long reservationId,
            @RequestBody ReservationRequestDTO dto) {
        return ResponseEntity.ok(reservationService.updateReservation(reservationId, dto));
    }

    @DeleteMapping("/delete/{reservationId}")
    public ResponseEntity<Void> deleteReservation(@PathVariable Long reservationId) {
        reservationService.deleteReservation(reservationId);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/get/{reservationId}")
    public ResponseEntity<ReservationResponseDTO> getReservationById(@PathVariable Long reservationId) {
        return ResponseEntity.ok(reservationService.getReservationById(reservationId));
    }

    @GetMapping("/getAll")
    public ResponseEntity<List<ReservationResponseDTO>> getAllReservations() {
        return ResponseEntity.ok(reservationService.getAllReservations());
    }

    // ========== ROOM STATUS & AVAILABILITY ==========

    @GetMapping("/room-status")
    public ResponseEntity<List<RoomStatusDTO>> getRoomStatusForDate(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {
        return ResponseEntity.ok(reservationService.getRoomStatusForDate(date));
    }

    @GetMapping("/room-status/range")
    public ResponseEntity<Map<Long, List<RoomStatusDTO>>> getRoomStatusForDateRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(reservationService.getRoomStatusForDateRange(startDate, endDate));
    }

    @GetMapping("/reservations")
    public List<Map<String, Object>> getAllRoomReservations() {
        return reservationService.getAllRoomReservationStatuses();
    }

    // ========== CALENDAR & DATE-BASED QUERIES ==========

    @GetMapping("/calendar")
    public ResponseEntity<List<ReservationSummaryDTO>> getReservationCalendar(
            @RequestParam int year,
            @RequestParam int month) {
        return ResponseEntity.ok(reservationService.getMonthlySummary(year, month));
    }

    @GetMapping("/day")
    public ResponseEntity<List<ReservationDayDetailDTO>> getReservationsByDate(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {
        return ResponseEntity.ok(reservationService.getReservationsForDate(date));
    }

    @GetMapping("/date-range")
    public ResponseEntity<List<ReservationResponseDTO>> getReservationsInDateRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(reservationService.getReservationsInDateRange(startDate, endDate));
    }

    // ========== ARRIVALS & DEPARTURES ==========

    @GetMapping("/arrivals")
    public ResponseEntity<List<ReservationResponseDTO>> getArrivals(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {
        return ResponseEntity.ok(reservationService.getArrivalsForDate(date));
    }

    @GetMapping("/departures")
    public ResponseEntity<List<ReservationResponseDTO>> getDepartures(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {
        return ResponseEntity.ok(reservationService.getDeparturesForDate(date));
    }

    @GetMapping("/daily-summary")
    public ResponseEntity<DailyOperationsSummaryDTO> getDailySummary(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {
        return ResponseEntity.ok(reservationService.getDailyOperationsSummary(date));
    }

    // ========== STATUS MANAGEMENT ==========

    @PatchMapping("/{reservationId}/status")
    public ResponseEntity<ReservationResponseDTO> updateReservationStatus(
            @PathVariable Long reservationId,
            @RequestParam String status) {
        return ResponseEntity.ok(reservationService.updateReservationStatus(reservationId, status));
    }

    @PostMapping("/{reservationId}/check-in")
    public ResponseEntity<ReservationResponseDTO> checkIn(@PathVariable Long reservationId) {
        return ResponseEntity.ok(reservationService.checkInReservation(reservationId));
    }

    @PostMapping("/{reservationId}/check-out")
    public ResponseEntity<ReservationResponseDTO> checkOut(@PathVariable Long reservationId) {
        return ResponseEntity.ok(reservationService.checkOutReservation(reservationId));
    }

    @PostMapping("/{reservationId}/cancel")
    public ResponseEntity<ReservationResponseDTO> cancel(@PathVariable Long reservationId) {
        return ResponseEntity.ok(reservationService.cancelReservation(reservationId));
    }

    // ========== GUEST & SEARCH ==========

    @GetMapping("/guest/{guestId}")
    public ResponseEntity<List<ReservationResponseDTO>> getGuestReservations(@PathVariable String guestId) {
        return ResponseEntity.ok(reservationService.getReservationsByGuestId(guestId));
    }

    @GetMapping("/search")
    public ResponseEntity<List<ReservationResponseDTO>> searchReservations(
            @RequestParam(required = false) String guestId,
            @RequestParam(required = false) String status,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate checkInDate,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate checkOutDate) {
        return ResponseEntity.ok(reservationService.searchReservations(guestId, status, checkInDate, checkOutDate));
    }

    // ========== OCCUPANCY STATS ==========

    @GetMapping("/occupancy/current")
    public ResponseEntity<OccupancyStatsDTO> getCurrentOccupancy() {
        return ResponseEntity.ok(reservationService.getCurrentOccupancyStats());
    }

    @GetMapping("/occupancy/date")
    public ResponseEntity<OccupancyStatsDTO> getOccupancyForDate(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {
        return ResponseEntity.ok(reservationService.getOccupancyStatsForDate(date));
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\ReservationDetailsController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.dto.ReservationDetailsDTO;
import com.example.stayops.service.ReservationDetailsService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/reservation-details")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
public class ReservationDetailsController {

    private final ReservationDetailsService reservationDetailsService;

    @PostMapping("/create/{reservationId}")
    public ResponseEntity<ReservationDetailsDTO> create(@PathVariable Long reservationId,
                                                        @RequestBody ReservationDetailsDTO dto) {
        return ResponseEntity.ok(reservationDetailsService.saveReservationDetails(reservationId, dto));
    }

    @GetMapping("/get/{reservationId}")
    public ResponseEntity<ReservationDetailsDTO> get(@PathVariable Long reservationId) {
        return ResponseEntity.ok(reservationDetailsService.getReservationDetails(reservationId));
    }

    @PutMapping("/update/{reservationId}")
    public ResponseEntity<ReservationDetailsDTO> update(@PathVariable Long reservationId,
                                                        @RequestBody ReservationDetailsDTO dto) {
        return ResponseEntity.ok(reservationDetailsService.updateReservationDetails(reservationId, dto));
    }

    @DeleteMapping("/delete/{reservationId}")
    public ResponseEntity<Void> delete(@PathVariable Long reservationId) {
        reservationDetailsService.deleteReservationDetails(reservationId);
        return ResponseEntity.noContent().build();
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\ReservationHistoryController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.dto.ReservationHistoryDTO;
import com.example.stayops.service.ReservationHistoryService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/reservation-history")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
public class ReservationHistoryController {

    private final ReservationHistoryService reservationHistoryService;

    @PostMapping
    public ResponseEntity<ReservationHistoryDTO> recordHistory(@RequestBody ReservationHistoryDTO dto) {
        return ResponseEntity.ok(reservationHistoryService.recordHistory(dto));
    }

    @GetMapping("/{reservationId}")
    public ResponseEntity<List<ReservationHistoryDTO>> getHistory(@PathVariable Long reservationId) {
        return ResponseEntity.ok(reservationHistoryService.getHistoryByReservation(reservationId));
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\ReservationHoldController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.dto.ReservationHoldRequestDTO;
import com.example.stayops.dto.ReservationHoldResponseDTO;
import com.example.stayops.service.ReservationHoldService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/holds")
@RequiredArgsConstructor
public class ReservationHoldController {

    private final ReservationHoldService holdService;

    @PostMapping("/create")
    public ResponseEntity<ReservationHoldResponseDTO> createHold(@RequestBody ReservationHoldRequestDTO request) {
        return ResponseEntity.ok(holdService.createHold(request));
    }

    @GetMapping("/{holdToken}")
    public ResponseEntity<ReservationHoldResponseDTO> getHold(@PathVariable String holdToken) {
        return ResponseEntity.ok(holdService.getHoldByToken(holdToken));
    }

    @PostMapping("/{holdToken}/convert")
    public ResponseEntity<Long> convertToReservation(@PathVariable String holdToken) {
        Long reservationId = holdService.convertHoldToReservation(holdToken);
        return ResponseEntity.ok(reservationId);
    }

    @DeleteMapping("/{holdToken}/cancel")
    public ResponseEntity<Void> cancelHold(@PathVariable String holdToken) {
        holdService.cancelHold(holdToken);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{holdToken}/extend")
    public ResponseEntity<ReservationHoldResponseDTO> extendHold(
            @PathVariable String holdToken,
            @RequestParam Integer additionalMinutes) {
        return ResponseEntity.ok(holdService.extendHold(holdToken, additionalMinutes));
    }

    @GetMapping("/guest/{guestId}")
    public ResponseEntity<List<ReservationHoldResponseDTO>> getGuestHolds(@PathVariable String guestId) {
        return ResponseEntity.ok(holdService.getActiveHoldsByGuest(guestId));
    }

    @PostMapping("/process-expired")
    public ResponseEntity<Integer> processExpiredHolds() {
        int processed = holdService.processExpiredHolds();
        return ResponseEntity.ok(processed);
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\RoomController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.dto.RoomDTO;
import com.example.stayops.service.RoomService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/rooms")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
public class RoomController {

    private final RoomService roomService;

    @PostMapping("/create")
    public ResponseEntity<RoomDTO> createRoom(@RequestBody RoomDTO roomDTO) {
        return ResponseEntity.ok(roomService.createRoom(roomDTO));
    }

    @PutMapping("/update/{id}")
    public ResponseEntity<RoomDTO> updateRoom(@PathVariable Long id, @RequestBody RoomDTO roomDTO) {
        return ResponseEntity.ok(roomService.updateRoom(id, roomDTO));
    }

    @DeleteMapping("/delete/{id}")
    public ResponseEntity<Void> deleteRoom(@PathVariable Long id) {
        roomService.deleteRoom(id);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/get/{id}")
    public ResponseEntity<RoomDTO> getRoomById(@PathVariable Long id) {
        return ResponseEntity.ok(roomService.getRoomById(id));
    }

    @GetMapping("/getAll")
    public ResponseEntity<List<RoomDTO>> getAllRooms() {
        return ResponseEntity.ok(roomService.getAllRooms());
    }

    @GetMapping("/get/available")
    public ResponseEntity<List<RoomDTO>> getAvailableRooms() {
        return ResponseEntity.ok(roomService.getAvailableRooms());
    }

    @GetMapping("/get/{type}")
    public ResponseEntity<List<RoomDTO>> getRoomsByType(@PathVariable String type) {
        return ResponseEntity.ok(roomService.getRoomsByType(type));
    }

    @GetMapping("/hotel/{hotelId}")
    public ResponseEntity<List<RoomDTO>> getRoomsByHotel(@PathVariable Long hotelId) {
        return ResponseEntity.ok(roomService.getRoomsByHotel(hotelId));
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\RoomStatusHistoryController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.dto.RoomStatusHistoryDTO;
import com.example.stayops.service.RoomStatusHistoryService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/room-status-history")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
public class RoomStatusHistoryController {

    private final RoomStatusHistoryService historyService;

    @PostMapping("/create")
    public RoomStatusHistoryDTO createStatusChange(@RequestBody RoomStatusHistoryDTO dto) {
        return historyService.createStatusChange(dto);
    }

    @GetMapping("/room/{roomId}")
    public List<RoomStatusHistoryDTO> getHistoryByRoom(@PathVariable Long roomId) {
        return historyService.getHistoryByRoom(roomId);
    }

    @GetMapping("/getAll")
    public List<RoomStatusHistoryDTO> getAllHistory() {
        return historyService.getAllHistory();
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\ServiceRequestController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.dto.ServiceRequestDTO;
import com.example.stayops.service.ServiceRequestService;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.Instant;
import java.util.List;

@RestController
@RequestMapping("/api/service-requests")
@RequiredArgsConstructor
public class ServiceRequestController {

    private final ServiceRequestService serviceRequestService;

    // ========== CRUD OPERATIONS ==========

    @PostMapping("/create")
    public ResponseEntity<ServiceRequestDTO> createServiceRequest(@RequestBody ServiceRequestDTO dto) {
        return ResponseEntity.ok(serviceRequestService.createServiceRequest(dto));
    }

    @GetMapping("/{id}")
    public ResponseEntity<ServiceRequestDTO> getServiceRequestById(@PathVariable Long id) {
        return ResponseEntity.ok(serviceRequestService.getServiceRequestById(id));
    }

    @GetMapping("/all")
    public ResponseEntity<List<ServiceRequestDTO>> getAllServiceRequests() {
        return ResponseEntity.ok(serviceRequestService.getAllServiceRequests());
    }

    @PutMapping("/{id}")
    public ResponseEntity<ServiceRequestDTO> updateServiceRequest(
            @PathVariable Long id,
            @RequestBody ServiceRequestDTO dto) {
        return ResponseEntity.ok(serviceRequestService.updateServiceRequest(id, dto));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteServiceRequest(@PathVariable Long id) {
        serviceRequestService.deleteServiceRequest(id);
        return ResponseEntity.noContent().build();
    }

    // ========== FILTERING & SEARCH ==========

    @GetMapping("/status/{status}")
    public ResponseEntity<List<ServiceRequestDTO>> getByStatus(@PathVariable String status) {
        return ResponseEntity.ok(serviceRequestService.getServiceRequestsByStatus(status));
    }

    @GetMapping("/type/{serviceType}")
    public ResponseEntity<List<ServiceRequestDTO>> getByType(@PathVariable String serviceType) {
        return ResponseEntity.ok(serviceRequestService.getServiceRequestsByType(serviceType));
    }

    @GetMapping("/priority/{priority}")
    public ResponseEntity<List<ServiceRequestDTO>> getByPriority(@PathVariable String priority) {
        return ResponseEntity.ok(serviceRequestService.getServiceRequestsByPriority(priority));
    }

    @GetMapping("/reservation/{reservationId}")
    public ResponseEntity<List<ServiceRequestDTO>> getByReservation(@PathVariable Long reservationId) {
        return ResponseEntity.ok(serviceRequestService.getServiceRequestsByReservation(reservationId));
    }

    @GetMapping("/room/{roomId}")
    public ResponseEntity<List<ServiceRequestDTO>> getByRoom(@PathVariable Long roomId) {
        return ResponseEntity.ok(serviceRequestService.getServiceRequestsByRoom(roomId));
    }

    @GetMapping("/staff/{staffId}")
    public ResponseEntity<List<ServiceRequestDTO>> getByAssignedStaff(@PathVariable String staffId) {
        return ResponseEntity.ok(serviceRequestService.getServiceRequestsByAssignedStaff(staffId));
    }

    @GetMapping("/pending")
    public ResponseEntity<List<ServiceRequestDTO>> getPendingRequests() {
        return ResponseEntity.ok(serviceRequestService.getPendingRequests());
    }

    @GetMapping("/urgent")
    public ResponseEntity<List<ServiceRequestDTO>> getUrgentRequests() {
        return ResponseEntity.ok(serviceRequestService.getUrgentRequests());
    }

    @GetMapping("/incomplete")
    public ResponseEntity<List<ServiceRequestDTO>> getIncompleteRequests() {
        return ResponseEntity.ok(serviceRequestService.getIncompleteRequests());
    }

    @GetMapping("/date-range")
    public ResponseEntity<List<ServiceRequestDTO>> getByDateRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant endDate) {
        return ResponseEntity.ok(serviceRequestService.getServiceRequestsByDateRange(startDate, endDate));
    }

    // ========== STATUS UPDATES & ASSIGNMENT ==========

    @PatchMapping("/{id}/assign")
    public ResponseEntity<ServiceRequestDTO> assignToStaff(
            @PathVariable Long id,
            @RequestParam String staffId) {
        return ResponseEntity.ok(serviceRequestService.assignToStaff(id, staffId));
    }

    @PatchMapping("/{id}/status")
    public ResponseEntity<ServiceRequestDTO> updateStatus(
            @PathVariable Long id,
            @RequestParam String status) {
        return ResponseEntity.ok(serviceRequestService.updateStatus(id, status));
    }

    @PostMapping("/{id}/complete")
    public ResponseEntity<ServiceRequestDTO> markAsCompleted(@PathVariable Long id) {
        return ResponseEntity.ok(serviceRequestService.markAsCompleted(id));
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\ServiceTypeController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.dto.ServiceTypeDTO;
import com.example.stayops.service.ServiceTypeService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/service-types")
@RequiredArgsConstructor
@Validated
@CrossOrigin(origins = {"*"}) // allow cross origin - adjust as necessary
public class ServiceTypeController {

    private final ServiceTypeService service;

    @PostMapping("/create")
    public ResponseEntity<ServiceTypeDTO> create(@Valid @RequestBody ServiceTypeDTO dto) {
        ServiceTypeDTO created = service.create(dto);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ServiceTypeDTO> getById(@PathVariable Long id) {
        ServiceTypeDTO dto = service.getById(id);
        return ResponseEntity.ok(dto);
    }

    @GetMapping("/code/{code}")
    public ResponseEntity<ServiceTypeDTO> getByCode(@PathVariable String code) {
        ServiceTypeDTO dto = service.getByCode(code);
        return ResponseEntity.ok(dto);
    }

    @GetMapping("/getAll")
    public ResponseEntity<List<ServiceTypeDTO>> getAll() {
        return ResponseEntity.ok(service.getAll());
    }

    @PutMapping("/update/{id}")
    public ResponseEntity<ServiceTypeDTO> update(@PathVariable Long id,
                                                 @Valid @RequestBody ServiceTypeDTO dto) {
        ServiceTypeDTO updated = service.update(id, dto);
        return ResponseEntity.ok(updated);
    }

    @DeleteMapping("/delete/{id}")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\StaffController.java ==== 
package com.example.stayops.controller;

import com.example.stayops.dto.StaffRequestDTO;
import com.example.stayops.dto.StaffResponseDTO;
import com.example.stayops.service.StaffService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/staff")
@RequiredArgsConstructor
@CrossOrigin(origins = {"*"})
public class StaffController {

    private final StaffService staffService;

    @PostMapping("/create")
    public ResponseEntity<StaffResponseDTO> createStaff(@RequestBody StaffRequestDTO dto) {
        return ResponseEntity.ok(staffService.createStaff(dto));
    }

    @PutMapping("/update/{staffId}")
    public ResponseEntity<StaffResponseDTO> updateStaff(
            @PathVariable String staffId,
            @RequestBody StaffRequestDTO dto) {
        return ResponseEntity.ok(staffService.updateStaff(staffId, dto));
    }

    @DeleteMapping("/delete/{staffId}")
    public ResponseEntity<Void> deleteStaff(@PathVariable String staffId) {
        staffService.deleteStaff(staffId);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/get/{staffId}")
    public ResponseEntity<StaffResponseDTO> getStaffById(@PathVariable String staffId) {
        return ResponseEntity.ok(staffService.getStaffById(staffId));
    }

    @GetMapping("/getAll")
    public ResponseEntity<List<StaffResponseDTO>> getAllStaff() {
        return ResponseEntity.ok(staffService.getAllStaff());
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\controller\TestController.java ==== 
package com.example.stayops.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestController {
    @GetMapping("/test")
    public String test() {
        return "Backend is working!";
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\AutomationMetricsDTO.java ==== 
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AutomationMetricsDTO {

    // Reservation Automation
    private Integer autoConfirmedReservations;
    private Integer autoAssignedRooms;
    private Integer roomAssignmentFailures;

    // Payment Automation
    private Integer successfulWebhooks;
    private Integer failedWebhooks;
    private Integer timeoutPayments;

    // Housekeeping Automation
    private Integer tasksCreated;
    private Integer tasksCompleted;
    private Integer overdueTasks;

    // No-Show & Cleanup
    private Integer markedNoShows;
    private Integer cancelledStaleReservations;

    // Fraud Detection
    private Integer fraudAlertsCreated;
    private Integer highRiskAlerts;

    // OTA Integration
    private Integer otaBookingsProcessed;
    private Integer availabilitySyncs;
    private Integer rateSyncs;

    private LocalDate date;
    private String period; // DAILY, WEEKLY, MONTHLY
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\DailyOperationsSummaryDTO.java ==== 
// DailyOperationsSummaryDTO.java
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DailyOperationsSummaryDTO {
    private LocalDate date;
    private Integer totalRooms;
    private Integer occupiedRooms;
    private Integer availableRooms;
    private Integer expectedArrivals;
    private Integer expectedDepartures;
    private Integer inHouseGuests;
    private Double occupancyRate;
    private Integer pendingReservations;
    private Integer confirmedReservations;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\FolioLineItemDTO.java ==== 
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FolioLineItemDTO {

    private Long id;
    private Long folioId;
    private LocalDate transactionDate;
    private String itemType;
    private String description;
    private BigDecimal amount;
    private Integer quantity;
    private BigDecimal unitPrice;
    private String reference;
    private String postedBy;
    private String department;
    private String notes;
    private Boolean isVoided;
    private String voidedBy;
    private Instant voidedAt;
    private String voidReason;
    private Instant createdAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\GuestCreateDTO.java ==== 
package com.example.stayops.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.validator.constraints.URL;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class GuestCreateDTO {

    @NotBlank private String firstName;
    @NotBlank private String lastName;
    @Email @NotBlank private String email;
    @NotBlank private String phone;
    private String nationality;
    private String identityType;
    private String identityNumber;
    @URL private String imageUrl;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\GuestFolioDTO.java ==== 
package com.example.stayops.dto;

import com.example.stayops.enums.FolioStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class GuestFolioDTO {

    private Long id;
    private String folioNumber;
    private Long reservationId;
    private FolioStatus status;
    private List<FolioLineItemDTO> lineItems;
    private BigDecimal totalCharges;
    private BigDecimal totalPayments;
    private BigDecimal balance;
    private String currency;
    private BigDecimal depositAmount;
    private BigDecimal incidentalDeposit;
    private Instant settledAt;
    private Instant closedAt;
    private String notes;
    private Instant createdAt;
    private Instant updatedAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\GuestRegistrationDTO.java ==== 
package com.example.stayops.dto;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class GuestRegistrationDTO {
    private String email;
    private String password;
    private String confirmPassword;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\GuestResponseDTO.java ==== 
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class GuestResponseDTO {
    private String guestId;
    private String fullName;
    private String email;
    private String phone;
    private String nationality;
    private String identityType;
    private String identityNumber;
    private String qrCodeBase64;
    private String imageUrl;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\LoginDTO.java ==== 
package com.example.stayops.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LoginDTO {
    @Email
    @NotBlank
    private String email;

    @NotBlank
    private String password;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\LoginResponseDTO.java ==== 
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LoginResponseDTO {
    private String token;
    private String tokenType;
    private Long expiresIn;
    private GuestResponseDTO guest;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\LoyaltyPointsDTO.java ==== 
package com.example.stayops.dto;

import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LoyaltyPointsDTO {
    private Long id;
    private String guestId;
    private Integer points;
    private String membershipLevel;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\OccupancyStatsDTO.java ==== 
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OccupancyStatsDTO {
    private LocalDate date;
    private Integer totalRooms;
    private Integer occupiedRooms;
    private Integer availableRooms;
    private Integer reservedRooms;
    private Double occupancyRate;
    private Integer totalGuests;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\PaymentTransactionDTO.java ==== 
package com.example.stayops.dto;

import com.example.stayops.enums.PaymentMethod;
import com.example.stayops.enums.PaymentStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PaymentTransactionDTO {

    private Long id;
    private Long reservationId;
    private String idempotencyKey;
    private String providerTransactionId;
    private String paymentIntentId;
    private PaymentStatus status;
    private PaymentMethod paymentMethod;
    private BigDecimal amount;
    private String currency;
    private String cardLast4;
    private String cardBrand;
    private String cardToken;
    private String failureReason;
    private Instant processedAt;
    private String processedBy;
    private String notes;
    private Boolean isRefund;
    private Long refundOfTransactionId;
    private BigDecimal refundedAmount;
    private Instant createdAt;
    private Instant updatedAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\RatePlanDTO.java ==== 
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RatePlanDTO {

    private Long id;
    private Long hotelId;
    private String ratePlanCode;
    private String name;
    private String description;
    private BigDecimal baseRate;
    private String roomType;
    private LocalDate validFrom;
    private LocalDate validUntil;
    private Integer minAdvanceBookingDays;
    private Integer maxAdvanceBookingDays;
    private Integer minLengthOfStay;
    private Integer maxLengthOfStay;
    private BigDecimal discountPercentage;
    private String promoCode;
    private Boolean isRefundable;
    private Boolean requiresPrepayment;
    private String cancellationPolicyCode;
    private Boolean isActive;
    private Integer priority;
    private String channelCode;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\ReceptionistRegisterDTO.java ==== 
package com.example.stayops.dto;

import lombok.Data;

@Data
public class ReceptionistRegisterDTO {
    private String username;
    private String password;
    private String fullName;
    private String email;
    private String phone;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\ReceptionistResponseDTO.java ==== 
package com.example.stayops.dto;

import lombok.Data;

@Data
public class ReceptionistResponseDTO {
    private Long id;
    private String username;
    private String fullName;
    private String email;
    private String phone;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\ReservationDayDetailDTO.java ==== 
package com.example.stayops.dto;

import com.example.stayops.enums.ReservationStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationDayDetailDTO {
    private Long reservationId;
    private String guestId;
    private Set<Long> roomIds;
    private LocalDate checkInDate;
    private LocalDate checkOutDate;
    private ReservationStatus status;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\ReservationDetailsDTO.java ==== 
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationDetailsDTO {

    private Long id;  // Auto-generated ID
    private Long reservationId;  // Foreign key to reservation
    private Integer adults;
    private Integer kids;
    private String mealPlan;
    private String amenities;
    private String specialRequests;
    private String additionalNotes;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\ReservationHistoryDTO.java ==== 
package com.example.stayops.dto;

import com.example.stayops.enums.ReservationStatus;
import lombok.*;

import java.time.Instant;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationHistoryDTO {
    private Long historyId;
    private Long reservationId;
    private ReservationStatus previousStatus;
    private ReservationStatus newStatus;
    private String changedBy;
    private String notes;
    private Instant changedAt;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\ReservationHoldRequestDTO.java ==== 
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationHoldRequestDTO {

    private String sessionId;
    private String guestId;
    private Set<Long> roomIds;
    private String roomType;  // Alternative: hold at room type level
    private Integer numberOfRooms;
    private LocalDate checkInDate;
    private LocalDate checkOutDate;
    private Integer numberOfGuests;
    private String notes;
    private Integer ttlMinutes;  // Time-to-live in minutes (default 15)
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\ReservationHoldResponseDTO.java ==== 
package com.example.stayops.dto;

import com.example.stayops.enums.HoldStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.time.LocalDate;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationHoldResponseDTO {

    private Long holdId;
    private String holdToken;
    private String sessionId;
    private String guestId;
    private Set<Long> roomIds;
    private String roomType;
    private Integer numberOfRooms;
    private LocalDate checkInDate;
    private LocalDate checkOutDate;
    private HoldStatus status;
    private Instant expiresAt;
    private Long secondsRemaining;  // Calculated field
    private Instant createdAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\ReservationRequestDTO.java ==== 
// ========== 2. ReservationRequestDTO.java (ENHANCED) ==========
package com.example.stayops.dto;

import com.example.stayops.enums.ReservationStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationRequestDTO {
    private String guestId;
    private Set<Long> roomIds;
    private LocalDate checkInDate;
    private LocalDate checkOutDate;
    private ReservationStatus status;

    // Additional fields for reservation details
    private Integer adults;
    private Integer kids;
    private String mealPlan;
    private String amenities;
    private String specialRequests;
    private String additionalNotes;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\ReservationResponseDTO.java ==== 
package com.example.stayops.dto;

import com.example.stayops.enums.ReservationStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.time.LocalDate;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationResponseDTO {

    private Long reservationId;
    private String guestId;
    private Set<Long> roomIds;
    private LocalDate checkInDate;
    private LocalDate checkOutDate;
    private ReservationStatus status;
    private Instant createdAt;
    private Instant updatedAt;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\ReservationStatusDTO.java ==== 
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class ReservationStatusDTO {
    private Long roomId;
    private String roomNumber;
    private Long reservationId;
    private LocalDate checkInDate;
    private LocalDate checkOutDate;
    private String status;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\ReservationSummaryDTO.java ==== 
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class ReservationSummaryDTO {
    private LocalDate date;
    private int checkIns;
    private int checkOuts;
    private int totalReservations;

    // Increment methods
    public void incrementCheckIns() {
        this.checkIns++;
    }

    public void incrementCheckOuts() {
        this.checkOuts++;
    }

    public void incrementTotalReservations() {
        this.totalReservations++;
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\RoomBlockDTO.java ==== 
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoomBlockDTO {

    private Long id;
    private Long hotelId;
    private String blockCode;
    private String blockName;
    private LocalDate startDate;
    private LocalDate endDate;
    private Integer numberOfRooms;
    private Integer roomsBooked;
    private Integer availableRooms;  // Calculated field
    private String roomType;
    private BigDecimal groupRate;
    private String contactName;
    private String contactEmail;
    private String contactPhone;
    private String companyName;
    private LocalDate cutOffDate;
    private BigDecimal depositAmount;
    private Boolean depositReceived;
    private String ratePlanCode;
    private String specialRequests;
    private String notes;
    private Boolean isActive;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\RoomDTO.java ==== 
package com.example.stayops.dto;

import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoomDTO {
    private Long id;
    private String roomNumber;
    private String type;
    private int capacity;
    private Double pricePerNight;
    private String availabilityStatus;
    private String floorNumber;
    private String description;
    private Long hotelId; // Flatten relation
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\RoomStatusDTO.java ==== 
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoomStatusDTO {
    private Long roomId;
    private String roomNumber;
    private String roomType;
    private LocalDate date;
    private String status; // AVAILABLE, OCCUPIED, RESERVED, ARRIVING, DEPARTING, DIRTY, OUT_OF_SERVICE
    private Long reservationId;
    private String reservationStatus;
    private String guestId;
    private String guestName;
    private LocalDate checkInDate;
    private LocalDate checkOutDate;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\RoomStatusHistoryDTO.java ==== 
package com.example.stayops.dto;

import lombok.*;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoomStatusHistoryDTO {
    private Long id;
    private Long roomId;
    private String previousStatus;
    private String newStatus;
    private LocalDateTime changedAt;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\ServiceRequestDTO.java ==== 
package com.example.stayops.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ServiceRequestDTO {

    private Long id;
    private String serviceType;  // HOUSEKEEPING, ROOM_SERVICE, MAINTENANCE, LAUNDRY
    private String description;
    private String status;  // PENDING, IN_PROGRESS, COMPLETED, CANCELLED
    private String requestedBy;  // Guest ID or name
    private String priority;  // LOW, MEDIUM, HIGH, URGENT
    private Long reservationId;
    private Long roomId;
    private String roomNumber;  // For display purposes
    private String assignedTo;  // Staff member assigned
    private Instant completedAt;
    private String notes;
    private Instant createdAt;
    private Instant updatedAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\ServiceTypeDTO.java ==== 
package com.example.stayops.dto;

import jakarta.validation.constraints.*;
import lombok.*;

import java.math.BigDecimal;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString
public class ServiceTypeDTO {

    private Long id;

    @NotBlank(message = "Name is required")
    @Size(max = 120, message = "Name must be at most 120 characters")
    private String name;

    @NotBlank(message = "Code is required")
    @Pattern(regexp = "^[A-Z0-9_\\-]+$", message = "Code must be uppercase letters, numbers, underscores or hyphens")
    @Size(max = 20, message = "Code must be at most 20 characters")
    private String code;

    @NotNull(message = "Default charge is required")
    @DecimalMin(value = "0.0", inclusive = true, message = "Default charge must be non-negative")
    private BigDecimal defaultCharge;

    @Size(max = 2000, message = "Description must be at most 2000 characters")
    private String description;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\StaffRequestDTO.java ==== 
package com.example.stayops.dto;

import com.example.stayops.enums.StaffRole;
import com.example.stayops.enums.StaffStatus;
import lombok.*;

import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class StaffRequestDTO {
    private String staffId;
    private String name;
    private String email;
    private String phone;
    private StaffRole role;
    private StaffStatus status;
    private LocalDate hireDate;
    private Long departmentId;   // Link to Department
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\dto\StaffResponseDTO.java ==== 
package com.example.stayops.dto;

import com.example.stayops.enums.StaffRole;
import com.example.stayops.enums.StaffStatus;
import lombok.*;

import java.time.Instant;
import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class StaffResponseDTO {
    private String staffId;
    private String name;
    private String email;
    private String phone;
    private StaffRole role;
    private StaffStatus status;
    private LocalDate hireDate;
    private Long departmentId;
    private String departmentName;
    private Instant createdAt;
    private Instant updatedAt;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\Amenity.java ==== 
package com.example.stayops.entity;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.*;

import java.util.ArrayList;
import java.util.List;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
public class Amenity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String name;

    @ManyToMany(mappedBy = "amenities")
    @JsonIgnoreProperties({"amenities", "staffMembers", "rooms", "departments"})
    @Builder.Default
    private List<Hotel> hotels = new ArrayList<>();
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\AuditLog.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.time.Instant;

@Entity
@Table(name = "audit_logs", indexes = {
        @Index(name = "idx_audit_entity", columnList = "entityType,entityId"),
        @Index(name = "idx_audit_action", columnList = "action"),
        @Index(name = "idx_audit_actor", columnList = "actorType,actorId"),
        @Index(name = "idx_audit_timestamp", columnList = "timestamp")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AuditLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 50)
    private String entityType;  // RESERVATION, PAYMENT, HOLD, FOLIO, etc.

    @Column(nullable = false, length = 100)
    private String entityId;  // ID of the entity being audited

    @Column(nullable = false, length = 50)
    private String action;  // CREATE, UPDATE, DELETE, STATUS_CHANGE, PAYMENT, etc.

    @Column(nullable = false, length = 50)
    private String actorType;  // GUEST, STAFF, SYSTEM, WEBHOOK, OTA

    @Column(length = 100)
    private String actorId;  // User ID, system process name, webhook source

    @Column(length = 200)
    private String actorName;  // Human-readable actor name

    @Column(columnDefinition = "TEXT")
    private String oldValue;  // Previous state (JSON or text)

    @Column(columnDefinition = "TEXT")
    private String newValue;  // New state (JSON or text)

    @Column(length = 500)
    private String description;  // Human-readable description

    @Column(length = 50)
    private String ipAddress;

    @Column(length = 500)
    private String userAgent;

    @Column(length = 100)
    private String requestId;  // Trace request across services

    @Column(length = 100)
    private String sessionId;

    @Column(nullable = false)
    @CreationTimestamp
    private Instant timestamp;

    // For sensitive operations
    private Boolean isSensitive;

    @Column(length = 200)
    private String complianceTag;  // PCI_DSS, GDPR, etc.
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\CancellationPolicy.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "cancellation_policies")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"hotel"})
@EqualsAndHashCode(exclude = {"hotel"})
public class CancellationPolicy {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "hotel_id", nullable = false)
    private Hotel hotel;

    @Column(nullable = false, unique = true, length = 50)
    private String policyCode;  // e.g., FLEXIBLE, MODERATE, STRICT, NON_REFUNDABLE

    @Column(nullable = false, length = 100)
    private String policyName;

    @Column(length = 1000)
    private String description;

    // Hours before check-in for free cancellation
    private Integer freeCancellationHours;  // e.g., 24, 48, 72 hours

    // Cancellation fee structure
    @Column(precision = 5, scale = 2)
    private BigDecimal cancellationFeePercentage;  // % of total booking

    @Column(precision = 10, scale = 2)
    private BigDecimal cancellationFeeFixed;  // Fixed fee amount

    // No-show policy
    @Column(precision = 5, scale = 2)
    private BigDecimal noShowFeePercentage;

    @Column(precision = 10, scale = 2)
    private BigDecimal noShowFeeFixed;

    // For tiered policies: different fees for different time windows
    @Column(columnDefinition = "TEXT")
    private String tieredRules;  // JSON: [{hoursBeforeCheckin: 48, feePercent: 0}, {hoursBeforeCheckin: 24, feePercent: 50}, ...]

    @Column(nullable = false)
    @Builder.Default
    private Boolean isActive = true;

    private Integer displayOrder;

    @CreationTimestamp
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\ChannelMapping.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;

@Entity
@Table(name = "channel_mappings", indexes = {
        @Index(name = "idx_channel_booking_id", columnList = "externalBookingId"),
        @Index(name = "idx_channel_code", columnList = "channelCode")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ChannelMapping {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reservation_id", nullable = false)
    private Reservation reservation;

    @Column(nullable = false, length = 50)
    private String channelCode;  // OTA identifier: BOOKING_COM, EXPEDIA, AGODA, etc.

    @Column(nullable = false, unique = true, length = 100)
    private String externalBookingId;  // OTA's booking reference

    @Column(length = 100)
    private String externalReservationNumber;  // OTA's reservation number

    @Column(columnDefinition = "TEXT")
    private String channelData;  // JSON payload from OTA for reference

    @Column(length = 100)
    private String guestNameFromChannel;  // Guest name as provided by OTA

    @Column(length = 100)
    private String guestEmailFromChannel;

    private Boolean isChannelCollectedPayment;  // True if OTA collected payment

    @Column(length = 50)
    private String channelCommissionType;  // PERCENTAGE, FIXED

    @Column(precision = 5, scale = 2)
    private java.math.BigDecimal commissionRate;

    private Instant lastSyncedAt;

    @Column(length = 500)
    private String syncNotes;

    @CreationTimestamp
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\Department.java ==== 
package com.example.stayops.entity;

import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Data
@Entity
@Table(name = "departments")
@NoArgsConstructor
@AllArgsConstructor
@Builder
@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Department name is required")
    @Size(max = 100, message = "Department name cannot exceed 100 characters")
    @Column(nullable = false, unique = true, length = 100)
    private String name;

    @Size(max = 255, message = "Description cannot exceed 255 characters")
    private String description;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "hotel_id", nullable = false)
    @JsonBackReference
    private Hotel hotel;

    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnoreProperties({"department", "hotel"})  // CRITICAL: Ignore to prevent lazy loading
    private Set<Staff> staff = new HashSet<>();

    @CreationTimestamp
    @Column(updatable = false)
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\EmailConfirmationToken.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import java.time.Instant;
import java.time.temporal.ChronoUnit;

@Entity
@Table(name = "email_confirmation_tokens")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmailConfirmationToken {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "token", nullable = false, unique = true)
    private String token;

    @Column(name = "email", nullable = false)
    private String email;

    @Column(name = "guest_id", nullable = false)
    private String guestId;

    @Column(name = "used", nullable = false)
    private boolean used = false;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "expires_at", nullable = false)
    private Instant expiresAt;

    // Constructor that automatically sets expiry to 24 hours from now
    public EmailConfirmationToken(String token, String email, String guestId) {
        this.token = token;
        this.email = email;
        this.guestId = guestId;
        this.used = false;
        this.expiresAt = Instant.now().plus(24, ChronoUnit.HOURS);
    }

    public boolean isExpired() {
        return Instant.now().isAfter(expiresAt);
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\FolioLineItem.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "folio_line_items", indexes = {
        @Index(name = "idx_line_item_date", columnList = "transactionDate"),
        @Index(name = "idx_line_item_type", columnList = "itemType")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"folio"})
@EqualsAndHashCode(exclude = {"folio"})
public class FolioLineItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "folio_id", nullable = false)
    private GuestFolio folio;

    @Column(nullable = false)
    private LocalDate transactionDate;

    @Column(nullable = false, length = 50)
    private String itemType;  // ROOM_CHARGE, MINIBAR, LAUNDRY, PAYMENT, TAX, SERVICE_FEE, etc.

    @Column(nullable = false, length = 200)
    private String description;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;  // Positive for charges, negative for payments

    private Integer quantity;

    @Column(precision = 10, scale = 2)
    private BigDecimal unitPrice;

    @Column(length = 50)
    private String reference;  // Reference to service request, payment transaction, etc.

    @Column(length = 50)
    private String postedBy;  // Staff or system who posted the charge

    @Column(length = 100)
    private String department;  // FRONT_DESK, HOUSEKEEPING, F&B, etc.

    @Column(length = 500)
    private String notes;

    private Boolean isVoided;

    @Column(length = 50)
    private String voidedBy;

    private Instant voidedAt;

    @Column(length = 200)
    private String voidReason;

    @CreationTimestamp
    private Instant createdAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\FraudAlert.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.time.Instant;

@Entity
@Table(name = "fraud_alerts", indexes = {
        @Index(name = "idx_fraud_reservation", columnList = "reservation_id"),
        @Index(name = "idx_fraud_status", columnList = "status"),
        @Index(name = "idx_fraud_severity", columnList = "severity")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FraudAlert {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reservation_id")
    private Reservation reservation;

    @Column(length = 50)
    private String guestEmail;

    @Column(length = 100)
    private String ipAddress;

    @Column(nullable = false, length = 50)
    private String alertType; // MULTIPLE_FAILED_CARDS, SUSPICIOUS_PATTERN, IP_MISMATCH, VELOCITY_CHECK

    @Column(nullable = false, length = 20)
    private String severity; // LOW, MEDIUM, HIGH, CRITICAL

    @Column(nullable = false, length = 20)
    @Builder.Default
    private String status = "PENDING"; // PENDING, REVIEWED, CONFIRMED_FRAUD, FALSE_POSITIVE

    @Column(columnDefinition = "TEXT")
    private String details;

    private Integer riskScore; // 0-100

    @Column(length = 100)
    private String reviewedBy;

    private Instant reviewedAt;

    @Column(length = 500)
    private String reviewNotes;

    @CreationTimestamp
    private Instant createdAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\Guest.java ==== 
package com.example.stayops.entity;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import org.hibernate.validator.constraints.URL;

import java.time.Instant;

@Entity
@Table(name = "guests")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@JsonIgnoreProperties({"hibernateLazyInitializer", "handler", "qrCodeImage"})
public class Guest {

    @Id
    @Column(name = "guest_id", updatable = false, nullable = false, unique = true)
    private String guestId;

    @NotBlank
    @Column(name = "first_name", nullable = false)
    private String firstName;

    @NotBlank
    @Column(name = "last_name", nullable = false)
    private String lastName;

    @Email
    @NotBlank
    @Column(unique = true, nullable = false)
    private String email;

    @Pattern(regexp = "^[0-9+\\-]{7,15}$", message = "Invalid phone number")
    @Column(nullable = false)
    private String phone;

    @Column
    private String nationality;

    @Column(name = "identity_type")
    private String identityType;

    @Column(name = "identity_number")
    private String identityNumber;

    @Lob
    private byte[] qrCodeImage;

    @URL
    @Column(name = "image_url", unique = true)
    private String imageUrl;

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private Instant createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private Instant updatedAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\GuestAccount.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "guest_accounts")
public class GuestAccount {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToOne
    @JoinColumn(name = "guest_id", nullable = false, unique = true)
    private Guest guest;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    private boolean activated;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\GuestFolio.java ==== 
package com.example.stayops.entity;

import com.example.stayops.enums.FolioStatus;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "guest_folios", indexes = {
        @Index(name = "idx_folio_number", columnList = "folioNumber"),
        @Index(name = "idx_folio_status", columnList = "status")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"reservation", "lineItems"})
@EqualsAndHashCode(exclude = {"reservation", "lineItems"})
public class GuestFolio {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String folioNumber;  // Human-readable folio number

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reservation_id", nullable = false)
    private Reservation reservation;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    @Builder.Default
    private FolioStatus status = FolioStatus.OPEN;

    @OneToMany(mappedBy = "folio", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @Builder.Default
    private List<FolioLineItem> lineItems = new ArrayList<>();

    @Column(nullable = false, precision = 10, scale = 2)
    @Builder.Default
    private BigDecimal totalCharges = BigDecimal.ZERO;

    @Column(nullable = false, precision = 10, scale = 2)
    @Builder.Default
    private BigDecimal totalPayments = BigDecimal.ZERO;

    @Column(nullable = false, precision = 10, scale = 2)
    @Builder.Default
    private BigDecimal balance = BigDecimal.ZERO;  // totalCharges - totalPayments

    @Column(length = 3)
    private String currency;

    @Column(precision = 10, scale = 2)
    private BigDecimal depositAmount;

    @Column(precision = 10, scale = 2)
    private BigDecimal incidentalDeposit;  // Hold for incidentals

    private Instant settledAt;

    private Instant closedAt;

    @Column(length = 500)
    private String notes;

    @CreationTimestamp
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;

    // Helper methods for managing line items
    public void addLineItem(FolioLineItem item) {
        lineItems.add(item);
        item.setFolio(this);
        recalculateBalance();
    }

    public void recalculateBalance() {
        this.totalCharges = lineItems.stream()
                .filter(item -> item.getAmount().compareTo(BigDecimal.ZERO) > 0)
                .map(FolioLineItem::getAmount)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        this.totalPayments = lineItems.stream()
                .filter(item -> item.getAmount().compareTo(BigDecimal.ZERO) < 0)
                .map(FolioLineItem::getAmount)
                .map(BigDecimal::abs)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        this.balance = totalCharges.subtract(totalPayments);
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\Hotel.java ==== 
package com.example.stayops.entity;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "hotel")
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
public class Hotel {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "hotel_id")
    private long id;

    @Column(name = "name", nullable = false)
    private String name;

    @Column(name = "address")
    private String address;

    @Pattern(regexp = "^[0-9+\\-]{7,15}$", message = "Invalid phone number")
    @Column(nullable = false)
    private String phone;

    @Email
    @NotBlank
    @Column(nullable = false, unique = true)
    private String email;

    private String description;

    @OneToMany(mappedBy = "hotel", cascade = CascadeType.ALL)
    @JsonIgnoreProperties({"hotel", "department"})
    private List<Staff> staffMembers = new ArrayList<>();

    @OneToMany(mappedBy = "hotel", cascade = CascadeType.ALL)
    @JsonIgnoreProperties({"hotel", "reservations"})
    private List<Room> rooms = new ArrayList<>();

    @OneToMany(mappedBy = "hotel", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnoreProperties({"hotel", "staff"})  // CRITICAL: Ignore staff to prevent deep lazy loading
    private List<Department> departments = new ArrayList<>();

    @ManyToMany
    @JoinTable(
            name = "hotel_amenities",
            joinColumns = @JoinColumn(name = "hotel_id"),
            inverseJoinColumns = @JoinColumn(name = "amenity_id")
    )
    @JsonIgnoreProperties("hotels")
    private List<Amenity> amenities = new ArrayList<>();
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\HousekeepingTask.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "housekeeping_tasks", indexes = {
        @Index(name = "idx_hk_status", columnList = "status"),
        @Index(name = "idx_hk_scheduled_date", columnList = "scheduledDate"),
        @Index(name = "idx_hk_room", columnList = "room_id")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"room", "reservation"})
@EqualsAndHashCode(exclude = {"room", "reservation"})
public class HousekeepingTask {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id", nullable = false)
    private Room room;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reservation_id")
    private Reservation reservation;

    @Column(nullable = false, length = 50)
    private String taskType; // PRE_ARRIVAL, CHECKOUT_CLEAN, TURNDOWN, MAINTENANCE, DEEP_CLEAN

    @Column(nullable = false, length = 20)
    @Builder.Default
    private String status = "PENDING"; // PENDING, IN_PROGRESS, COMPLETED, CANCELLED

    @Column(nullable = false)
    private LocalDate scheduledDate;

    @Column(length = 20)
    @Builder.Default
    private String priority = "MEDIUM"; // LOW, MEDIUM, HIGH, URGENT

    @Column(length = 100)
    private String assignedTo; // Staff ID

    @Column(length = 1000)
    private String notes;

    private Instant completedAt;

    @Column(length = 100)
    private String completedBy;

    @CreationTimestamp
    @Column(updatable = false)
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\LoyaltyPoints.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "loyalty_points")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LoyaltyPoints {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // relation to Guest (assuming Guest entity exists)
    @OneToOne
    @JoinColumn(name = "guest_id", nullable = false, unique = true)
    private Guest guest;

    @Column(nullable = false)
    private Integer points = 0; // default 0

    private String membershipLevel; // e.g., Silver, Gold, Platinum
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\PaymentTransaction.java ==== 
package com.example.stayops.entity;

import com.example.stayops.enums.PaymentMethod;
import com.example.stayops.enums.PaymentStatus;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "payment_transactions", indexes = {
        @Index(name = "idx_payment_transaction_id", columnList = "providerTransactionId"),
        @Index(name = "idx_payment_idempotency", columnList = "idempotencyKey"),
        @Index(name = "idx_payment_status", columnList = "status")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"reservation"})
@EqualsAndHashCode(exclude = {"reservation"})
public class PaymentTransaction {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reservation_id")
    private Reservation reservation;

    @Column(nullable = false, unique = true, length = 100)
    private String idempotencyKey;  // Prevent duplicate transactions

    @Column(length = 100)
    private String providerTransactionId;  // Payment gateway transaction ID

    @Column(length = 100)
    private String paymentIntentId;  // Payment intent/session ID

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    @Builder.Default
    private PaymentStatus status = PaymentStatus.PENDING;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PaymentMethod paymentMethod;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;

    @Column(length = 3)
    private String currency;  // ISO currency code (USD, EUR, etc.)

    @Column(length = 20)
    private String cardLast4;  // Masked card number (last 4 digits)

    @Column(length = 50)
    private String cardBrand;  // Visa, Mastercard, etc.

    @Column(length = 100)
    private String cardToken;  // Tokenized card for future use

    @Column(length = 500)
    private String failureReason;

    @Column(length = 1000)
    private String webhookPayload;  // Store webhook data for debugging

    private Instant processedAt;

    @Column(length = 50)
    private String processedBy;  // Staff or system identifier

    @Column(length = 500)
    private String notes;

    // Refund related fields
    private Boolean isRefund;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "refund_of_transaction_id")
    private PaymentTransaction refundOfTransaction;  // Link to original transaction if this is a refund

    @Column(precision = 10, scale = 2)
    private BigDecimal refundedAmount;

    @CreationTimestamp
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\PricingRule.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "pricing_rules")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PricingRule {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String ruleName;

    @Column(nullable = false, length = 50)
    private String ruleType; // DEMAND_BASED, SEASONAL, LAST_MINUTE, EARLY_BIRD, OCCUPANCY_BASED

    @Column(nullable = false)
    private Boolean isActive;

    private Integer priority; // Lower number = higher priority

    // Conditions
    private Integer minDaysToArrival;
    private Integer maxDaysToArrival;
    private BigDecimal minOccupancyPercent;
    private BigDecimal maxOccupancyPercent;
    private LocalDate seasonStartDate;
    private LocalDate seasonEndDate;
    private String dayOfWeek; // MONDAY, TUESDAY, etc. or ALL

    // Adjustments (LKR)
    private BigDecimal priceMultiplier; // e.g., 1.2 for 20% increase
    private BigDecimal priceAddition; // Fixed amount to add in LKR
    private BigDecimal priceReduction; // Fixed amount to reduce in LKR
    private BigDecimal minPrice; // Floor price in LKR
    private BigDecimal maxPrice; // Ceiling price in LKR

    @Column(length = 500)
    private String description;

    @CreationTimestamp
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\RatePlan.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "rate_plans")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"hotel"})
@EqualsAndHashCode(exclude = {"hotel"})
public class RatePlan {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "hotel_id", nullable = false)
    private Hotel hotel;

    @Column(nullable = false, length = 50)
    private String ratePlanCode;  // Unique code like PROMO2024, CORPORATE, etc.

    @Column(nullable = false, length = 100)
    private String name;

    @Column(length = 500)
    private String description;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal baseRate;  // Per night base rate

    @Column(length = 20)
    private String roomType;  // Applicable room type

    // Date validity
    private LocalDate validFrom;
    private LocalDate validUntil;

    // Booking window (how far in advance)
    private Integer minAdvanceBookingDays;
    private Integer maxAdvanceBookingDays;

    // Stay requirements
    private Integer minLengthOfStay;
    private Integer maxLengthOfStay;

    // Discounts
    @Column(precision = 5, scale = 2)
    private BigDecimal discountPercentage;

    @Column(length = 50)
    private String promoCode;

    // Refundability
    private Boolean isRefundable;
    private Boolean requiresPrepayment;

    // Cancellation policy reference
    @Column(length = 50)
    private String cancellationPolicyCode;

    @Column(nullable = false)
    @Builder.Default
    private Boolean isActive = true;

    private Integer priority;  // For rate selection logic (lower = higher priority)

    @Column(length = 50)
    private String channelCode;  // For OTA-specific rates

    @CreationTimestamp
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\RateSnapshot.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "rate_snapshots")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"reservation"})
@EqualsAndHashCode(exclude = {"reservation"})
public class RateSnapshot {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reservation_id", nullable = false)
    private Reservation reservation;

    @Column(length = 50)
    private String ratePlanCode;  // Reference to rate plan used

    @Column(length = 100)
    private String ratePlanName;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal baseRatePerNight;

    @Column(precision = 10, scale = 2)
    private BigDecimal taxAmount;

    @Column(precision = 10, scale = 2)
    private BigDecimal serviceFeeAmount;

    @Column(precision = 10, scale = 2)
    private BigDecimal discountAmount;

    @Column(precision = 10, scale = 2)
    private BigDecimal totalAmount;

    @Column(length = 3)
    private String currency;

    private Integer numberOfNights;

    @Column(length = 100)
    private String promoCode;

    @Column(precision = 5, scale = 2)
    private BigDecimal taxRate;  // Tax percentage

    // Cancellation policy snapshot
    @Column(length = 50)
    private String cancellationPolicyCode;

    @Column(length = 1000)
    private String cancellationPolicyText;

    private LocalDate freeCancellationUntil;

    @Column(precision = 10, scale = 2)
    private BigDecimal cancellationFee;

    // Per-night breakdown stored as JSON or separate table if needed
    @Column(columnDefinition = "TEXT")
    private String perNightBreakdown;  // JSON format: [{date, rate, taxes}, ...]

    @Column(length = 500)
    private String notes;

    @CreationTimestamp
    private Instant createdAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\Receptionist.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "receptionists")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Receptionist {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false)
    private String fullName;

    @Column(nullable = false)
    private String email;

    @Column(nullable = false)
    private String phone;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\Reservation.java ==== 
package com.example.stayops.entity;

import com.example.stayops.enums.ReservationStatus;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Entity
@Table(name = "reservations")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"guest", "rooms", "reservationDetails", "history", "roomBlock"})
@EqualsAndHashCode(exclude = {"guest", "rooms", "reservationDetails", "history", "roomBlock"})
@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
public class Reservation {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long reservationId;

    @Column(nullable = false)
    private LocalDate checkInDate;

    @Column(nullable = false)
    private LocalDate checkOutDate;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    @Builder.Default
    private ReservationStatus status = ReservationStatus.PENDING;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "guest_id", nullable = false)
    @JsonIgnoreProperties({"qrCodeImage"})
    private Guest guest;

    @ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(
            name = "room_reservations",
            joinColumns = @JoinColumn(name = "reservation_id"),
            inverseJoinColumns = @JoinColumn(name = "room_id")
    )
    @JsonIgnoreProperties({"reservations", "hotel"})
    @Builder.Default
    private Set<Room> rooms = new HashSet<>();

    @OneToOne(mappedBy = "reservation", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @JsonIgnoreProperties("reservation")
    private ReservationDetails reservationDetails;

    @OneToMany(mappedBy = "reservation", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @JsonIgnoreProperties("reservation")
    @Builder.Default
    private List<ReservationHistory> history = new ArrayList<>();

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_block_id")
    @JsonIgnoreProperties({"reservations", "hotel"})
    private RoomBlock roomBlock;

    @CreationTimestamp
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;

    // Helper methods for managing bidirectional relationships
    public void addRoom(Room room) {
        this.rooms.add(room);
        room.getReservations().add(this);
    }

    public void removeRoom(Room room) {
        this.rooms.remove(room);
        room.getReservations().remove(this);
    }

    public void setRoomsCollection(Set<Room> newRooms) {
        if (this.rooms != null) {
            this.rooms.forEach(room -> room.getReservations().remove(this));
        }
        this.rooms = newRooms != null ? newRooms : new HashSet<>();
        this.rooms.forEach(room -> room.getReservations().add(this));
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\ReservationDetails.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "reservation_details")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "reservation")
@EqualsAndHashCode(exclude = "reservation")
public class ReservationDetails {

    @Id
    @Column(name = "reservation_id")
    private Long reservationId;  // Use reservation_id as the primary key

    @OneToOne(fetch = FetchType.LAZY)
    @MapsId  // This tells JPA to use the same value for both the PK and FK
    @JoinColumn(name = "reservation_id")
    private Reservation reservation;

    @Column(nullable = false)
    @Builder.Default
    private Integer adults = 1;

    @Column(nullable = false)
    @Builder.Default
    private Integer kids = 0;

    @Column(name = "meal_plan", length = 100)
    private String mealPlan;

    @Column(length = 500)
    private String amenities;

    @Column(name = "special_requests", length = 1000)
    private String specialRequests;

    @Column(name = "additional_notes", length = 1000)
    private String additionalNotes;

    // Ignore the room_id column if it exists in database but not needed
    @Transient
    private Long roomId;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\ReservationHistory.java ==== 
package com.example.stayops.entity;

import com.example.stayops.enums.ReservationStatus;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.time.Instant;

@Entity
@Table(name = "reservation_history")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReservationHistory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long historyId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reservation_id", nullable = false)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private Reservation reservation;

    @Enumerated(EnumType.STRING)
    private ReservationStatus previousStatus;

    @Enumerated(EnumType.STRING)
    private ReservationStatus newStatus;

    private String changedBy; // staff username/system

    @Column(length = 500)
    private String notes;

    @CreationTimestamp
    private Instant changedAt;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\ReservationHold.java ==== 
package com.example.stayops.entity;

import com.example.stayops.enums.HoldStatus;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;
import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "reservation_holds", indexes = {
        @Index(name = "idx_hold_expires_at", columnList = "expiresAt"),
        @Index(name = "idx_hold_status", columnList = "status"),
        @Index(name = "idx_hold_session", columnList = "sessionId")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"guest", "rooms"})
@EqualsAndHashCode(exclude = {"guest", "rooms"})
public class ReservationHold {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long holdId;

    @Column(nullable = false, unique = true, length = 100)
    private String holdToken;  // Idempotency token

    @Column(length = 100)
    private String sessionId;  // User session identifier

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "guest_id")
    private Guest guest;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
            name = "hold_rooms",
            joinColumns = @JoinColumn(name = "hold_id"),
            inverseJoinColumns = @JoinColumn(name = "room_id")
    )
    @Builder.Default
    private Set<Room> rooms = new HashSet<>();

    @Column(nullable = false)
    private LocalDate checkInDate;

    @Column(nullable = false)
    private LocalDate checkOutDate;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    @Builder.Default
    private HoldStatus status = HoldStatus.ACTIVE;

    @Column(nullable = false)
    private Instant expiresAt;  // TTL expiry timestamp

    @Column(length = 20)
    private String roomType;  // If hold is at room type level

    private Integer numberOfRooms;  // Number of rooms in hold

    private Integer numberOfGuests;

    @Column(length = 500)
    private String notes;

    // Link to reservation if converted
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reservation_id")
    private Reservation reservation;

    @CreationTimestamp
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;

    // Helper method to check if hold is expired
    public boolean isExpired() {
        return Instant.now().isAfter(expiresAt);
    }

    // Helper method to check if hold is active
    public boolean isActive() {
        return status == HoldStatus.ACTIVE && !isExpired();
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\Room.java ==== 
package com.example.stayops.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import lombok.*;

import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "rooms")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"hotel", "reservations"})
@EqualsAndHashCode(exclude = {"hotel", "reservations"})
@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
public class Room {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Column(nullable = false, unique = true)
    private String roomNumber;

    @NotBlank
    private String type;

    @Min(1)
    private int capacity;

    private Double pricePerNight;

    @NotBlank
    private String availabilityStatus;

    private String floorNumber;

    private String description;

    @ManyToOne(fetch = FetchType.LAZY, optional = true)
    @JoinColumn(name = "hotel_id", nullable = true)
    @JsonIgnoreProperties({"staffMembers", "rooms", "departments", "amenities"})
    private Hotel hotel;

    @ManyToMany(mappedBy = "rooms", fetch = FetchType.LAZY)
    @JsonIgnore
    @Builder.Default
    private List<Reservation> reservations = new ArrayList<>();
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\RoomBlock.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "room_blocks")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"hotel", "reservations"})
@EqualsAndHashCode(exclude = {"hotel", "reservations"})
public class RoomBlock {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "hotel_id", nullable = false)
    private Hotel hotel;

    @Column(nullable = false, unique = true, length = 50)
    private String blockCode;  // Unique identifier for the block

    @Column(nullable = false, length = 200)
    private String blockName;  // Event/group name

    @Column(nullable = false)
    private LocalDate startDate;

    @Column(nullable = false)
    private LocalDate endDate;

    @Column(nullable = false)
    private Integer numberOfRooms;  // Total rooms in block

    private Integer roomsBooked;  // Rooms already booked from block

    @Column(length = 50)
    private String roomType;  // Specific room type or "MIXED"

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal groupRate;  // Special group rate per night

    @Column(length = 100)
    private String contactName;

    @Column(length = 100)
    private String contactEmail;

    @Column(length = 20)
    private String contactPhone;

    @Column(length = 100)
    private String companyName;

    // Cut-off date: when block releases unbooked rooms
    private LocalDate cutOffDate;

    @Column(precision = 10, scale = 2)
    private BigDecimal depositAmount;

    private Boolean depositReceived;

    @Column(length = 50)
    private String ratePlanCode;  // Corporate rate plan if applicable

    @Column(length = 1000)
    private String specialRequests;

    @Column(length = 1000)
    private String notes;

    @Column(nullable = false)
    @Builder.Default
    private Boolean isActive = true;

    // Link to individual reservations made from this block
    @OneToMany(mappedBy = "roomBlock", fetch = FetchType.LAZY)
    @Builder.Default
    private List<Reservation> reservations = new ArrayList<>();

    @CreationTimestamp
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;

    // Helper method to check available rooms in block
    public Integer getAvailableRooms() {
        return numberOfRooms - (roomsBooked != null ? roomsBooked : 0);
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\RoomStatusHistory.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "room_status_history")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoomStatusHistory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // relation to Room
    @ManyToOne
    @JoinColumn(name = "room_id", nullable = false)
    private Room room;

    @Column(nullable = false)
    private String previousStatus;

    @Column(nullable = false)
    private String newStatus;

    @Column(nullable = false)
    private LocalDateTime changedAt;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\ServiceRequest.java ==== 
package com.example.stayops.entity;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;

@Entity
@Table(name = "service_requests")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
public class ServiceRequest {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String serviceType;

    @Column(length = 500)
    private String description;

    @Column(nullable = false, length = 20)
    @Builder.Default
    private String status = "PENDING";

    @Column(length = 100)
    private String requestedBy;

    @Column(length = 20)
    private String priority;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reservation_id")
    @JsonIgnoreProperties({"guest", "rooms", "reservationDetails", "history"})
    private Reservation reservation;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id")
    @JsonIgnoreProperties({"reservations", "hotel"})
    private Room room;

    @Column(length = 100)
    private String assignedTo;

    private Instant completedAt;

    @Column(length = 500)
    private String notes;

    @CreationTimestamp
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\ServiceType.java ==== 
package com.example.stayops.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "service_types", indexes = {
        @Index(name = "idx_service_type_code", columnList = "code")
}, uniqueConstraints = {
        @UniqueConstraint(name = "uk_service_type_code", columnNames = {"code"})
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class ServiceType {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 120)
    @NotBlank
    @Size(max = 120)
    private String name;

    @Column(nullable = false, length = 20, unique = true)
    @NotBlank
    @Size(max = 20)
    private String code; // e.g. "ROOM_CLEAN", "LATE_CHECKOUT"

    @Column(name = "default_charge", precision = 12, scale = 2, nullable = false)
    private BigDecimal defaultCharge;

    @Column(columnDefinition = "TEXT")
    private String description;

    @CreationTimestamp
    @Column(updatable = false)
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\entity\Staff.java ==== 
package com.example.stayops.entity;

import com.example.stayops.enums.StaffRole;
import com.example.stayops.enums.StaffStatus;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.Instant;
import java.time.LocalDate;

@Data
@Entity
@Table(name = "staff")
@NoArgsConstructor
@AllArgsConstructor
@Builder
@JsonIgnoreProperties({"hibernateLazyInitializer", "handler", "hotel", "department"})
public class Staff {

    @Id
    @Column(name = "staff_id", nullable = false, unique = true, length = 50)
    private String staffId;

    @NotBlank(message = "Name is required")
    @Size(max = 100, message = "Name cannot exceed 100 characters")
    @Column(nullable = false, length = 100)
    private String name;

    @Email(message = "Invalid email format")
    @Column(nullable = false, unique = true, length = 150)
    private String email;

    @NotBlank(message = "Phone is required")
    @Size(max = 20, message = "Phone number cannot exceed 20 characters")
    @Column(nullable = false, length = 20)
    private String phone;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    private StaffRole role;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    private StaffStatus status;

    @Column(name = "hire_date", nullable = false)
    private LocalDate hireDate;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "hotel_id", nullable = false)
    @JsonIgnoreProperties({"staffMembers", "rooms", "departments", "amenities"})
    private Hotel hotel;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id", nullable = false)
    @JsonIgnoreProperties({"staff", "hotel"})
    private Department department;

    @CreationTimestamp
    @Column(updatable = false)
    private Instant createdAt;

    @UpdateTimestamp
    private Instant updatedAt;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\enums\FolioStatus.java ==== 
package com.example.stayops.enums;

public enum FolioStatus {
    OPEN,       // Folio is active and accepting charges
    SETTLED,    // All charges paid
    CLOSED,     // Folio closed after checkout
    DISPUTED,   // Payment disputed
    TRANSFERRED // Charges transferred to another folio
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\enums\HoldStatus.java ==== 
package com.example.stayops.enums;

public enum HoldStatus {
    ACTIVE,      // Hold is active and inventory is reserved
    EXPIRED,     // Hold has expired, inventory released
    CONVERTED,   // Hold converted to confirmed reservation
    CANCELLED,   // Hold manually cancelled
    PAYMENT_PENDING // Hold waiting for payment completion
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\enums\PaymentMethod.java ==== 
package com.example.stayops.enums;

public enum PaymentMethod {
    CREDIT_CARD,
    DEBIT_CARD,
    CASH,
    BANK_TRANSFER,
    DIGITAL_WALLET,
    PAY_AT_HOTEL,
    CORPORATE_BILLING,
    OTA_COLLECTED  // Payment collected by OTA
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\enums\PaymentStatus.java ==== 
package com.example.stayops.enums;

public enum PaymentStatus {
    PENDING,           // Payment initiated but not confirmed
    AUTHORIZED,        // Payment authorized but not captured
    CAPTURED,          // Payment successfully captured
    FAILED,            // Payment failed
    REFUNDED,          // Payment refunded
    PARTIALLY_REFUNDED, // Partial refund issued
    CANCELLED,         // Payment cancelled
    DISPUTED,          // Chargeback/dispute raised
    TIMEOUT            // Payment timed out
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\enums\ReservationStatus.java ==== 
package com.example.stayops.enums;

public enum ReservationStatus {
    PENDING,
    OCCUPIED,
    CONFIRMED,
    CHECKED_IN,
    CHECKED_OUT,
    CANCELLED
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\enums\StaffRole.java ==== 
package com.example.stayops.enums;

public enum StaffRole {
    RECEPTIONIST,
    HOUSEKEEPING,
    CHEF,
    MANAGER,
    SECURITY,
    MAINTENANCE
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\enums\StaffStatus.java ==== 
package com.example.stayops.enums;

public enum StaffStatus {
    ACTIVE,
    INACTIVE,
    ON_LEAVE
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\event\EventPublisher.java ==== 
package com.example.stayops.event;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class EventPublisher {

    private final ApplicationEventPublisher applicationEventPublisher;

    public void publishReservationEvent(ReservationEvent event) {
        log.info("Publishing reservation event: {} for reservation {}",
                event.getEventType(), event.getReservationId());
        applicationEventPublisher.publishEvent(event);
    }

    public void publishPaymentEvent(PaymentEvent event) {
        log.info("Publishing payment event: {} for payment {}",
                event.getEventType(), event.getPaymentId());
        applicationEventPublisher.publishEvent(event);
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\event\PaymentEvent.java ==== 
package com.example.stayops.event;

import com.example.stayops.enums.PaymentStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.Instant;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PaymentEvent {
    private Long paymentId;
    private Long reservationId;
    private PaymentStatus status;
    private BigDecimal amount;
    private String eventType; // SUCCESS, FAILED, REFUNDED, AUTHORIZED
    private Instant eventTime;
    private String providerTransactionId;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\event\ReservationEvent.java ==== 
package com.example.stayops.event;

import com.example.stayops.enums.ReservationStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ReservationEvent {
    private Long reservationId;
    private String guestId;
    private ReservationStatus previousStatus;
    private ReservationStatus newStatus;
    private String eventType; // CREATED, CONFIRMED, CHECKED_IN, CHECKED_OUT, CANCELLED
    private Instant eventTime;
    private String triggeredBy;
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\exception\ApiError.java ==== 
package com.example.stayops.exception;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ApiError {

    private HttpStatus status;
    private String message;
    private String details;
    private LocalDateTime timestamp;

    // Constructor for (status, message)
    public ApiError(HttpStatus status, String message) {
        this.status = status;
        this.message = message;
        this.timestamp = LocalDateTime.now();
    }

    // Constructor for (status, message, details)
    public ApiError(HttpStatus status, String message, String details) {
        this.status = status;
        this.message = message;
        this.details = details;
        this.timestamp = LocalDateTime.now();
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\exception\GlobalExceptionHandler.java ==== 
package com.example.stayops.exception;

import jakarta.validation.ConstraintViolationException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.*;

import java.util.stream.Collectors;

@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

  @ExceptionHandler(ResourceNotFoundException.class)
  public ResponseEntity<ApiError> handleNotFound(ResourceNotFoundException ex) {
    ApiError error = new ApiError(HttpStatus.NOT_FOUND, ex.getMessage());
    return new ResponseEntity<>(error, error.getStatus());
  }

  @ExceptionHandler(MethodArgumentNotValidException.class)
  public ResponseEntity<ApiError> handleValidation(MethodArgumentNotValidException ex) {
    String msg = ex.getBindingResult().getFieldErrors()
            .stream()
            .map(fe -> fe.getField() + " : " + fe.getDefaultMessage())
            .collect(Collectors.joining("; "));
    ApiError error = new ApiError(HttpStatus.BAD_REQUEST, "Validation failed: " + msg);
    return new ResponseEntity<>(error, error.getStatus());
  }

  @ExceptionHandler(ConstraintViolationException.class)
  public ResponseEntity<ApiError> handleConstraintViolation(ConstraintViolationException ex) {
    ApiError error = new ApiError(HttpStatus.BAD_REQUEST, "Validation failed: " + ex.getMessage());
    return new ResponseEntity<>(error, error.getStatus());
  }

  @ExceptionHandler(Exception.class)
  public ResponseEntity<ApiError> handleAll(Exception ex) {
    log.error("Unhandled exception", ex);
    ApiError error = new ApiError(HttpStatus.INTERNAL_SERVER_ERROR, "An unexpected error occurred", ex.getMessage());
    return new ResponseEntity<>(error, error.getStatus());
  }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\exception\ResourceNotFoundException.java ==== 
package com.example.stayops.exception;

public class ResourceNotFoundException extends RuntimeException {

    public ResourceNotFoundException(String resource, String field, Object value) {
        super(String.format("%s not found with %s : '%s'", resource, field, value));
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\AmenityRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.Amenity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.List;

public interface AmenityRepository extends JpaRepository<Amenity, Long> {

    @Query(value = """
        SELECT a.* FROM amenity a
        INNER JOIN hotel_amenities ha ON a.id = ha.amenity_id
        WHERE ha.hotel_id = :hotelId
    """, nativeQuery = true)
    List<Amenity> findAmenitiesByHotelId(@Param("hotelId") Long hotelId);
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\AuditLogRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.*;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface AuditLogRepository extends JpaRepository<AuditLog, Long> {
    List<AuditLog> findByEntityTypeAndEntityId(String entityType, String entityId);
    List<AuditLog> findByActorTypeAndActorId(String actorType, String actorId);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\CancellationPolicyRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.*;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface CancellationPolicyRepository extends JpaRepository<CancellationPolicy, Long> {
    Optional<CancellationPolicy> findByPolicyCode(String policyCode);
    List<CancellationPolicy> findByHotelIdAndIsActive(Long hotelId, Boolean isActive);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\ChannelMappingRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.*;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ChannelMappingRepository extends JpaRepository<ChannelMapping, Long> {
    Optional<ChannelMapping> findByExternalBookingId(String externalBookingId);
    Optional<ChannelMapping> findByReservationReservationId(Long reservationId);
    List<ChannelMapping> findByChannelCode(String channelCode);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\DepartmentRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.Department;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface DepartmentRepository extends JpaRepository<Department, Long> {
    boolean existsByName(String name);  // to avoid duplicates
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\EmailConfirmationTokenRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.EmailConfirmationToken;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface EmailConfirmationTokenRepository extends JpaRepository<EmailConfirmationToken, Long> {
    Optional<EmailConfirmationToken> findByToken(String token);
    Optional<EmailConfirmationToken> findByEmailAndUsedFalse(String email);
    void deleteByGuestId(String guestId);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\FolioLineItemRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.*;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface FolioLineItemRepository extends JpaRepository<FolioLineItem, Long> {
    List<FolioLineItem> findByFolioIdOrderByTransactionDateDesc(Long folioId);
    List<FolioLineItem> findByFolioIdAndIsVoided(Long folioId, Boolean isVoided);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\FraudAlertRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.FraudAlert;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.List;

@Repository
public interface FraudAlertRepository extends JpaRepository<FraudAlert, Long> {

    List<FraudAlert> findByStatus(String status);

    List<FraudAlert> findByGuestEmail(String email);

    List<FraudAlert> findByIpAddress(String ipAddress);

    @Query("SELECT COUNT(f) FROM FraudAlert f WHERE f.guestEmail = :email " +
            "AND f.createdAt > :since")
    long countRecentAlertsByEmail(@Param("email") String email, @Param("since") Instant since);

    @Query("SELECT COUNT(f) FROM FraudAlert f WHERE f.ipAddress = :ip " +
            "AND f.createdAt > :since")
    long countRecentAlertsByIP(@Param("ip") String ip, @Param("since") Instant since);

    List<FraudAlert> findBySeverityAndStatus(String severity, String status);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\GuestAccountRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.GuestAccount;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface GuestAccountRepository extends JpaRepository<GuestAccount, Long> {
    Optional<GuestAccount> findByEmail(String email);
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\GuestFolioRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.GuestFolio;
import com.example.stayops.enums.FolioStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

@Repository
public interface GuestFolioRepository extends JpaRepository<GuestFolio, Long> {

    Optional<GuestFolio> findByFolioNumber(String folioNumber);

    Optional<GuestFolio> findByReservationReservationId(Long reservationId);

    List<GuestFolio> findByStatus(FolioStatus status);

    // Find folios with outstanding balance
    @Query("SELECT f FROM GuestFolio f WHERE f.balance > :minBalance AND f.status = 'OPEN'")
    List<GuestFolio> findFoliosWithOutstandingBalance(@Param("minBalance") BigDecimal minBalance);

    // Find folios ready for settlement (balance = 0 and open)
    @Query("SELECT f FROM GuestFolio f WHERE f.balance = 0 AND f.status = 'OPEN'")
    List<GuestFolio> findFoliosReadyForSettlement();

    @Query("SELECT DISTINCT f FROM GuestFolio f " +
            "JOIN f.reservation.rooms r " +
            "WHERE r.hotel.id = :hotelId AND f.status = 'OPEN'")
    List<GuestFolio> findOpenFoliosByHotel(@Param("hotelId") Long hotelId);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\GuestRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.Guest;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface GuestRepository extends JpaRepository<Guest, String> {
    Optional<Guest> findByEmail(String email);
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\HotelRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.Hotel;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface HotelRepository extends JpaRepository<Hotel, Long> {

    // Optional: Use JOIN FETCH for better performance (avoids N+1 query problem)
    @Query("SELECT DISTINCT h FROM Hotel h " +
            "LEFT JOIN FETCH h.departments " +
            "LEFT JOIN FETCH h.rooms " +
            "LEFT JOIN FETCH h.staffMembers")
    List<Hotel> findAllWithRelations();

    @Query("SELECT h FROM Hotel h " +
            "LEFT JOIN FETCH h.departments " +
            "LEFT JOIN FETCH h.rooms " +
            "LEFT JOIN FETCH h.staffMembers " +
            "WHERE h.id = :id")
    Optional<Hotel> findByIdWithRelations(Long id);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\HousekeepingTaskRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.HousekeepingTask;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;

@Repository
public interface HousekeepingTaskRepository extends JpaRepository<HousekeepingTask, Long> {

    List<HousekeepingTask> findByStatus(String status);

    List<HousekeepingTask> findByScheduledDate(LocalDate date);

    List<HousekeepingTask> findByReservationReservationId(Long reservationId);

    List<HousekeepingTask> findByRoomId(Long roomId);

    List<HousekeepingTask> findByAssignedTo(String staffId);

    @Query("SELECT h FROM HousekeepingTask h WHERE h.status = 'PENDING' " +
            "AND h.scheduledDate <= :date ORDER BY h.priority DESC, h.scheduledDate ASC")
    List<HousekeepingTask> findOverdueTasks(@Param("date") LocalDate date);

    @Query("SELECT h FROM HousekeepingTask h WHERE h.status IN ('PENDING', 'IN_PROGRESS') " +
            "AND h.priority = 'URGENT' ORDER BY h.scheduledDate ASC")
    List<HousekeepingTask> findUrgentTasks();
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\LoyaltyPointsRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.LoyaltyPoints;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface LoyaltyPointsRepository extends JpaRepository<LoyaltyPoints, Long> {
    Optional<LoyaltyPoints> findByGuestGuestId(String guestId);
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\PaymentTransactionRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.PaymentTransaction;
import com.example.stayops.enums.PaymentStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.List;
import java.util.Optional;

@Repository
public interface PaymentTransactionRepository extends JpaRepository<PaymentTransaction, Long> {

    Optional<PaymentTransaction> findByIdempotencyKey(String idempotencyKey);

    Optional<PaymentTransaction> findByProviderTransactionId(String providerTransactionId);

    Optional<PaymentTransaction> findByPaymentIntentId(String paymentIntentId);

    List<PaymentTransaction> findByReservationReservationId(Long reservationId);

    List<PaymentTransaction> findByStatus(PaymentStatus status);

    // Find pending payments older than threshold (for timeout handling)
    @Query("SELECT p FROM PaymentTransaction p " +
            "WHERE p.status = 'PENDING' " +
            "AND p.createdAt < :threshold")
    List<PaymentTransaction> findPendingPaymentsOlderThan(@Param("threshold") Instant threshold);

    // Find refunds for a specific transaction
    List<PaymentTransaction> findByRefundOfTransaction_Id(Long transactionId);

    // Find successful payments for a reservation
    @Query("SELECT p FROM PaymentTransaction p " +
            "WHERE p.reservation.reservationId = :reservationId " +
            "AND p.status IN ('AUTHORIZED', 'CAPTURED') " +
            "AND (p.isRefund IS NULL OR p.isRefund = false)")
    List<PaymentTransaction> findSuccessfulPaymentsForReservation(@Param("reservationId") Long reservationId);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\PricingRuleRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.PricingRule;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface PricingRuleRepository extends JpaRepository<PricingRule, Long> {

    List<PricingRule> findByIsActiveTrueOrderByPriorityAsc();

    List<PricingRule> findByRuleTypeAndIsActive(String ruleType, Boolean isActive);

    @Query("SELECT p FROM PricingRule p WHERE p.isActive = true ORDER BY p.priority ASC, p.id ASC")
    List<PricingRule> findActiveRulesInOrder();
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\RatePlanRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.RatePlan;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface RatePlanRepository extends JpaRepository<RatePlan, Long> {

    Optional<RatePlan> findByRatePlanCode(String ratePlanCode);

    List<RatePlan> findByHotelIdAndIsActive(Long hotelId, Boolean isActive);

    Optional<RatePlan> findByPromoCode(String promoCode);

    // Find applicable rate plans for a date range and room type
    @Query("SELECT r FROM RatePlan r " +
            "WHERE r.hotel.id = :hotelId " +
            "AND r.isActive = true " +
            "AND (r.roomType IS NULL OR r.roomType = :roomType) " +
            "AND (r.validFrom IS NULL OR r.validFrom <= :checkInDate) " +
            "AND (r.validUntil IS NULL OR r.validUntil >= :checkOutDate) " +
            "ORDER BY r.priority ASC")
    List<RatePlan> findApplicableRatePlans(
            @Param("hotelId") Long hotelId,
            @Param("roomType") String roomType,
            @Param("checkInDate") LocalDate checkInDate,
            @Param("checkOutDate") LocalDate checkOutDate
    );

    // Find rate plan by promo code for specific dates
    @Query("SELECT r FROM RatePlan r " +
            "WHERE r.promoCode = :promoCode " +
            "AND r.isActive = true " +
            "AND (r.validFrom IS NULL OR r.validFrom <= :date) " +
            "AND (r.validUntil IS NULL OR r.validUntil >= :date)")
    Optional<RatePlan> findByPromoCodeAndDate(
            @Param("promoCode") String promoCode,
            @Param("date") LocalDate date
    );

    // Find channel-specific rates
    List<RatePlan> findByChannelCodeAndIsActive(String channelCode, Boolean isActive);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\RateSnapshotRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.*;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface RateSnapshotRepository extends JpaRepository<RateSnapshot, Long> {
    Optional<RateSnapshot> findByReservationReservationId(Long reservationId);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\ReceptionistRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.Receptionist;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface ReceptionistRepository extends JpaRepository<Receptionist, Long> {
    Optional<Receptionist> findByUsername(String username);
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\ReservationDetailsRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.ReservationDetails;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ReservationDetailsRepository extends JpaRepository<ReservationDetails, Long> {

    // Remove the custom query since we're using reservation_id as the primary key
    // The default findById will work now
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\ReservationHistoryRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.ReservationHistory;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ReservationHistoryRepository extends JpaRepository<ReservationHistory, Long> {
    List<ReservationHistory> findByReservation_ReservationId(Long reservationId);
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\ReservationHoldRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.ReservationHold;
import com.example.stayops.enums.HoldStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface ReservationHoldRepository extends JpaRepository<ReservationHold, Long> {

    Optional<ReservationHold> findByHoldToken(String holdToken);

    List<ReservationHold> findBySessionId(String sessionId);

    List<ReservationHold> findByStatus(HoldStatus status);

    // Find expired active holds
    @Query("SELECT h FROM ReservationHold h WHERE h.status = 'ACTIVE' AND h.expiresAt < :currentTime")
    List<ReservationHold> findExpiredActiveHolds(@Param("currentTime") Instant currentTime);

    // Find holds overlapping with a date range for a specific room
    @Query("SELECT h FROM ReservationHold h " +
            "JOIN h.rooms r " +
            "WHERE r.id = :roomId " +
            "AND h.status = 'ACTIVE' " +
            "AND h.checkInDate < :checkOutDate " +
            "AND h.checkOutDate > :checkInDate")
    List<ReservationHold> findActiveHoldsForRoom(
            @Param("roomId") Long roomId,
            @Param("checkInDate") LocalDate checkInDate,
            @Param("checkOutDate") LocalDate checkOutDate
    );

    // Find active holds by guest
    List<ReservationHold> findByGuestGuestIdAndStatus(String guestId, HoldStatus status);

    // Find holds that will expire soon (for notifications)
    @Query("SELECT h FROM ReservationHold h " +
            "WHERE h.status = 'ACTIVE' " +
            "AND h.expiresAt BETWEEN :now AND :threshold")
    List<ReservationHold> findHoldsExpiringSoon(
            @Param("now") Instant now,
            @Param("threshold") Instant threshold
    );
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\ReservationRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.Reservation;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;

public interface ReservationRepository extends JpaRepository<Reservation, Long> {

    // ==================== DATE OVERLAP QUERIES ====================

    /**
     * Find all reservations that overlap with a given date range
     * A reservation overlaps if its checkout is after or on the start date
     * AND its checkin is before or on the end date
     */
    @Query("SELECT r FROM Reservation r WHERE r.checkInDate <= :end AND r.checkOutDate >= :start")
    List<Reservation> findReservationsOverlapping(@Param("start") LocalDate start, @Param("end") LocalDate end);

    /**
     * Find overlapping reservations for a specific room
     */
    @Query("SELECT r FROM Reservation r JOIN r.rooms rm WHERE rm.id = :roomId " +
            "AND r.checkInDate <= :end AND r.checkOutDate >= :start")
    List<Reservation> findOverlappingReservationsForRoom(@Param("roomId") Long roomId,
                                                         @Param("start") LocalDate start,
                                                         @Param("end") LocalDate end);

    /**
     * Find overlapping reservations for a specific room, excluding a specific reservation
     * (useful when updating an existing reservation)
     */
    @Query("SELECT r FROM Reservation r JOIN r.rooms rm WHERE rm.id = :roomId " +
            "AND r.reservationId <> :excludeId " +
            "AND r.checkInDate <= :end AND r.checkOutDate >= :start")
    List<Reservation> findOverlappingReservationsForRoomExcludingReservation(
            @Param("roomId") Long roomId,
            @Param("excludeId") Long excludeId,
            @Param("start") LocalDate start,
            @Param("end") LocalDate end);

    // ==================== DATE-SPECIFIC QUERIES ====================

    /**
     * Find all reservations checking in on a specific date
     */
    @Query("SELECT r FROM Reservation r WHERE r.checkInDate = :date")
    List<Reservation> findByCheckInDate(@Param("date") LocalDate date);

    /**
     * Find all reservations checking out on a specific date
     */
    @Query("SELECT r FROM Reservation r WHERE r.checkOutDate = :date")
    List<Reservation> findByCheckOutDate(@Param("date") LocalDate date);

    // ==================== GUEST QUERIES ====================

    /**
     * Find all reservations for a specific guest
     */
    @Query("SELECT r FROM Reservation r WHERE r.guest.guestId = :guestId ORDER BY r.checkInDate DESC")
    List<Reservation> findByGuestGuestId(@Param("guestId") String guestId);

    // ==================== ROOM STATUS QUERIES ====================

    /**
     * Get room-reservation mapping with status information
     */
    @Query("""
           SELECT new map(
               rm.id as roomId, 
               rm.roomNumber as roomNumber, 
               r.reservationId as reservationId,
               r.checkInDate as checkInDate, 
               r.checkOutDate as checkOutDate, 
               r.status as status
           )
           FROM Reservation r JOIN r.rooms rm
           """)
    List<Map<String, Object>> findAllRoomReservationStatuses();
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\RoomBlockRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.RoomBlock;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface RoomBlockRepository extends JpaRepository<RoomBlock, Long> {

    Optional<RoomBlock> findByBlockCode(String blockCode);

    List<RoomBlock> findByHotelIdAndIsActive(Long hotelId, Boolean isActive);

    // Find blocks with available rooms
    @Query("SELECT b FROM RoomBlock b " +
            "WHERE b.isActive = true " +
            "AND (b.numberOfRooms - COALESCE(b.roomsBooked, 0)) > 0 " +
            "AND b.startDate <= :date " +
            "AND b.endDate >= :date")
    List<RoomBlock> findBlocksWithAvailability(@Param("date") LocalDate date);

    // Find blocks expiring soon (cutoff date approaching)
    @Query("SELECT b FROM RoomBlock b " +
            "WHERE b.isActive = true " +
            "AND b.cutOffDate BETWEEN :startDate AND :endDate")
    List<RoomBlock> findBlocksExpiringSoon(
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate
    );

    // Find blocks overlapping with date range
    @Query("SELECT b FROM RoomBlock b " +
            "WHERE b.hotel.id = :hotelId " +
            "AND b.isActive = true " +
            "AND b.startDate < :checkOutDate " +
            "AND b.endDate > :checkInDate")
    List<RoomBlock> findOverlappingBlocks(
            @Param("hotelId") Long hotelId,
            @Param("checkInDate") LocalDate checkInDate,
            @Param("checkOutDate") LocalDate checkOutDate
    );
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\RoomRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.Room;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface RoomRepository extends JpaRepository<Room, Long> {
    List<Room> findByAvailabilityStatus(String availabilityStatus);
    List<Room> findByType(String type);
    List<Room> findByHotelId(Long hotelId);
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\RoomStatusHistoryRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.RoomStatusHistory;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface RoomStatusHistoryRepository extends JpaRepository<RoomStatusHistory, Long> {
    List<RoomStatusHistory> findByRoomId(Long roomId);
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\ServiceRequestRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.ServiceRequest;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.List;

@Repository
public interface ServiceRequestRepository extends JpaRepository<ServiceRequest, Long> {

    // Find by status
    List<ServiceRequest> findByStatus(String status);

    // Find by service type
    List<ServiceRequest> findByServiceType(String serviceType);

    // Find by priority
    List<ServiceRequest> findByPriority(String priority);

    // Find by reservation
    List<ServiceRequest> findByReservationReservationId(Long reservationId);

    // Find by room
    List<ServiceRequest> findByRoomId(Long roomId);

    // Find by assigned staff
    List<ServiceRequest> findByAssignedTo(String assignedTo);

    // Find pending requests
    @Query("SELECT s FROM ServiceRequest s WHERE s.status = 'PENDING' ORDER BY s.createdAt ASC")
    List<ServiceRequest> findPendingRequests();

    // Find urgent requests
    @Query("SELECT s FROM ServiceRequest s WHERE s.priority = 'URGENT' AND s.status != 'COMPLETED' ORDER BY s.createdAt ASC")
    List<ServiceRequest> findUrgentRequests();

    // Find requests by status and priority
    List<ServiceRequest> findByStatusAndPriority(String status, String priority);

    // Find requests created within date range
    @Query("SELECT s FROM ServiceRequest s WHERE s.createdAt BETWEEN :startDate AND :endDate")
    List<ServiceRequest> findByDateRange(@Param("startDate") Instant startDate, @Param("endDate") Instant endDate);

    // Find incomplete requests (not completed or cancelled)
    @Query("SELECT s FROM ServiceRequest s WHERE s.status NOT IN ('COMPLETED', 'CANCELLED')")
    List<ServiceRequest> findIncompleteRequests();

    // Count by status
    Long countByStatus(String status);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\ServiceTypeRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.ServiceType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ServiceTypeRepository extends JpaRepository<ServiceType, Long> {

    Optional<ServiceType> findByCode(String code);

    boolean existsByCode(String code);
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\repository\StaffRepository.java ==== 
package com.example.stayops.repository;

import com.example.stayops.entity.Staff;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface StaffRepository extends JpaRepository<Staff, String> {
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\scheduling\ReservationScheduledJobs.java ==== 
package com.example.stayops.scheduling;

import com.example.stayops.service.PaymentService;
import com.example.stayops.service.ReservationHoldService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

/**
 * Scheduled jobs for reservation system background tasks
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class ReservationScheduledJobs {

    private final ReservationHoldService holdService;
    private final PaymentService paymentService;

    /**
     * Process expired holds every 5 minutes
     */
    @Scheduled(fixedRate = 300000) // 5 minutes
    public void processExpiredHolds() {
        log.info("Running scheduled job: Process expired holds");
        try {
            int processed = holdService.processExpiredHolds();
            log.info("Processed {} expired holds", processed);
        } catch (Exception e) {
            log.error("Error processing expired holds", e);
        }
    }

    /**
     * Process timeout payments every 10 minutes
     */
    @Scheduled(fixedRate = 600000) // 10 minutes
    public void processTimeoutPayments() {
        log.info("Running scheduled job: Process timeout payments");
        try {
            int processed = paymentService.processTimeoutPayments(30); // 30 minute timeout
            log.info("Processed {} timeout payments", processed);
        } catch (Exception e) {
            log.error("Error processing timeout payments", e);
        }
    }

    /**
     * Send arrival reminders - runs at 9 AM daily
     */
    @Scheduled(cron = "0 0 9 * * *") // 9 AM daily
    public void sendArrivalReminders() {
        log.info("Running scheduled job: Send arrival reminders");
        try {
            // TODO: Implement reminder sending for arrivals in next 24-48 hours
            log.info("Arrival reminders sent");
        } catch (Exception e) {
            log.error("Error sending arrival reminders", e);
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\security\GuestUserDetails.java ==== 
package com.example.stayops.security;

import com.example.stayops.entity.GuestAccount;
import lombok.Getter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;
import java.util.Objects;

@Getter
public class GuestUserDetails implements UserDetails {

    private final GuestAccount guestAccount;

    public GuestUserDetails(GuestAccount guestAccount) {
        this.guestAccount = Objects.requireNonNull(guestAccount, "GuestAccount cannot be null");
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singletonList(new SimpleGrantedAuthority("ROLE_GUEST"));
    }

    @Override
    public String getPassword() {
        return guestAccount.getPassword();
    }

    @Override
    public String getUsername() {
        return guestAccount.getEmail();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true; // You can add logic here if you want to handle account expiration
    }

    @Override
    public boolean isAccountNonLocked() {
        return true; // You can add logic here if you want to handle account locking
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true; // You can add logic here if you want to handle credential expiration
    }

    @Override
    public boolean isEnabled() {
        return guestAccount.isActivated();
    }

    // Additional utility methods
    public String getEmail() {
        return guestAccount.getEmail();
    }

    public String getGuestId() {
        return guestAccount.getGuest() != null ? guestAccount.getGuest().getGuestId() : null;
    }

    public String getFullName() {
        if (guestAccount.getGuest() != null) {
            return guestAccount.getGuest().getFirstName() + " " + guestAccount.getGuest().getLastName();
        }
        return null;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        GuestUserDetails that = (GuestUserDetails) obj;
        return Objects.equals(guestAccount.getEmail(), that.guestAccount.getEmail());
    }

    @Override
    public int hashCode() {
        return Objects.hash(guestAccount.getEmail());
    }

    @Override
    public String toString() {
        return "GuestUserDetails{" +
                "email='" + guestAccount.getEmail() + '\'' +
                ", activated=" + guestAccount.isActivated() +
                '}';
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\security\JwtRequestFilter.java ==== 
package com.example.stayops.security;

import com.example.stayops.service.impl.GuestUserDetailsService;
import com.example.stayops.util.JwtUtil;
import io.jsonwebtoken.ExpiredJwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class JwtRequestFilter extends OncePerRequestFilter {

    private final GuestUserDetailsService userDetailsService;
    private final JwtUtil jwtUtil;

    /**
     * PUBLIC_ENDPOINTS contains ant-style patterns where appropriate.
     * "/api/rooms/**" will match /api/rooms/create, /api/rooms/getAll etc.
     */
    private static final List<String> PUBLIC_ENDPOINTS = List.of(
            "/api/v1/guests/create",
            "/api/v1/guests/register",
            "/api/v1/guests/getAll",
            "/api/v1/auth/login",
            "/api/v1/auth/validate",
            "/api/receptionists/register",
            "/api/hotels/**",
            "/api/room-status-history/**",
            "/api/rooms/**",
            "/api/reservations/**",
            "/api/amenities/**",
            "/api/departments/**",
            "/api/v1/guests/**",
            "/api/reservation-details/**",
            "/api/receptionists/**",
            "/api/staff/**",
            "/api/debug/**"
    );

    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {

        final String requestTokenHeader = request.getHeader("Authorization");
        final String requestURI = request.getRequestURI();
        final String method = request.getMethod();

        log.info("=== JWT FILTER DEBUG ===");
        log.info("Method: {}", method);
        log.info("URI: {}", requestURI);
        log.info("Authorization Header: {}", requestTokenHeader != null ? "Present" : "Not Present");

        // Skip JWT processing for public endpoints and OPTIONS requests
        if (isPublicEndpoint(requestURI) || "OPTIONS".equalsIgnoreCase(method)) {
            log.info("SKIPPING JWT processing for public endpoint: {}", requestURI);
            chain.doFilter(request, response);
            return;
        }

        log.info("PROCESSING JWT for protected endpoint: {}", requestURI);

        String username = null;
        String jwtToken = null;

        // JWT Token is in the form "Bearer token". Remove Bearer word and get only the Token
        if (requestTokenHeader != null && requestTokenHeader.startsWith("Bearer ")) {
            jwtToken = requestTokenHeader.substring(7);
            try {
                username = jwtUtil.getUsernameFromToken(jwtToken);
                log.info("JWT token found for user: {}", username);
            } catch (IllegalArgumentException e) {
                log.error("Unable to get JWT Token: {}", e.getMessage());
            } catch (ExpiredJwtException e) {
                log.error("JWT Token has expired: {}", e.getMessage());
            } catch (Exception e) {
                log.error("JWT Token processing error: {}", e.getMessage());
            }
        } else {
            log.warn("No Bearer token found for protected endpoint: {}", requestURI);
        }

        // Once we get the token validate it.
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            try {
                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);

                // if token is valid configure Spring Security to manually set authentication
                if (jwtUtil.validateToken(jwtToken, userDetails)) {
                    UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken =
                            new UsernamePasswordAuthenticationToken(
                                    userDetails, null, userDetails.getAuthorities());
                    usernamePasswordAuthenticationToken
                            .setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);
                    log.info("Authentication set successfully for user: {}", username);
                } else {
                    log.warn("JWT token validation failed for user: {}", username);
                }
            } catch (Exception e) {
                log.error("Authentication error for user {}: {}", username, e.getMessage());
            }
        }
        log.info("=== END JWT FILTER DEBUG ===");
        chain.doFilter(request, response);
    }

    private boolean isPublicEndpoint(String requestURI) {
        for (String endpoint : PUBLIC_ENDPOINTS) {
            // Ant-style pattern match (supports /**)
            if (pathMatcher.match(endpoint, requestURI) || requestURI.startsWith(endpoint)) {
                log.info("Endpoint {} matches public pattern: {}", requestURI, endpoint);
                return true;
            }
        }
        log.warn("Endpoint {} does NOT match any public patterns", requestURI);
        log.info("Available public patterns: {}", PUBLIC_ENDPOINTS);
        return false;
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\AmenityService.java ==== 
package com.example.stayops.service;

import com.example.stayops.entity.Amenity;

import java.util.List;

public interface AmenityService {
    List<Amenity> getAllAmenities();
    Amenity addAmenity(Amenity amenity);
    void deleteAmenity(Long id);
    List<Amenity> getAmenitiesByHotelId(Long hotelId);
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\AuthService.java ==== 
package com.example.stayops.service;

import com.example.stayops.dto.LoginDTO;
import com.example.stayops.dto.LoginResponseDTO;

public interface AuthService {
    LoginResponseDTO authenticateGuest(LoginDTO loginDTO);
    boolean validateToken(String token);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\DepartmentService.java ==== 
package com.example.stayops.service;

import com.example.stayops.entity.Department;

import java.util.List;

public interface DepartmentService {
    Department createDepartment(Department department);
    Department updateDepartment(Long id, Department department);
    void deleteDepartment(Long id);
    Department getDepartmentById(Long id);
    List<Department> getAllDepartments();
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\EmailService.java ==== 
package com.example.stayops.service;

import com.example.stayops.entity.EmailConfirmationToken;
import com.example.stayops.entity.Guest;

public interface EmailService {

    /**
     * Send welcome email with registration link to the guest
     * @param guest Guest entity
     */
    void sendWelcomeEmailWithRegistrationLink(Guest guest);

    /**
     * Validate email confirmation token
     * @param token Token string
     * @return EmailConfirmationToken if valid
     * @throws RuntimeException if token is invalid, expired, or already used
     */
    EmailConfirmationToken validateToken(String token);

    /**
     * Mark token as used after successful registration
     * @param token Token string
     */
    void markTokenAsUsed(String token);

    /**
     * Check if email confirmation token exists and is valid for the email
     * @param email Guest email
     * @return true if valid token exists
     */
    boolean hasValidTokenForEmail(String email);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\GuestService.java ==== 
package com.example.stayops.service;

import com.example.stayops.dto.GuestCreateDTO;
import com.example.stayops.dto.GuestRegistrationDTO;
import com.example.stayops.dto.GuestResponseDTO;
import com.example.stayops.entity.GuestAccount;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

public interface GuestService {

    /**
     * Create a guest and optionally upload an identity image.
     *
     * @param dto           Guest data (JSON)
     * @param identityImage Identity image file (optional)
     * @return created GuestResponseDTO
     */
    GuestResponseDTO createGuest(GuestCreateDTO dto, MultipartFile identityImage);

    /**
     * Get guest details by guest ID.
     *
     * @param guestId Guest unique ID
     * @return GuestResponseDTO
     */
    GuestResponseDTO getGuestById(String guestId);

    /**
     * Get all guests.
     *
     * @return List of GuestResponseDTO
     */
    List<GuestResponseDTO> getAllGuests();

    /**
     * Register a guest from mobile app.
     *
     * @param dto GuestRegistrationDTO
     * @return created GuestAccount
     */
    GuestAccount registerGuestFromMobile(GuestRegistrationDTO dto);

    /**
     * Register a guest from web registration link (email confirmation flow)
     *
     * @param dto GuestRegistrationDTO
     * @param token Email confirmation token
     * @return created GuestAccount
     */
    GuestAccount registerGuestFromWeb(GuestRegistrationDTO dto, String token);

    /**
     * Return the guest's QR image as a full data URL (e.g. data:image/png;base64,...).
     * This is useful for frontends that want to render the image directly.
     *
     * @param guestId guest id
     * @return data url string or null if not present
     */
    String getGuestQrCodeDataUrl(String guestId);

    /**
     * Get guest information by email confirmation token
     *
     * @param token Email confirmation token
     * @return Guest email and ID
     */
    GuestResponseDTO getGuestByToken(String token);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\HotelService.java ==== 
package com.example.stayops.service;

import com.example.stayops.entity.Hotel;

import java.util.List;

public interface HotelService {

    Hotel createHotel(Hotel hotel);

    Hotel updateHotel(Long hotelId, Hotel hotel);

    void deleteHotel(Long hotelId);

    Hotel getHotelById(Long hotelId);

    List<Hotel> getAllHotels();
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\LoyaltyPointsService.java ==== 
package com.example.stayops.service;

import com.example.stayops.dto.LoyaltyPointsDTO;
import java.util.List;

public interface LoyaltyPointsService {
    LoyaltyPointsDTO createOrUpdate(LoyaltyPointsDTO dto);
    LoyaltyPointsDTO getByGuestId(String guestId);
    List<LoyaltyPointsDTO> getAll();
    void delete(Long id);
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\PaymentService.java ==== 
package com.example.stayops.service;

import com.example.stayops.dto.PaymentTransactionDTO;

import java.math.BigDecimal;
import java.util.List;

public interface PaymentService {

    /**
     * Initiate a payment transaction with idempotency
     */
    PaymentTransactionDTO initiatePayment(PaymentTransactionDTO request);

    /**
     * Process payment webhook (from payment provider)
     */
    PaymentTransactionDTO processWebhook(String webhookPayload, String signature);

    /**
     * Get payment by idempotency key (prevents duplicates)
     */
    PaymentTransactionDTO getByIdempotencyKey(String idempotencyKey);

    /**
     * Get all payments for a reservation
     */
    List<PaymentTransactionDTO> getPaymentsByReservation(Long reservationId);

    /**
     * Initiate refund
     */
    PaymentTransactionDTO initiateRefund(Long transactionId, BigDecimal amount, String reason);

    /**
     * Process timeout for pending payments (called by scheduler)
     */
    int processTimeoutPayments(int timeoutMinutes);

    /**
     * Capture authorized payment
     */
    PaymentTransactionDTO capturePayment(Long transactionId);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\ReceptionistService.java ==== 
package com.example.stayops.service;

import com.example.stayops.dto.ReceptionistRegisterDTO;
import com.example.stayops.dto.ReceptionistResponseDTO;
import com.example.stayops.entity.Receptionist;

import java.util.List;

public interface ReceptionistService {
    Receptionist registerReceptionist(ReceptionistRegisterDTO dto);
    List<ReceptionistResponseDTO> getAllReceptionists();
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\ReservationDetailsService.java ==== 
package com.example.stayops.service;

import com.example.stayops.dto.ReservationDetailsDTO;

public interface ReservationDetailsService {

    ReservationDetailsDTO saveReservationDetails(Long reservationId, ReservationDetailsDTO dto);

    ReservationDetailsDTO getReservationDetails(Long reservationId);

    ReservationDetailsDTO updateReservationDetails(Long reservationId, ReservationDetailsDTO dto);

    void deleteReservationDetails(Long reservationId);
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\ReservationHistoryService.java ==== 
package com.example.stayops.service;

import com.example.stayops.dto.ReservationHistoryDTO;

import java.util.List;

public interface ReservationHistoryService {
    ReservationHistoryDTO recordHistory(ReservationHistoryDTO dto);
    List<ReservationHistoryDTO> getHistoryByReservation(Long reservationId);
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\ReservationHoldService.java ==== 
package com.example.stayops.service;

import com.example.stayops.dto.ReservationHoldRequestDTO;
import com.example.stayops.dto.ReservationHoldResponseDTO;

import java.util.List;

public interface ReservationHoldService {

    /**
     * Create a new reservation hold with TTL
     */
    ReservationHoldResponseDTO createHold(ReservationHoldRequestDTO request);

    /**
     * Get hold by token
     */
    ReservationHoldResponseDTO getHoldByToken(String holdToken);

    /**
     * Convert hold to confirmed reservation
     */
    Long convertHoldToReservation(String holdToken);

    /**
     * Cancel/release a hold manually
     */
    void cancelHold(String holdToken);

    /**
     * Extend hold expiry time
     */
    ReservationHoldResponseDTO extendHold(String holdToken, Integer additionalMinutes);

    /**
     * Process expired holds (called by scheduler)
     */
    int processExpiredHolds();

    /**
     * Get active holds for a guest
     */
    List<ReservationHoldResponseDTO> getActiveHoldsByGuest(String guestId);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\ReservationService.java ==== 
package com.example.stayops.service;

import com.example.stayops.dto.*;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;

public interface ReservationService {

    // CRUD Operations
    ReservationResponseDTO createReservation(ReservationRequestDTO requestDTO);
    ReservationResponseDTO updateReservation(Long reservationId, ReservationRequestDTO requestDTO);
    void deleteReservation(Long reservationId);
    ReservationResponseDTO getReservationById(Long reservationId);
    List<ReservationResponseDTO> getAllReservations();

    // Calendar & Date-based
    List<ReservationSummaryDTO> getMonthlySummary(int year, int month);
    List<ReservationDayDetailDTO> getReservationsForDate(LocalDate date);
    List<ReservationResponseDTO> getReservationsInDateRange(LocalDate startDate, LocalDate endDate);

    // Room Status
    List<Map<String, Object>> getAllRoomReservationStatuses();
    List<RoomStatusDTO> getRoomStatusForDate(LocalDate date);
    Map<Long, List<RoomStatusDTO>> getRoomStatusForDateRange(LocalDate startDate, LocalDate endDate);

    // Arrivals & Departures
    List<ReservationResponseDTO> getArrivalsForDate(LocalDate date);
    List<ReservationResponseDTO> getDeparturesForDate(LocalDate date);
    DailyOperationsSummaryDTO getDailyOperationsSummary(LocalDate date);

    // Status Management
    ReservationResponseDTO updateReservationStatus(Long reservationId, String status);
    ReservationResponseDTO checkInReservation(Long reservationId);
    ReservationResponseDTO checkOutReservation(Long reservationId);
    ReservationResponseDTO cancelReservation(Long reservationId);

    // Guest & Search
    List<ReservationResponseDTO> getReservationsByGuestId(String guestId);
    List<ReservationResponseDTO> searchReservations(String guestId, String status,
                                                    LocalDate checkInDate, LocalDate checkOutDate);

    // Occupancy
    OccupancyStatsDTO getCurrentOccupancyStats();
    OccupancyStatsDTO getOccupancyStatsForDate(LocalDate date);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\RoomService.java ==== 
package com.example.stayops.service;

import com.example.stayops.dto.RoomDTO;
import java.util.List;

public interface RoomService {
    RoomDTO createRoom(RoomDTO roomDTO);
    RoomDTO updateRoom(Long id, RoomDTO roomDTO);
    void deleteRoom(Long id);
    RoomDTO getRoomById(Long id);
    List<RoomDTO> getAllRooms();
    List<RoomDTO> getAvailableRooms();
    List<RoomDTO> getRoomsByType(String type);
    List<RoomDTO> getRoomsByHotel(Long hotelId);
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\RoomStatusHistoryService.java ==== 
package com.example.stayops.service;

import com.example.stayops.dto.RoomStatusHistoryDTO;
import java.util.List;

public interface RoomStatusHistoryService {
    RoomStatusHistoryDTO createStatusChange(RoomStatusHistoryDTO dto);
    List<RoomStatusHistoryDTO> getHistoryByRoom(Long roomId);
    List<RoomStatusHistoryDTO> getAllHistory();
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\ServiceRequestService.java ==== 
package com.example.stayops.service;

import com.example.stayops.dto.ServiceRequestDTO;

import java.time.Instant;
import java.util.List;

public interface ServiceRequestService {

    /**
     * Create a new service request
     */
    ServiceRequestDTO createServiceRequest(ServiceRequestDTO dto);

    /**
     * Get service request by ID
     */
    ServiceRequestDTO getServiceRequestById(Long id);

    /**
     * Get all service requests
     */
    List<ServiceRequestDTO> getAllServiceRequests();

    /**
     * Update service request
     */
    ServiceRequestDTO updateServiceRequest(Long id, ServiceRequestDTO dto);

    /**
     * Delete service request
     */
    void deleteServiceRequest(Long id);

    /**
     * Get service requests by status
     */
    List<ServiceRequestDTO> getServiceRequestsByStatus(String status);

    /**
     * Get service requests by type
     */
    List<ServiceRequestDTO> getServiceRequestsByType(String serviceType);

    /**
     * Get service requests by priority
     */
    List<ServiceRequestDTO> getServiceRequestsByPriority(String priority);

    /**
     * Get service requests for a reservation
     */
    List<ServiceRequestDTO> getServiceRequestsByReservation(Long reservationId);

    /**
     * Get service requests for a room
     */
    List<ServiceRequestDTO> getServiceRequestsByRoom(Long roomId);

    /**
     * Get service requests assigned to a staff member
     */
    List<ServiceRequestDTO> getServiceRequestsByAssignedStaff(String staffId);

    /**
     * Get all pending requests
     */
    List<ServiceRequestDTO> getPendingRequests();

    /**
     * Get all urgent requests
     */
    List<ServiceRequestDTO> getUrgentRequests();

    /**
     * Assign service request to staff
     */
    ServiceRequestDTO assignToStaff(Long requestId, String staffId);

    /**
     * Update service request status
     */
    ServiceRequestDTO updateStatus(Long requestId, String status);

    /**
     * Mark service request as completed
     */
    ServiceRequestDTO markAsCompleted(Long requestId);

    /**
     * Get service requests by date range
     */
    List<ServiceRequestDTO> getServiceRequestsByDateRange(Instant startDate, Instant endDate);

    /**
     * Get incomplete service requests
     */
    List<ServiceRequestDTO> getIncompleteRequests();
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\ServiceTypeService.java ==== 
package com.example.stayops.service;

import com.example.stayops.dto.ServiceTypeDTO;

import java.util.List;

public interface ServiceTypeService {

    ServiceTypeDTO create(ServiceTypeDTO dto);

    ServiceTypeDTO getById(Long id);

    ServiceTypeDTO getByCode(String code);

    List<ServiceTypeDTO> getAll();

    ServiceTypeDTO update(Long id, ServiceTypeDTO dto);

    void delete(Long id);
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\StaffService.java ==== 
package com.example.stayops.service;

import com.example.stayops.dto.StaffRequestDTO;
import com.example.stayops.dto.StaffResponseDTO;

import java.util.List;

public interface StaffService {
    StaffResponseDTO createStaff(StaffRequestDTO dto);
    StaffResponseDTO updateStaff(String staffId, StaffRequestDTO dto);
    void deleteStaff(String staffId);
    StaffResponseDTO getStaffById(String staffId);
    List<StaffResponseDTO> getAllStaff();
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\AmenityServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.entity.Amenity;
import com.example.stayops.repository.AmenityRepository;
import com.example.stayops.service.AmenityService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class AmenityServiceImpl implements AmenityService {

    private final AmenityRepository amenityRepository;

    @Override
    @Transactional(readOnly = true)
    public List<Amenity> getAllAmenities() {
        return amenityRepository.findAll();
    }

    @Override
    @Transactional
    public Amenity addAmenity(Amenity amenity) {
        return amenityRepository.save(amenity);
    }

    @Override
    @Transactional
    public void deleteAmenity(Long id) {
        amenityRepository.deleteById(id);
    }

    @Override
    @Transactional(readOnly = true)
    public List<Amenity> getAmenitiesByHotelId(Long hotelId) {
        return amenityRepository.findAmenitiesByHotelId(hotelId);
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\AuthServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.dto.GuestResponseDTO;
import com.example.stayops.dto.LoginDTO;
import com.example.stayops.dto.LoginResponseDTO;
import com.example.stayops.entity.GuestAccount;
import com.example.stayops.repository.GuestAccountRepository;
import com.example.stayops.service.AuthService;
import com.example.stayops.service.GuestService;
import com.example.stayops.util.JwtUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class AuthServiceImpl implements AuthService {

    private final GuestAccountRepository guestAccountRepository;
    private final GuestService guestService;
    private final JwtUtil jwtUtil;
    private final PasswordEncoder passwordEncoder;

    @Override
    public LoginResponseDTO authenticateGuest(LoginDTO loginDTO) {
        log.info("Attempting to authenticate guest with email: {}", loginDTO.getEmail());

        try {
            // Manual authentication - no AuthenticationManager needed
            GuestAccount guestAccount = guestAccountRepository.findByEmail(loginDTO.getEmail())
                    .orElseThrow(() -> {
                        log.error("Guest account not found for email: {}", loginDTO.getEmail());
                        return new RuntimeException("Invalid email or password");
                    });

            log.info("Found guest account for email: {}, activated: {}",
                    loginDTO.getEmail(), guestAccount.isActivated());

            // Check if account is activated
            if (!guestAccount.isActivated()) {
                log.error("Account not activated for email: {}", loginDTO.getEmail());
                throw new RuntimeException("Account not activated. Please complete registration first.");
            }

            // Verify password manually
            if (!passwordEncoder.matches(loginDTO.getPassword(), guestAccount.getPassword())) {
                log.error("Password mismatch for email: {}", loginDTO.getEmail());
                throw new RuntimeException("Invalid email or password");
            }

            log.info("Authentication successful for email: {}", loginDTO.getEmail());

            // Generate JWT token
            String token = jwtUtil.generateToken(loginDTO.getEmail());

            // Get guest details
            GuestResponseDTO guestResponse = guestService.getGuestById(guestAccount.getGuest().getGuestId());

            return LoginResponseDTO.builder()
                    .token(token)
                    .tokenType("Bearer")
                    .expiresIn(jwtUtil.getExpirationTime())
                    .guest(guestResponse)
                    .build();

        } catch (Exception e) {
            log.error("Authentication failed for email: {} with error: {}", loginDTO.getEmail(), e.getMessage());
            throw new RuntimeException("Authentication failed: " + e.getMessage());
        }
    }

    @Override
    public boolean validateToken(String token) {
        try {
            String email = jwtUtil.extractEmail(token);
            return jwtUtil.validateToken(token, email);
        } catch (Exception e) {
            log.error("Token validation failed: {}", e.getMessage());
            return false;
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\DepartmentServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.entity.Department;
import com.example.stayops.repository.DepartmentRepository;
import com.example.stayops.service.DepartmentService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class DepartmentServiceImpl implements DepartmentService {

    private final DepartmentRepository departmentRepository;

    @Override
    @Transactional
    public Department createDepartment(Department department) {
        if (departmentRepository.existsByName(department.getName())) {
            throw new RuntimeException("Department with this name already exists!");
        }
        return departmentRepository.save(department);
    }

    @Override
    @Transactional
    public Department updateDepartment(Long id, Department department) {
        Department existing = departmentRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Department not found with id " + id));

        existing.setName(department.getName());
        existing.setDescription(department.getDescription());

        return departmentRepository.save(existing);
    }

    @Override
    @Transactional
    public void deleteDepartment(Long id) {
        if (!departmentRepository.existsById(id)) {
            throw new RuntimeException("Department not found with id " + id);
        }
        departmentRepository.deleteById(id);
    }

    @Override
    @Transactional(readOnly = true)
    public Department getDepartmentById(Long id) {
        return departmentRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Department not found with id " + id));
    }

    @Override
    @Transactional(readOnly = true)
    public List<Department> getAllDepartments() {
        return departmentRepository.findAll();
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\EmailServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.entity.EmailConfirmationToken;
import com.example.stayops.entity.Guest;
import com.example.stayops.repository.EmailConfirmationTokenRepository;
import com.example.stayops.service.EmailService;
import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.thymeleaf.TemplateEngine;
import org.thymeleaf.context.Context;

import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class EmailServiceImpl implements EmailService {

    private final JavaMailSender mailSender;
    private final TemplateEngine templateEngine;
    private final EmailConfirmationTokenRepository tokenRepository;

    @Value("${spring.mail.username}")
    private String fromEmail;

    @Value("${app.base-url}")
    private String baseUrl;

    @Value("${app.hotel-name}")
    private String hotelName;

    @Override
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void sendWelcomeEmailWithRegistrationLink(Guest guest) {
        try {
            log.info("Starting to send welcome email to guest: {}", guest.getEmail());

            // Generate unique token
            String token = UUID.randomUUID().toString();

            // Delete any existing tokens for this guest (cleanup)
            tokenRepository.deleteByGuestId(guest.getGuestId());

            // Save new token to database
            EmailConfirmationToken confirmationToken = new EmailConfirmationToken(
                    token, guest.getEmail(), guest.getGuestId()
            );
            tokenRepository.save(confirmationToken);
            log.debug("Created confirmation token for guest: {}", guest.getEmail());

            // Create email content
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");

            helper.setFrom(fromEmail);
            helper.setTo(guest.getEmail());
            helper.setSubject("Welcome to " + hotelName + " - Complete Your Mobile App Registration");

            // Create email content using Thymeleaf template
            Context context = new Context();
            context.setVariable("guestName", guest.getFirstName() + " " + guest.getLastName());
            context.setVariable("hotelName", hotelName);
            context.setVariable("registrationLink", baseUrl + "/registration?token=" + token);

            String htmlContent = templateEngine.process("welcome-email", context);
            helper.setText(htmlContent, true);

            // Attach QR code if available
            if (guest.getQrCodeImage() != null && guest.getQrCodeImage().length > 0) {
                ByteArrayResource qrCodeResource = new ByteArrayResource(guest.getQrCodeImage());
                helper.addAttachment("your-qr-code.png", qrCodeResource);
                log.debug("QR code attached to email for guest: {}", guest.getEmail());
            }

            mailSender.send(message);
            log.info("Welcome email sent successfully to: {}", guest.getEmail());

        } catch (MessagingException e) {
            log.error("Failed to send welcome email to: {} - {}", guest.getEmail(), e.getMessage(), e);
            // Don't throw exception - allow guest creation to succeed even if email fails
        } catch (Exception e) {
            log.error("Unexpected error while sending welcome email to: {} - {}", guest.getEmail(), e.getMessage(), e);
            // Don't throw exception - allow guest creation to succeed even if email fails
        }
    }

    @Override
    @Transactional(readOnly = true)
    public EmailConfirmationToken validateToken(String token) {
        log.debug("Validating token: {}", token);

        EmailConfirmationToken confirmationToken = tokenRepository.findByToken(token)
                .orElseThrow(() -> {
                    log.warn("Token not found: {}", token);
                    return new RuntimeException("Invalid token");
                });

        if (confirmationToken.isExpired()) {
            log.warn("Token expired: {} - expired at: {}", token, confirmationToken.getExpiresAt());
            throw new RuntimeException("Token has expired");
        }

        if (confirmationToken.isUsed()) {
            log.warn("Token already used: {}", token);
            throw new RuntimeException("Token has already been used");
        }

        log.debug("Token validation successful: {}", token);
        return confirmationToken;
    }

    @Override
    @Transactional
    public void markTokenAsUsed(String token) {
        log.debug("Marking token as used: {}", token);

        EmailConfirmationToken confirmationToken = tokenRepository.findByToken(token)
                .orElseThrow(() -> {
                    log.error("Token not found when marking as used: {}", token);
                    return new RuntimeException("Token not found");
                });

        confirmationToken.setUsed(true);
        tokenRepository.save(confirmationToken);

        log.info("Token marked as used successfully: {}", token);
    }

    @Override
    @Transactional(readOnly = true)
    public boolean hasValidTokenForEmail(String email) {
        return tokenRepository.findByEmailAndUsedFalse(email).isPresent();
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\GuestServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.cloudinary.Cloudinary;
import com.cloudinary.utils.ObjectUtils;
import com.example.stayops.dto.GuestCreateDTO;
import com.example.stayops.dto.GuestRegistrationDTO;
import com.example.stayops.dto.GuestResponseDTO;
import com.example.stayops.entity.Guest;
import com.example.stayops.entity.GuestAccount;
import com.example.stayops.repository.GuestAccountRepository;
import com.example.stayops.repository.GuestRepository;
import com.example.stayops.service.GuestService;
import com.example.stayops.util.ImageConverterUtil;
import com.example.stayops.util.QRCodeUtil;
import com.example.stayops.service.EmailService;
import com.example.stayops.entity.EmailConfirmationToken;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class GuestServiceImpl implements GuestService {

    private final GuestRepository guestRepository;
    private final GuestAccountRepository guestAccountRepository;
    private final Cloudinary cloudinary;
    private final PasswordEncoder passwordEncoder;

    @Autowired
    private EmailService emailService;

    @Override
    @Transactional
    public GuestResponseDTO createGuest(GuestCreateDTO dto, MultipartFile identityImage) {
        try {
            log.info("Creating guest with email: {}", dto.getEmail());

            if (guestRepository.findByEmail(dto.getEmail()).isPresent()) {
                log.warn("Guest already exists with email: {}", dto.getEmail());
                throw new RuntimeException("Guest already exists with this email");
            }

            String guestId = generateUniqueGuestId();
            log.debug("Generated unique guest ID: {}", guestId);

            String imageUrl = null;
            if (identityImage != null && !identityImage.isEmpty()) {
                imageUrl = uploadImageToCloudinary(identityImage);
            }

            // Generate QR code FIRST with just the guest ID
            byte[] qrCodeBytes = generateQRCode(guestId);
            log.debug("QR code generated, size: {} bytes", qrCodeBytes != null ? qrCodeBytes.length : 0);

            Guest guest = Guest.builder()
                    .guestId(guestId)
                    .firstName(dto.getFirstName())
                    .lastName(dto.getLastName())
                    .email(dto.getEmail())
                    .phone(dto.getPhone())
                    .nationality(dto.getNationality())
                    .identityType(dto.getIdentityType())
                    .identityNumber(dto.getIdentityNumber())
                    .imageUrl(imageUrl)
                    .qrCodeImage(qrCodeBytes)
                    .build();

            Guest savedGuest = guestRepository.save(guest);
            guestRepository.flush(); // Ensure data is written to database
            log.info("Guest created successfully with ID: {}, QR code size: {} bytes",
                    savedGuest.getGuestId(),
                    savedGuest.getQrCodeImage() != null ? savedGuest.getQrCodeImage().length : 0);

            // Send welcome email asynchronously in a separate transaction
            try {
                emailService.sendWelcomeEmailWithRegistrationLink(savedGuest);
                log.info("Welcome email initiated for guest: {}", savedGuest.getEmail());
            } catch (Exception e) {
                log.error("Failed to initiate welcome email for guest: {} - Error: {}",
                        savedGuest.getEmail(), e.getMessage());
            }

            return convertToResponseDTO(savedGuest);

        } catch (Exception e) {
            log.error("Error creating guest with email: {} - Error: {}", dto.getEmail(), e.getMessage(), e);
            throw new RuntimeException("Failed to create guest: " + e.getMessage(), e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public GuestResponseDTO getGuestByToken(String token) {
        try {
            log.debug("Getting guest info by token: {}", token);

            EmailConfirmationToken confirmationToken = emailService.validateToken(token);

            Guest guest = guestRepository.findByEmail(confirmationToken.getEmail())
                    .orElseThrow(() -> new RuntimeException("Guest not found"));

            return convertToResponseDTO(guest);

        } catch (Exception e) {
            log.error("Error getting guest by token: {} - Error: {}", token, e.getMessage(), e);
            throw new RuntimeException("Failed to get guest information: " + e.getMessage(), e);
        }
    }

    @Override
    @Transactional
    public GuestAccount registerGuestFromWeb(GuestRegistrationDTO dto, String token) {
        try {
            log.info("Starting web registration for email: {}", dto.getEmail());

            EmailConfirmationToken confirmationToken = emailService.validateToken(token);

            if (!confirmationToken.getEmail().equals(dto.getEmail())) {
                log.warn("Email mismatch in token validation. Token email: {}, DTO email: {}",
                        confirmationToken.getEmail(), dto.getEmail());
                throw new RuntimeException("Email mismatch");
            }

            Guest guest = guestRepository.findByEmail(dto.getEmail())
                    .orElseThrow(() -> {
                        log.error("Guest not found for email: {}", dto.getEmail());
                        return new RuntimeException("Guest not found with email: " + dto.getEmail());
                    });

            Optional<GuestAccount> existingAccount = guestAccountRepository.findByEmail(dto.getEmail());
            if (existingAccount.isPresent()) {
                log.warn("Account already exists for email: {}", dto.getEmail());
                throw new RuntimeException("Account already exists for this email");
            }

            GuestAccount guestAccount = GuestAccount.builder()
                    .guest(guest)
                    .email(dto.getEmail())
                    .password(passwordEncoder.encode(dto.getPassword()))
                    .activated(true)
                    .build();

            GuestAccount savedAccount = guestAccountRepository.save(guestAccount);
            log.info("Guest account created successfully for email: {}", dto.getEmail());

            emailService.markTokenAsUsed(token);

            return savedAccount;

        } catch (Exception e) {
            log.error("Error during web registration for email: {} - Error: {}",
                    dto.getEmail(), e.getMessage(), e);
            throw new RuntimeException("Registration failed: " + e.getMessage(), e);
        }
    }

    @Override
    @Transactional
    public GuestAccount registerGuestFromMobile(GuestRegistrationDTO dto) {
        try {
            log.info("Starting mobile registration for email: {}", dto.getEmail());

            Optional<Guest> guestOptional = guestRepository.findByEmail(dto.getEmail());
            if (!guestOptional.isPresent()) {
                log.error("Guest not found for mobile registration with email: {}", dto.getEmail());
                throw new RuntimeException("Guest not found with email: " + dto.getEmail());
            }

            Guest guest = guestOptional.get();

            Optional<GuestAccount> existingAccount = guestAccountRepository.findByEmail(dto.getEmail());
            if (existingAccount.isPresent()) {
                log.warn("Account already exists for mobile registration with email: {}", dto.getEmail());
                throw new RuntimeException("Account already exists for this email");
            }

            GuestAccount guestAccount = GuestAccount.builder()
                    .guest(guest)
                    .email(dto.getEmail())
                    .password(passwordEncoder.encode(dto.getPassword()))
                    .activated(false)
                    .build();

            GuestAccount savedAccount = guestAccountRepository.save(guestAccount);
            log.info("Mobile guest account created successfully for email: {}", dto.getEmail());

            return savedAccount;

        } catch (Exception e) {
            log.error("Error during mobile registration for email: {} - Error: {}",
                    dto.getEmail(), e.getMessage(), e);
            throw new RuntimeException("Mobile registration failed: " + e.getMessage(), e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public GuestResponseDTO getGuestById(String guestId) {
        Guest guest = guestRepository.findById(guestId)
                .orElseThrow(() -> new RuntimeException("Guest not found"));
        return toResponseDTO(guest);
    }

    @Override
    @Transactional(readOnly = true)
    public List<GuestResponseDTO> getAllGuests() {
        return guestRepository.findAll()
                .stream()
                .map(this::toResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public String getGuestQrCodeDataUrl(String guestId) {
        Guest guest = guestRepository.findById(guestId)
                .orElseThrow(() -> new RuntimeException("Guest not found"));

        if (guest.getQrCodeImage() == null || guest.getQrCodeImage().length == 0) {
            log.warn("No QR code found for guest: {}", guestId);
            return null;
        }

        return ImageConverterUtil.bytesToBase64DataUrl(guest.getQrCodeImage());
    }

    private String generateUniqueGuestId() {
        String guestId;
        do {
            guestId = "GUEST" + String.format("%06d", new Random().nextInt(999999));
        } while (guestRepository.findById(guestId).isPresent());

        return guestId;
    }

    private String uploadImageToCloudinary(MultipartFile file) {
        try {
            log.debug("Uploading image to Cloudinary: {}", file.getOriginalFilename());

            Map<String, Object> uploadResult = cloudinary.uploader().upload(file.getBytes(),
                    ObjectUtils.asMap(
                            "resource_type", "image",
                            "folder", "guest_identity_images",
                            "use_filename", true,
                            "unique_filename", true
                    ));

            String imageUrl = uploadResult.get("secure_url").toString();
            log.debug("Image uploaded successfully to Cloudinary: {}", imageUrl);

            return imageUrl;

        } catch (Exception e) {
            log.error("Failed to upload image to Cloudinary: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to upload image: " + e.getMessage(), e);
        }
    }

    private byte[] generateQRCode(String guestId) {
        try {
            log.debug("Generating QR code for guest: {}", guestId);

            // Use only the guest ID without any prefix for maximum compatibility
            String qrContent = guestId;
            byte[] qrCodeBytes = QRCodeUtil.generateQRCodeImage(qrContent, 300, 300);

            log.debug("QR code generated successfully for guest: {}, size: {} bytes", guestId, qrCodeBytes.length);
            return qrCodeBytes;

        } catch (Exception e) {
            log.error("Failed to generate QR code for guest: {} - Error: {}", guestId, e.getMessage(), e);
            throw new RuntimeException("Failed to generate QR code: " + e.getMessage(), e);
        }
    }

    private GuestResponseDTO convertToResponseDTO(Guest guest) {
        String qrCodeBase64 = null;
        if (guest.getQrCodeImage() != null) {
            qrCodeBase64 = Base64.getEncoder().encodeToString(guest.getQrCodeImage());
        }

        return GuestResponseDTO.builder()
                .guestId(guest.getGuestId())
                .fullName(guest.getFirstName() + " " + guest.getLastName())
                .email(guest.getEmail())
                .phone(guest.getPhone())
                .nationality(guest.getNationality())
                .identityType(guest.getIdentityType())
                .identityNumber(guest.getIdentityNumber())
                .qrCodeBase64(qrCodeBase64)
                .imageUrl(guest.getImageUrl())
                .build();
    }

    private GuestResponseDTO toResponseDTO(Guest guest) {
        String rawBase64 = null;
        if (guest.getQrCodeImage() != null && guest.getQrCodeImage().length > 0) {
            rawBase64 = Base64.getEncoder().encodeToString(guest.getQrCodeImage());
        }

        String dataUrl = null;
        if (guest.getQrCodeImage() != null && guest.getQrCodeImage().length > 0) {
            try {
                dataUrl = ImageConverterUtil.bytesToBase64DataUrl(guest.getQrCodeImage());
            } catch (Exception e) {
                dataUrl = (rawBase64 != null) ? ("data:image/png;base64," + rawBase64) : null;
            }
        }

        return GuestResponseDTO.builder()
                .guestId(guest.getGuestId())
                .fullName(guest.getFirstName() + " " + guest.getLastName())
                .email(guest.getEmail())
                .phone(guest.getPhone())
                .nationality(guest.getNationality())
                .identityType(guest.getIdentityType())
                .identityNumber(guest.getIdentityNumber())
                .imageUrl(guest.getImageUrl())
                .qrCodeBase64(dataUrl)
                .build();
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\GuestUserDetailsService.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.entity.GuestAccount;
import com.example.stayops.repository.GuestAccountRepository;
import com.example.stayops.security.GuestUserDetails;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@Slf4j
public class GuestUserDetailsService implements UserDetailsService {

    private final GuestAccountRepository guestAccountRepository;

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        log.debug("Attempting to load user with email: {}", email);

        GuestAccount guestAccount = guestAccountRepository.findByEmail(email)
                .orElseThrow(() -> {
                    log.error("Guest account not found for email: {}", email);
                    return new UsernameNotFoundException("Guest account not found with email: " + email);
                });

        log.debug("Found guest account for email: {}, activated: {}", email, guestAccount.isActivated());

        return new GuestUserDetails(guestAccount);
    }

    public boolean existsByEmail(String email) {
        return guestAccountRepository.findByEmail(email).isPresent();
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\HotelServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.entity.Hotel;
import com.example.stayops.repository.HotelRepository;
import com.example.stayops.service.HotelService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class HotelServiceImpl implements HotelService {

    private final HotelRepository hotelRepository;

    @Override
    @Transactional
    public Hotel createHotel(Hotel hotel){
        return hotelRepository.save(hotel);
    }

    @Override
    @Transactional
    public Hotel updateHotel(Long hotelId, Hotel hotel){
        return hotelRepository.findById(hotelId)
                .map(existing -> {
                    existing.setName(hotel.getName());
                    existing.setAddress(hotel.getAddress());
                    existing.setPhone(hotel.getPhone());
                    existing.setEmail(hotel.getEmail());
                    existing.setDescription(hotel.getDescription());
                    return hotelRepository.save(existing);
                })
                .orElseThrow(() -> new RuntimeException("Hotel not found with id " + hotelId));
    }

    @Override
    @Transactional
    public void deleteHotel(Long hotelId){
        hotelRepository.deleteById(hotelId);
    }

    @Override
    @Transactional(readOnly = true)
    public Hotel getHotelById(Long hotelId){
        return hotelRepository.findById(hotelId)
                .orElseThrow(() -> new RuntimeException("Hotel not found with id " + hotelId));
    }

    @Override
    @Transactional(readOnly = true)
    public List<Hotel> getAllHotels(){
        return hotelRepository.findAll();
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\LoyaltyPointsServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.dto.LoyaltyPointsDTO;
import com.example.stayops.entity.Guest;
import com.example.stayops.entity.LoyaltyPoints;
import com.example.stayops.repository.GuestRepository;
import com.example.stayops.repository.LoyaltyPointsRepository;
import com.example.stayops.service.LoyaltyPointsService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class LoyaltyPointsServiceImpl implements LoyaltyPointsService {

    private final LoyaltyPointsRepository loyaltyPointsRepository;
    private final GuestRepository guestRepository;

    @Override
    public LoyaltyPointsDTO createOrUpdate(LoyaltyPointsDTO dto) {
        Guest guest = guestRepository.findById(dto.getGuestId())
                .orElseThrow(() -> new RuntimeException("Guest not found"));

        LoyaltyPoints loyaltyPoints = loyaltyPointsRepository.findByGuestGuestId(dto.getGuestId())
                .orElse(LoyaltyPoints.builder()
                        .guest(guest)
                        .build());

        loyaltyPoints.setPoints(dto.getPoints());
        loyaltyPoints.setMembershipLevel(dto.getMembershipLevel());

        LoyaltyPoints saved = loyaltyPointsRepository.save(loyaltyPoints);

        return new LoyaltyPointsDTO(saved.getId(),
                saved.getGuest().getGuestId(),
                saved.getPoints(),
                saved.getMembershipLevel());
    }

    @Override
    public LoyaltyPointsDTO getByGuestId(String guestId) {
        LoyaltyPoints lp = loyaltyPointsRepository.findByGuestGuestId(guestId)
                .orElseThrow(() -> new RuntimeException("Loyalty record not found"));
        return new LoyaltyPointsDTO(lp.getId(), lp.getGuest().getGuestId(), lp.getPoints(), lp.getMembershipLevel());
    }

    @Override
    public List<LoyaltyPointsDTO> getAll() {
        return loyaltyPointsRepository.findAll()
                .stream()
                .map(lp -> new LoyaltyPointsDTO(lp.getId(), lp.getGuest().getGuestId(), lp.getPoints(), lp.getMembershipLevel()))
                .collect(Collectors.toList());
    }

    @Override
    public void delete(Long id) {
        loyaltyPointsRepository.deleteById(id);
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\PaymentServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.dto.PaymentTransactionDTO;
import com.example.stayops.entity.PaymentTransaction;
import com.example.stayops.entity.Reservation;
import com.example.stayops.enums.PaymentStatus;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.event.EventPublisher;
import com.example.stayops.event.PaymentEvent;
import com.example.stayops.repository.PaymentTransactionRepository;
import com.example.stayops.repository.ReservationRepository;
import com.example.stayops.service.PaymentService;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.math.BigDecimal;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.time.Instant;
import java.util.Base64;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class PaymentServiceImpl implements PaymentService {

    private final PaymentTransactionRepository paymentRepository;
    private final ReservationRepository reservationRepository;
    private final EventPublisher eventPublisher;
    private final ObjectMapper objectMapper;

    @Override
    @Transactional
    public PaymentTransactionDTO initiatePayment(PaymentTransactionDTO request) {
        log.info("Initiating payment for reservation: {}", request.getReservationId());

        // Check idempotency
        if (request.getIdempotencyKey() != null) {
            var existing = paymentRepository.findByIdempotencyKey(request.getIdempotencyKey());
            if (existing.isPresent()) {
                log.info("Returning existing payment for idempotency key: {}", request.getIdempotencyKey());
                return mapToDTO(existing.get());
            }
        }

        // Generate idempotency key if not provided
        String idempotencyKey = request.getIdempotencyKey() != null
                ? request.getIdempotencyKey()
                : UUID.randomUUID().toString();

        // Fetch reservation
        Reservation reservation = reservationRepository.findById(request.getReservationId())
                .orElseThrow(() -> new EntityNotFoundException("Reservation not found: " + request.getReservationId()));

        // Create payment transaction
        PaymentTransaction payment = PaymentTransaction.builder()
                .reservation(reservation)
                .idempotencyKey(idempotencyKey)
                .paymentIntentId(request.getPaymentIntentId())
                .status(PaymentStatus.PENDING)
                .paymentMethod(request.getPaymentMethod())
                .amount(request.getAmount())
                .currency(request.getCurrency())
                .cardToken(request.getCardToken())
                .notes(request.getNotes())
                .isRefund(false)
                .build();

        PaymentTransaction saved = paymentRepository.save(payment);

        log.info("Payment initiated with ID: {} for reservation: {}",
                saved.getId(), request.getReservationId());

        return mapToDTO(saved);
    }

    @Override
    @Transactional
    public PaymentTransactionDTO processWebhook(String webhookPayload, String signature) {
        log.info("Processing payment webhook");

        // Validate webhook signature
        if (!validateWebhookSignature(webhookPayload, signature)) {
            log.error("Invalid webhook signature");
            throw new SecurityException("Invalid webhook signature");
        }

        try {
            // Parse webhook payload
            JsonNode payloadNode = objectMapper.readTree(webhookPayload);

            String transactionId = payloadNode.path("transaction_id").asText();
            String status = payloadNode.path("status").asText();
            String failureReason = payloadNode.path("failure_reason").asText(null);

            PaymentTransaction payment = paymentRepository
                    .findByProviderTransactionId(transactionId)
                    .orElseThrow(() -> new EntityNotFoundException(
                            "Payment not found: " + transactionId));

            PaymentStatus oldStatus = payment.getStatus();

            // Update payment status based on webhook
            switch (status.toLowerCase()) {
                case "succeeded":
                case "captured":
                    payment.setStatus(PaymentStatus.CAPTURED);
                    payment.setProcessedAt(Instant.now());
                    payment.setProcessedBy("WEBHOOK");
                    break;
                case "authorized":
                    payment.setStatus(PaymentStatus.AUTHORIZED);
                    break;
                case "failed":
                    payment.setStatus(PaymentStatus.FAILED);
                    payment.setFailureReason(failureReason);
                    break;
                case "refunded":
                    payment.setStatus(PaymentStatus.REFUNDED);
                    break;
                default:
                    log.warn("Unknown payment status: {}", status);
                    payment.setStatus(PaymentStatus.PENDING);
            }

            payment.setWebhookPayload(webhookPayload);
            PaymentTransaction saved = paymentRepository.save(payment);

            // Publish payment event for other automations
            String eventType = saved.getStatus() == PaymentStatus.CAPTURED ? "SUCCESS" :
                    saved.getStatus() == PaymentStatus.FAILED ? "FAILED" :
                            saved.getStatus() == PaymentStatus.AUTHORIZED ? "AUTHORIZED" : "UPDATED";

            eventPublisher.publishPaymentEvent(PaymentEvent.builder()
                    .paymentId(saved.getId())
                    .reservationId(saved.getReservation().getReservationId())
                    .status(saved.getStatus())
                    .amount(saved.getAmount())
                    .eventType(eventType)
                    .eventTime(Instant.now())
                    .providerTransactionId(saved.getProviderTransactionId())
                    .build());

            log.info("Payment webhook processed: {} -> {} for transaction {}",
                    oldStatus, saved.getStatus(), transactionId);

            return mapToDTO(saved);

        } catch (Exception e) {
            log.error("Error processing webhook: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to process webhook", e);
        }
    }

    private boolean validateWebhookSignature(String payload, String signature) {
        try {
            // Use a webhook secret from configuration
            String webhookSecret = "your-webhook-secret"; // TODO: Move to config

            Mac mac = Mac.getInstance("HmacSHA256");
            SecretKeySpec secretKeySpec = new SecretKeySpec(
                    webhookSecret.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
            mac.init(secretKeySpec);

            byte[] hash = mac.doFinal(payload.getBytes(StandardCharsets.UTF_8));
            String calculatedSignature = Base64.getEncoder().encodeToString(hash);

            return calculatedSignature.equals(signature);
        } catch (Exception e) {
            log.error("Error validating webhook signature: {}", e.getMessage());
            return false;
        }
    }

    @Override
    @Transactional(readOnly = true)
    public PaymentTransactionDTO getByIdempotencyKey(String idempotencyKey) {
        PaymentTransaction payment = paymentRepository.findByIdempotencyKey(idempotencyKey)
                .orElseThrow(() -> new EntityNotFoundException("Payment not found for key: " + idempotencyKey));
        return mapToDTO(payment);
    }

    @Override
    @Transactional(readOnly = true)
    public List<PaymentTransactionDTO> getPaymentsByReservation(Long reservationId) {
        return paymentRepository.findByReservationReservationId(reservationId).stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public PaymentTransactionDTO initiateRefund(Long transactionId, BigDecimal amount, String reason) {
        log.info("Initiating refund for transaction: {}", transactionId);

        PaymentTransaction originalPayment = paymentRepository.findById(transactionId)
                .orElseThrow(() -> new EntityNotFoundException("Payment not found: " + transactionId));

        if (originalPayment.getStatus() != PaymentStatus.CAPTURED) {
            throw new IllegalStateException("Can only refund captured payments");
        }

        // Create refund transaction
        PaymentTransaction refund = PaymentTransaction.builder()
                .reservation(originalPayment.getReservation())
                .idempotencyKey(UUID.randomUUID().toString())
                .status(PaymentStatus.PENDING)
                .paymentMethod(originalPayment.getPaymentMethod())
                .amount(amount)
                .currency(originalPayment.getCurrency())
                .isRefund(true)
                .refundOfTransaction(originalPayment)
                .notes(reason)
                .build();

        PaymentTransaction saved = paymentRepository.save(refund);

        // Update original payment's refunded amount
        BigDecimal currentRefunded = originalPayment.getRefundedAmount() != null
                ? originalPayment.getRefundedAmount()
                : BigDecimal.ZERO;
        originalPayment.setRefundedAmount(currentRefunded.add(amount));

        if (originalPayment.getRefundedAmount().compareTo(originalPayment.getAmount()) >= 0) {
            originalPayment.setStatus(PaymentStatus.REFUNDED);
        } else {
            originalPayment.setStatus(PaymentStatus.PARTIALLY_REFUNDED);
        }

        paymentRepository.save(originalPayment);

        // Publish refund event
        eventPublisher.publishPaymentEvent(PaymentEvent.builder()
                .paymentId(saved.getId())
                .reservationId(saved.getReservation().getReservationId())
                .status(saved.getStatus())
                .amount(saved.getAmount())
                .eventType("REFUNDED")
                .eventTime(Instant.now())
                .build());

        log.info("Refund initiated with ID: {}", saved.getId());
        return mapToDTO(saved);
    }

    @Override
    @Transactional
    public int processTimeoutPayments(int timeoutMinutes) {
        log.info("Processing timeout payments (timeout: {} minutes)", timeoutMinutes);

        Instant threshold = Instant.now().minus(Duration.ofMinutes(timeoutMinutes));
        List<PaymentTransaction> timedOutPayments = paymentRepository.findPendingPaymentsOlderThan(threshold);

        for (PaymentTransaction payment : timedOutPayments) {
            payment.setStatus(PaymentStatus.TIMEOUT);
            payment.setFailureReason("Payment timed out after " + timeoutMinutes + " minutes");

            eventPublisher.publishPaymentEvent(PaymentEvent.builder()
                    .paymentId(payment.getId())
                    .reservationId(payment.getReservation().getReservationId())
                    .status(PaymentStatus.TIMEOUT)
                    .amount(payment.getAmount())
                    .eventType("FAILED")
                    .eventTime(Instant.now())
                    .build());

            log.info("Payment {} timed out", payment.getId());
        }

        paymentRepository.saveAll(timedOutPayments);

        log.info("Processed {} timeout payments", timedOutPayments.size());
        return timedOutPayments.size();
    }

    @Override
    @Transactional
    public PaymentTransactionDTO capturePayment(Long transactionId) {
        log.info("Capturing payment: {}", transactionId);

        PaymentTransaction payment = paymentRepository.findById(transactionId)
                .orElseThrow(() -> new EntityNotFoundException("Payment not found: " + transactionId));

        if (payment.getStatus() != PaymentStatus.AUTHORIZED) {
            throw new IllegalStateException("Can only capture authorized payments");
        }

        payment.setStatus(PaymentStatus.CAPTURED);
        payment.setProcessedAt(Instant.now());
        payment.setProcessedBy("System");

        PaymentTransaction saved = paymentRepository.save(payment);

        // Publish success event
        eventPublisher.publishPaymentEvent(PaymentEvent.builder()
                .paymentId(saved.getId())
                .reservationId(saved.getReservation().getReservationId())
                .status(PaymentStatus.CAPTURED)
                .amount(saved.getAmount())
                .eventType("SUCCESS")
                .eventTime(Instant.now())
                .providerTransactionId(saved.getProviderTransactionId())
                .build());

        log.info("Payment {} captured successfully", transactionId);
        return mapToDTO(saved);
    }

    private PaymentTransactionDTO mapToDTO(PaymentTransaction entity) {
        return PaymentTransactionDTO.builder()
                .id(entity.getId())
                .reservationId(entity.getReservation() != null ? entity.getReservation().getReservationId() : null)
                .idempotencyKey(entity.getIdempotencyKey())
                .providerTransactionId(entity.getProviderTransactionId())
                .paymentIntentId(entity.getPaymentIntentId())
                .status(entity.getStatus())
                .paymentMethod(entity.getPaymentMethod())
                .amount(entity.getAmount())
                .currency(entity.getCurrency())
                .cardLast4(entity.getCardLast4())
                .cardBrand(entity.getCardBrand())
                .cardToken(entity.getCardToken())
                .failureReason(entity.getFailureReason())
                .processedAt(entity.getProcessedAt())
                .processedBy(entity.getProcessedBy())
                .notes(entity.getNotes())
                .isRefund(entity.getIsRefund())
                .refundOfTransactionId(entity.getRefundOfTransaction() != null ? entity.getRefundOfTransaction().getId() : null)
                .refundedAmount(entity.getRefundedAmount())
                .createdAt(entity.getCreatedAt())
                .updatedAt(entity.getUpdatedAt())
                .build();
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\ReceptionistServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.dto.ReceptionistRegisterDTO;
import com.example.stayops.dto.ReceptionistResponseDTO;
import com.example.stayops.entity.Receptionist;
import com.example.stayops.repository.ReceptionistRepository;
import com.example.stayops.service.ReceptionistService;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ReceptionistServiceImpl implements ReceptionistService {

    private final ReceptionistRepository repository;
    private final PasswordEncoder passwordEncoder;

    @Override
    public Receptionist registerReceptionist(ReceptionistRegisterDTO dto) {
        Receptionist receptionist = new Receptionist();
        receptionist.setUsername(dto.getUsername());
        receptionist.setPassword(passwordEncoder.encode(dto.getPassword()));
        receptionist.setFullName(dto.getFullName());
        receptionist.setEmail(dto.getEmail());
        receptionist.setPhone(dto.getPhone());
        return repository.save(receptionist);
    }

    @Override
    public List<ReceptionistResponseDTO> getAllReceptionists() {
        return repository.findAll().stream()
                .map(r -> {
                    ReceptionistResponseDTO dto = new ReceptionistResponseDTO();
                    dto.setId(r.getId());
                    dto.setUsername(r.getUsername());
                    dto.setFullName(r.getFullName());
                    dto.setEmail(r.getEmail());
                    dto.setPhone(r.getPhone());
                    return dto;
                })
                .collect(Collectors.toList());
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\ReservationDetailsServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.dto.ReservationDetailsDTO;
import com.example.stayops.entity.Reservation;
import com.example.stayops.entity.ReservationDetails;
import com.example.stayops.repository.ReservationDetailsRepository;
import com.example.stayops.repository.ReservationRepository;
import com.example.stayops.service.ReservationDetailsService;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Slf4j
@Service
@RequiredArgsConstructor
public class ReservationDetailsServiceImpl implements ReservationDetailsService {

    private final ReservationDetailsRepository reservationDetailsRepository;
    private final ReservationRepository reservationRepository;

    @Override
    @Transactional
    public ReservationDetailsDTO saveReservationDetails(Long reservationId, ReservationDetailsDTO dto) {
        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new EntityNotFoundException("Reservation not found: " + reservationId));

        ReservationDetails existingDetails = reservationDetailsRepository.findById(reservationId).orElse(null);

        ReservationDetails details;

        if (existingDetails != null) {
            details = existingDetails;
        } else {
            details = new ReservationDetails();
            details.setReservationId(reservationId);  // Set the ID explicitly
            details.setReservation(reservation);
        }

        details.setAdults(dto.getAdults() != null ? dto.getAdults() : 1);
        details.setKids(dto.getKids() != null ? dto.getKids() : 0);
        details.setMealPlan(dto.getMealPlan());
        details.setAmenities(dto.getAmenities());
        details.setSpecialRequests(dto.getSpecialRequests());
        details.setAdditionalNotes(dto.getAdditionalNotes());

        ReservationDetails saved = reservationDetailsRepository.save(details);

        return mapToDTO(saved);
    }

    @Override
    @Transactional(readOnly = true)
    public ReservationDetailsDTO getReservationDetails(Long reservationId) {
        ReservationDetails details = reservationDetailsRepository.findById(reservationId)
                .orElseThrow(() -> new EntityNotFoundException(
                        "Reservation details not found for reservation: " + reservationId));

        return mapToDTO(details);
    }

    @Override
    @Transactional
    public ReservationDetailsDTO updateReservationDetails(Long reservationId, ReservationDetailsDTO dto) {
        ReservationDetails details = reservationDetailsRepository.findById(reservationId)
                .orElseThrow(() -> new EntityNotFoundException(
                        "Reservation details not found for reservation: " + reservationId));

        details.setAdults(dto.getAdults() != null ? dto.getAdults() : details.getAdults());
        details.setKids(dto.getKids() != null ? dto.getKids() : details.getKids());
        details.setMealPlan(dto.getMealPlan() != null ? dto.getMealPlan() : details.getMealPlan());
        details.setAmenities(dto.getAmenities() != null ? dto.getAmenities() : details.getAmenities());
        details.setSpecialRequests(dto.getSpecialRequests() != null ? dto.getSpecialRequests() : details.getSpecialRequests());
        details.setAdditionalNotes(dto.getAdditionalNotes() != null ? dto.getAdditionalNotes() : details.getAdditionalNotes());

        ReservationDetails saved = reservationDetailsRepository.save(details);

        return mapToDTO(saved);
    }

    @Override
    @Transactional
    public void deleteReservationDetails(Long reservationId) {
        if (reservationDetailsRepository.existsById(reservationId)) {
            reservationDetailsRepository.deleteById(reservationId);
        }
    }

    private ReservationDetailsDTO mapToDTO(ReservationDetails details) {
        return ReservationDetailsDTO.builder()
                .id(details.getReservationId())  // Use reservationId as the id in DTO
                .reservationId(details.getReservationId())
                .adults(details.getAdults())
                .kids(details.getKids())
                .mealPlan(details.getMealPlan())
                .amenities(details.getAmenities())
                .specialRequests(details.getSpecialRequests())
                .additionalNotes(details.getAdditionalNotes())
                .build();
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\ReservationHistoryServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.dto.ReservationHistoryDTO;
import com.example.stayops.entity.Reservation;
import com.example.stayops.entity.ReservationHistory;
import com.example.stayops.repository.ReservationHistoryRepository;
import com.example.stayops.repository.ReservationRepository;
import com.example.stayops.service.ReservationHistoryService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ReservationHistoryServiceImpl implements ReservationHistoryService {

    private final ReservationHistoryRepository historyRepository;
    private final ReservationRepository reservationRepository;

    @Override
    public ReservationHistoryDTO recordHistory(ReservationHistoryDTO dto) {
        Reservation reservation = reservationRepository.findById(dto.getReservationId())
                .orElseThrow(() -> new RuntimeException("Reservation not found"));

        ReservationHistory history = ReservationHistory.builder()
                .reservation(reservation)
                .previousStatus(dto.getPreviousStatus())
                .newStatus(dto.getNewStatus())
                .changedBy(dto.getChangedBy())
                .notes(dto.getNotes())
                .build();

        return toDTO(historyRepository.save(history));
    }

    @Override
    public List<ReservationHistoryDTO> getHistoryByReservation(Long reservationId) {
        return historyRepository.findByReservation_ReservationId(reservationId)
                .stream().map(this::toDTO).collect(Collectors.toList());
    }

    private ReservationHistoryDTO toDTO(ReservationHistory entity) {
        return ReservationHistoryDTO.builder()
                .historyId(entity.getHistoryId())
                .reservationId(entity.getReservation().getReservationId())
                .previousStatus(entity.getPreviousStatus())
                .newStatus(entity.getNewStatus())
                .changedBy(entity.getChangedBy())
                .notes(entity.getNotes())
                .changedAt(entity.getChangedAt())
                .build();
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\ReservationHoldServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.dto.ReservationHoldRequestDTO;
import com.example.stayops.dto.ReservationHoldResponseDTO;
import com.example.stayops.dto.ReservationRequestDTO;
import com.example.stayops.entity.Guest;
import com.example.stayops.entity.ReservationHold;
import com.example.stayops.entity.Room;
import com.example.stayops.enums.HoldStatus;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.repository.GuestRepository;
import com.example.stayops.repository.ReservationHoldRepository;
import com.example.stayops.repository.ReservationRepository;
import com.example.stayops.repository.RoomRepository;
import com.example.stayops.service.ReservationHoldService;
import com.example.stayops.service.ReservationService;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class ReservationHoldServiceImpl implements ReservationHoldService {

    private final ReservationHoldRepository holdRepository;
    private final RoomRepository roomRepository;
    private final GuestRepository guestRepository;
    private final ReservationRepository reservationRepository;
    private final ReservationService reservationService;

    private static final int DEFAULT_TTL_MINUTES = 15;

    @Override
    @Transactional
    public ReservationHoldResponseDTO createHold(ReservationHoldRequestDTO request) {
        log.info("Creating reservation hold for guest: {}", request.getGuestId());

        // Validate request
        if (request.getCheckInDate() == null || request.getCheckOutDate() == null) {
            throw new IllegalArgumentException("Check-in and check-out dates are required");
        }
        if (request.getCheckOutDate().isBefore(request.getCheckInDate()) ||
                request.getCheckOutDate().equals(request.getCheckInDate())) {
            throw new IllegalArgumentException("Check-out date must be after check-in date");
        }

        // Fetch guest if provided
        Guest guest = null;
        if (request.getGuestId() != null) {
            guest = guestRepository.findById(request.getGuestId())
                    .orElseThrow(() -> new EntityNotFoundException("Guest not found: " + request.getGuestId()));
        }

        // Fetch and validate rooms
        Set<Room> rooms = new HashSet<>();
        if (request.getRoomIds() != null && !request.getRoomIds().isEmpty()) {
            List<Room> roomList = roomRepository.findAllById(request.getRoomIds());
            if (roomList.size() != request.getRoomIds().size()) {
                throw new EntityNotFoundException("Some rooms not found");
            }

            // Check room availability (considering existing holds and reservations)
            for (Room room : roomList) {
                if (!isRoomAvailable(room.getId(), request.getCheckInDate(), request.getCheckOutDate())) {
                    throw new IllegalStateException("Room " + room.getRoomNumber() +
                            " is not available for the selected dates");
                }
            }
            rooms.addAll(roomList);
        }

        // Generate hold token (idempotency key)
        String holdToken = UUID.randomUUID().toString();

        // Calculate expiry time
        int ttlMinutes = request.getTtlMinutes() != null ? request.getTtlMinutes() : DEFAULT_TTL_MINUTES;
        Instant expiresAt = Instant.now().plus(Duration.ofMinutes(ttlMinutes));

        // Create hold
        ReservationHold hold = ReservationHold.builder()
                .holdToken(holdToken)
                .sessionId(request.getSessionId())
                .guest(guest)
                .rooms(rooms)
                .checkInDate(request.getCheckInDate())
                .checkOutDate(request.getCheckOutDate())
                .status(HoldStatus.ACTIVE)
                .expiresAt(expiresAt)
                .roomType(request.getRoomType())
                .numberOfRooms(request.getNumberOfRooms())
                .numberOfGuests(request.getNumberOfGuests())
                .notes(request.getNotes())
                .build();

        ReservationHold savedHold = holdRepository.save(hold);

        log.info("Hold created successfully with token: {} (expires at: {})", holdToken, expiresAt);

        return mapToResponseDTO(savedHold);
    }

    @Override
    @Transactional(readOnly = true)
    public ReservationHoldResponseDTO getHoldByToken(String holdToken) {
        ReservationHold hold = holdRepository.findByHoldToken(holdToken)
                .orElseThrow(() -> new EntityNotFoundException("Hold not found: " + holdToken));
        return mapToResponseDTO(hold);
    }

    @Override
    @Transactional
    public Long convertHoldToReservation(String holdToken) {
        log.info("Converting hold to reservation: {}", holdToken);

        ReservationHold hold = holdRepository.findByHoldToken(holdToken)
                .orElseThrow(() -> new EntityNotFoundException("Hold not found: " + holdToken));

        // Validate hold is still active
        if (hold.getStatus() != HoldStatus.ACTIVE) {
            throw new IllegalStateException("Hold is not active: " + hold.getStatus());
        }
        if (hold.isExpired()) {
            throw new IllegalStateException("Hold has expired");
        }

        // Double-check room availability
        for (Room room : hold.getRooms()) {
            if (!isRoomAvailable(room.getId(), hold.getCheckInDate(), hold.getCheckOutDate())) {
                throw new IllegalStateException("Room " + room.getRoomNumber() +
                        " is no longer available");
            }
        }

        // Create reservation from hold
        ReservationRequestDTO reservationRequest = ReservationRequestDTO.builder()
                .guestId(hold.getGuest() != null ? hold.getGuest().getGuestId() : null)
                .roomIds(hold.getRooms().stream().map(Room::getId).collect(Collectors.toSet()))
                .checkInDate(hold.getCheckInDate())
                .checkOutDate(hold.getCheckOutDate())
                .status(ReservationStatus.PENDING)  // Start as PENDING until payment
                .build();

        var reservation = reservationService.createReservation(reservationRequest);

        // Update hold status
        hold.setStatus(HoldStatus.CONVERTED);
        holdRepository.save(hold);

        log.info("Hold {} converted to reservation {}", holdToken, reservation.getReservationId());

        return reservation.getReservationId();
    }

    @Override
    @Transactional
    public void cancelHold(String holdToken) {
        log.info("Cancelling hold: {}", holdToken);

        ReservationHold hold = holdRepository.findByHoldToken(holdToken)
                .orElseThrow(() -> new EntityNotFoundException("Hold not found: " + holdToken));

        if (hold.getStatus() != HoldStatus.ACTIVE) {
            throw new IllegalStateException("Hold is not active");
        }

        hold.setStatus(HoldStatus.CANCELLED);
        holdRepository.save(hold);

        log.info("Hold {} cancelled successfully", holdToken);
    }

    @Override
    @Transactional
    public ReservationHoldResponseDTO extendHold(String holdToken, Integer additionalMinutes) {
        log.info("Extending hold {} by {} minutes", holdToken, additionalMinutes);

        ReservationHold hold = holdRepository.findByHoldToken(holdToken)
                .orElseThrow(() -> new EntityNotFoundException("Hold not found: " + holdToken));

        if (hold.getStatus() != HoldStatus.ACTIVE) {
            throw new IllegalStateException("Hold is not active");
        }

        Instant newExpiresAt = hold.getExpiresAt().plus(Duration.ofMinutes(additionalMinutes));
        hold.setExpiresAt(newExpiresAt);

        ReservationHold updated = holdRepository.save(hold);

        log.info("Hold {} extended, new expiry: {}", holdToken, newExpiresAt);

        return mapToResponseDTO(updated);
    }

    @Override
    @Transactional
    public int processExpiredHolds() {
        log.info("Processing expired holds...");

        List<ReservationHold> expiredHolds = holdRepository.findExpiredActiveHolds(Instant.now());

        for (ReservationHold hold : expiredHolds) {
            hold.setStatus(HoldStatus.EXPIRED);
            log.info("Expired hold: {} (token: {})", hold.getHoldId(), hold.getHoldToken());
        }

        holdRepository.saveAll(expiredHolds);

        log.info("Processed {} expired holds", expiredHolds.size());
        return expiredHolds.size();
    }

    @Override
    @Transactional(readOnly = true)
    public List<ReservationHoldResponseDTO> getActiveHoldsByGuest(String guestId) {
        List<ReservationHold> holds = holdRepository.findByGuestGuestIdAndStatus(guestId, HoldStatus.ACTIVE);
        return holds.stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    // Helper methods

    private boolean isRoomAvailable(Long roomId, java.time.LocalDate checkIn, java.time.LocalDate checkOut) {
        // Check for overlapping active holds
        List<ReservationHold> conflictingHolds = holdRepository.findActiveHoldsForRoom(
                roomId, checkIn, checkOut);

        if (!conflictingHolds.isEmpty()) {
            return false;
        }

        // Check for overlapping reservations
        var conflictingReservations = reservationRepository
                .findOverlappingReservationsForRoom(roomId, checkIn, checkOut);

        boolean hasActiveReservation = conflictingReservations.stream()
                .anyMatch(r -> r.getStatus() != ReservationStatus.CANCELLED &&
                        r.getStatus() != ReservationStatus.CHECKED_OUT);

        return !hasActiveReservation;
    }

    private ReservationHoldResponseDTO mapToResponseDTO(ReservationHold hold) {
        long secondsRemaining = 0;
        if (hold.getStatus() == HoldStatus.ACTIVE) {
            Duration remaining = Duration.between(Instant.now(), hold.getExpiresAt());
            secondsRemaining = Math.max(0, remaining.getSeconds());
        }

        return ReservationHoldResponseDTO.builder()
                .holdId(hold.getHoldId())
                .holdToken(hold.getHoldToken())
                .sessionId(hold.getSessionId())
                .guestId(hold.getGuest() != null ? hold.getGuest().getGuestId() : null)
                .roomIds(hold.getRooms() != null
                        ? hold.getRooms().stream().map(Room::getId).collect(Collectors.toSet())
                        : Collections.emptySet())
                .roomType(hold.getRoomType())
                .numberOfRooms(hold.getNumberOfRooms())
                .checkInDate(hold.getCheckInDate())
                .checkOutDate(hold.getCheckOutDate())
                .status(hold.getStatus())
                .expiresAt(hold.getExpiresAt())
                .secondsRemaining(secondsRemaining)
                .createdAt(hold.getCreatedAt())
                .build();
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\ReservationServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.dto.*;
import com.example.stayops.entity.Guest;
import com.example.stayops.entity.Reservation;
import com.example.stayops.entity.ReservationDetails;
import com.example.stayops.entity.Room;
import com.example.stayops.enums.ReservationStatus;
import com.example.stayops.repository.GuestRepository;
import com.example.stayops.repository.ReservationRepository;
import com.example.stayops.repository.RoomRepository;
import com.example.stayops.service.ReservationService;
import com.example.stayops.service.ReservationHistoryService;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.example.stayops.entity.AuditLog;
import com.example.stayops.repository.AuditLogRepository;

import java.time.Instant;
import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@Slf4j
@Service
@RequiredArgsConstructor
public class ReservationServiceImpl implements ReservationService {

    private final ReservationRepository reservationRepository;
    private final GuestRepository guestRepository;
    private final RoomRepository roomRepository;
    private final ReservationHistoryService historyService;
    private final AuditLogRepository auditLogRepository;

    // ==================== CRUD OPERATIONS ====================

    @Override
    @Transactional
    public ReservationResponseDTO createReservation(ReservationRequestDTO requestDTO) {
        log.info("Creating reservation for guest: {}", requestDTO.getGuestId());

        // Validate dates
        validateDates(requestDTO.getCheckInDate(), requestDTO.getCheckOutDate());

        // Fetch guest
        Guest guest = guestRepository.findById(requestDTO.getGuestId())
                .orElseThrow(() -> new EntityNotFoundException("Guest not found: " + requestDTO.getGuestId()));

        // Fetch and validate rooms
        Set<Room> rooms = fetchAndValidateRooms(requestDTO.getRoomIds(),
                requestDTO.getCheckInDate(), requestDTO.getCheckOutDate(), null);

        // IMPORTANT: Auto-determine initial status based on check-in date
        ReservationStatus initialStatus = determineInitialStatus(
                requestDTO.getCheckInDate(),
                requestDTO.getStatus()
        );

        // Create reservation with determined status
        Reservation reservation = Reservation.builder()
                .checkInDate(requestDTO.getCheckInDate())
                .checkOutDate(requestDTO.getCheckOutDate())
                .status(initialStatus) // Use auto-determined status
                .guest(guest)
                .rooms(rooms)
                .build();

        // Add reservation details if provided
        if (hasReservationDetails(requestDTO)) {
            ReservationDetails details = ReservationDetails.builder()
                    .reservation(reservation)
                    .adults(requestDTO.getAdults() != null ? requestDTO.getAdults() : 1)
                    .kids(requestDTO.getKids() != null ? requestDTO.getKids() : 0)
                    .mealPlan(requestDTO.getMealPlan())
                    .amenities(requestDTO.getAmenities())
                    .specialRequests(requestDTO.getSpecialRequests())
                    .additionalNotes(requestDTO.getAdditionalNotes())
                    .build();
            reservation.setReservationDetails(details);
        }

        // Save everything in one transaction
        Reservation saved = reservationRepository.save(reservation);

        // Log audit with special note if auto-confirmed
        String auditNote = initialStatus == ReservationStatus.CONFIRMED &&
                requestDTO.getCheckInDate().equals(LocalDate.now())
                ? "Reservation created and AUTO-CONFIRMED (same-day booking)"
                : "Reservation created for guest: " + requestDTO.getGuestId();

        logAudit("RESERVATION", saved.getReservationId().toString(),
                "CREATE", "SYSTEM", "API", auditNote);

        // Record history
        recordStatusChange(saved, null, saved.getStatus(), "System",
                initialStatus == ReservationStatus.CONFIRMED &&
                        requestDTO.getCheckInDate().equals(LocalDate.now())
                        ? "Auto-confirmed same-day reservation"
                        : "Reservation created");

        log.info("Reservation created successfully with ID: {} (Status: {})",
                saved.getReservationId(), saved.getStatus());

        return mapToResponseDTO(saved);
    }

    // Add this helper method to ReservationServiceImpl
    private ReservationStatus determineInitialStatus(LocalDate checkInDate, ReservationStatus requestedStatus) {
        // If check-in is today, automatically confirm (skip PENDING status)
        if (checkInDate.equals(LocalDate.now())) {
            log.info("Same-day reservation detected - auto-confirming (bypassing PENDING status)");
            return ReservationStatus.CONFIRMED;
        }

        // Otherwise, use the requested status (typically PENDING)
        return requestedStatus != null ? requestedStatus : ReservationStatus.PENDING;
    }

    @Override
    @Transactional
    public ReservationResponseDTO updateReservation(Long reservationId, ReservationRequestDTO requestDTO) {
        log.info("Updating reservation: {}", reservationId);

        validateDates(requestDTO.getCheckInDate(), requestDTO.getCheckOutDate());

        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new EntityNotFoundException("Reservation not found: " + reservationId));

        // Store old status for history
        ReservationStatus oldStatus = reservation.getStatus();

        // Update guest if changed
        if (!reservation.getGuest().getGuestId().equals(requestDTO.getGuestId())) {
            Guest guest = guestRepository.findById(requestDTO.getGuestId())
                    .orElseThrow(() -> new EntityNotFoundException("Guest not found: " + requestDTO.getGuestId()));
            reservation.setGuest(guest);
        }

        // Update rooms if changed
        Set<Room> newRooms = fetchAndValidateRooms(requestDTO.getRoomIds(),
                requestDTO.getCheckInDate(), requestDTO.getCheckOutDate(), reservationId);
        reservation.setRoomsCollection(newRooms);

        // Update dates and status
        reservation.setCheckInDate(requestDTO.getCheckInDate());
        reservation.setCheckOutDate(requestDTO.getCheckOutDate());
        if (requestDTO.getStatus() != null) {
            validateStatusTransition(oldStatus, requestDTO.getStatus());
            reservation.setStatus(requestDTO.getStatus());
        }

        // Update or create reservation details
        if (hasReservationDetails(requestDTO)) {
            ReservationDetails details = reservation.getReservationDetails();
            if (details == null) {
                details = ReservationDetails.builder()
                        .reservation(reservation)
                        .build();
                reservation.setReservationDetails(details);
            }
            details.setAdults(requestDTO.getAdults() != null ? requestDTO.getAdults() : details.getAdults());
            details.setKids(requestDTO.getKids() != null ? requestDTO.getKids() : details.getKids());
            details.setMealPlan(requestDTO.getMealPlan() != null ? requestDTO.getMealPlan() : details.getMealPlan());
            details.setAmenities(requestDTO.getAmenities() != null ? requestDTO.getAmenities() : details.getAmenities());
            details.setSpecialRequests(requestDTO.getSpecialRequests() != null ?
                    requestDTO.getSpecialRequests() : details.getSpecialRequests());
            details.setAdditionalNotes(requestDTO.getAdditionalNotes() != null ?
                    requestDTO.getAdditionalNotes() : details.getAdditionalNotes());
        }

        Reservation saved = reservationRepository.save(reservation);

        // Record history if status changed
        if (oldStatus != saved.getStatus()) {
            recordStatusChange(saved, oldStatus, saved.getStatus(), "System", "Status updated during reservation update");
        }

        log.info("Reservation updated successfully: {}", saved.getReservationId());
        return mapToResponseDTO(saved);
    }

    @Override
    @Transactional
    public void deleteReservation(Long reservationId) {
        log.info("Deleting reservation: {}", reservationId);

        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new EntityNotFoundException("Reservation not found: " + reservationId));

        // Clear room associations
        reservation.setRoomsCollection(new HashSet<>());

        // Delete the reservation (cascade will handle details and history)
        reservationRepository.delete(reservation);

        log.info("Reservation deleted successfully: {}", reservationId);
    }

    @Override
    @Transactional(readOnly = true)
    public ReservationResponseDTO getReservationById(Long reservationId) {
        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new EntityNotFoundException("Reservation not found: " + reservationId));
        return mapToResponseDTO(reservation);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ReservationResponseDTO> getAllReservations() {
        return reservationRepository.findAll().stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    // ==================== STATUS MANAGEMENT ====================

    @Override
    @Transactional
    public ReservationResponseDTO updateReservationStatus(Long reservationId, String statusStr) {
        log.info("Updating reservation {} status to: {}", reservationId, statusStr);

        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new EntityNotFoundException("Reservation not found: " + reservationId));

        ReservationStatus oldStatus = reservation.getStatus();
        ReservationStatus newStatus;

        try {
            newStatus = ReservationStatus.valueOf(statusStr.toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid status: " + statusStr);
        }

        validateStatusTransition(oldStatus, newStatus);
        reservation.setStatus(newStatus);

        Reservation saved = reservationRepository.save(reservation);
        recordStatusChange(saved, oldStatus, newStatus, "System", "Manual status update");

        return mapToResponseDTO(saved);
    }

    @Override
    @Transactional
    public ReservationResponseDTO checkInReservation(Long reservationId) {
        log.info("Checking in reservation: {}", reservationId);

        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new EntityNotFoundException("Reservation not found: " + reservationId));

        if (reservation.getStatus() != ReservationStatus.CONFIRMED &&
                reservation.getStatus() != ReservationStatus.PENDING) {
            throw new IllegalStateException("Only CONFIRMED or PENDING reservations can be checked in");
        }

        LocalDate today = LocalDate.now();
        if (reservation.getCheckInDate().isAfter(today)) {
            throw new IllegalStateException("Cannot check in before check-in date");
        }

        ReservationStatus oldStatus = reservation.getStatus();
        reservation.setStatus(ReservationStatus.CHECKED_IN);

        Reservation saved = reservationRepository.save(reservation);
        recordStatusChange(saved, oldStatus, ReservationStatus.CHECKED_IN, "System", "Guest checked in");

        return mapToResponseDTO(saved);
    }

    @Override
    @Transactional
    public ReservationResponseDTO checkOutReservation(Long reservationId) {
        log.info("Checking out reservation: {}", reservationId);

        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new EntityNotFoundException("Reservation not found: " + reservationId));

        if (reservation.getStatus() != ReservationStatus.CHECKED_IN &&
                reservation.getStatus() != ReservationStatus.OCCUPIED) {
            throw new IllegalStateException("Only CHECKED_IN or OCCUPIED reservations can be checked out");
        }

        ReservationStatus oldStatus = reservation.getStatus();
        reservation.setStatus(ReservationStatus.CHECKED_OUT);

        Reservation saved = reservationRepository.save(reservation);
        recordStatusChange(saved, oldStatus, ReservationStatus.CHECKED_OUT, "System", "Guest checked out");

        return mapToResponseDTO(saved);
    }

    @Override
    @Transactional
    public ReservationResponseDTO cancelReservation(Long reservationId) {
        log.info("Cancelling reservation: {}", reservationId);

        Reservation reservation = reservationRepository.findById(reservationId)
                .orElseThrow(() -> new EntityNotFoundException("Reservation not found: " + reservationId));

        if (reservation.getStatus() == ReservationStatus.CHECKED_OUT) {
            throw new IllegalStateException("Cannot cancel a checked-out reservation");
        }

        ReservationStatus oldStatus = reservation.getStatus();
        reservation.setStatus(ReservationStatus.CANCELLED);

        Reservation saved = reservationRepository.save(reservation);
        recordStatusChange(saved, oldStatus, ReservationStatus.CANCELLED, "System", "Reservation cancelled");

        return mapToResponseDTO(saved);
    }

    // ==================== CALENDAR & DATE-BASED ====================

    @Override
    @Transactional(readOnly = true)
    public List<ReservationSummaryDTO> getMonthlySummary(int year, int month) {
        LocalDate firstDay = LocalDate.of(year, month, 1);
        LocalDate lastDay = firstDay.withDayOfMonth(firstDay.lengthOfMonth());

        List<Reservation> reservations = reservationRepository.findReservationsOverlapping(firstDay, lastDay);

        Map<LocalDate, ReservationSummaryDTO> map = new LinkedHashMap<>();
        IntStream.rangeClosed(1, firstDay.lengthOfMonth())
                .forEach(d -> map.put(firstDay.withDayOfMonth(d),
                        ReservationSummaryDTO.builder()
                                .date(firstDay.withDayOfMonth(d))
                                .checkIns(0)
                                .checkOuts(0)
                                .totalReservations(0)
                                .build()));

        for (Reservation r : reservations) {
            if (r.getStatus() == ReservationStatus.CANCELLED) {
                continue; // Skip cancelled reservations
            }

            LocalDate start = r.getCheckInDate();
            LocalDate end = r.getCheckOutDate();

            if (!start.isBefore(firstDay) && !start.isAfter(lastDay)) {
                map.get(start).incrementCheckIns();
            }
            if (!end.isBefore(firstDay) && !end.isAfter(lastDay)) {
                map.get(end).incrementCheckOuts();
            }

            LocalDate iter = start.isBefore(firstDay) ? firstDay : start;
            LocalDate iterEnd = end.isAfter(lastDay) ? lastDay : end;

            while (!iter.isAfter(iterEnd)) {
                map.get(iter).incrementTotalReservations();
                iter = iter.plusDays(1);
            }
        }

        return new ArrayList<>(map.values());
    }

    @Override
    @Transactional(readOnly = true)
    public List<ReservationDayDetailDTO> getReservationsForDate(LocalDate date) {
        List<Reservation> reservations = reservationRepository.findReservationsOverlapping(date, date);

        return reservations.stream()
                .filter(r -> r.getStatus() != ReservationStatus.CANCELLED)
                .map(r -> ReservationDayDetailDTO.builder()
                        .reservationId(r.getReservationId())
                        .guestId(r.getGuest() != null ? r.getGuest().getGuestId() : null)
                        .roomIds(r.getRooms() != null
                                ? r.getRooms().stream().map(Room::getId).collect(Collectors.toSet())
                                : Collections.emptySet())
                        .checkInDate(r.getCheckInDate())
                        .checkOutDate(r.getCheckOutDate())
                        .status(r.getStatus())
                        .build())
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<ReservationResponseDTO> getReservationsInDateRange(LocalDate startDate, LocalDate endDate) {
        List<Reservation> reservations = reservationRepository.findReservationsOverlapping(startDate, endDate);
        return reservations.stream()
                .filter(r -> r.getStatus() != ReservationStatus.CANCELLED)
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    // ==================== ROOM STATUS ====================

    @Override
    @Transactional(readOnly = true)
    public List<Map<String, Object>> getAllRoomReservationStatuses() {
        return reservationRepository.findAllRoomReservationStatuses();
    }

    @Override
    @Transactional(readOnly = true)
    public List<RoomStatusDTO> getRoomStatusForDate(LocalDate date) {
        List<Room> allRooms = roomRepository.findAll();
        List<Reservation> reservations = reservationRepository.findReservationsOverlapping(date, date);

        // Filter out cancelled reservations
        reservations = reservations.stream()
                .filter(r -> r.getStatus() != ReservationStatus.CANCELLED)
                .collect(Collectors.toList());

        Map<Long, Reservation> roomReservationMap = new HashMap<>();
        for (Reservation res : reservations) {
            if (res.getRooms() != null) {
                for (Room room : res.getRooms()) {
                    roomReservationMap.put(room.getId(), res);
                }
            }
        }

        List<RoomStatusDTO> statusList = new ArrayList<>();
        for (Room room : allRooms) {
            RoomStatusDTO status = RoomStatusDTO.builder()
                    .roomId(room.getId())
                    .roomNumber(room.getRoomNumber())
                    .roomType(room.getType())
                    .date(date)
                    .build();

            if (roomReservationMap.containsKey(room.getId())) {
                Reservation res = roomReservationMap.get(room.getId());
                status.setReservationId(res.getReservationId());
                status.setReservationStatus(res.getStatus().name());

                if (res.getGuest() != null) {
                    status.setGuestId(res.getGuest().getGuestId());
                    status.setGuestName(res.getGuest().getFirstName() + " " + res.getGuest().getLastName());
                }

                status.setCheckInDate(res.getCheckInDate());
                status.setCheckOutDate(res.getCheckOutDate());

                // Determine room status based on reservation status and dates
                if (res.getCheckInDate().equals(date) && res.getStatus() != ReservationStatus.CHECKED_IN) {
                    status.setStatus("ARRIVING");
                } else if (res.getCheckOutDate().equals(date) &&
                        (res.getStatus() == ReservationStatus.CHECKED_IN ||
                                res.getStatus() == ReservationStatus.OCCUPIED)) {
                    status.setStatus("DEPARTING");
                } else if (res.getStatus() == ReservationStatus.CHECKED_IN ||
                        res.getStatus() == ReservationStatus.OCCUPIED) {
                    status.setStatus("OCCUPIED");
                } else if (res.getStatus() == ReservationStatus.CONFIRMED ||
                        res.getStatus() == ReservationStatus.PENDING) {
                    status.setStatus("RESERVED");
                } else {
                    status.setStatus("AVAILABLE");
                }
            } else {
                status.setStatus("AVAILABLE");
            }

            statusList.add(status);
        }

        return statusList;
    }

    @Override
    @Transactional(readOnly = true)
    public Map<Long, List<RoomStatusDTO>> getRoomStatusForDateRange(LocalDate startDate, LocalDate endDate) {
        Map<Long, List<RoomStatusDTO>> rangeMap = new LinkedHashMap<>();

        LocalDate current = startDate;
        while (!current.isAfter(endDate)) {
            List<RoomStatusDTO> dailyStatus = getRoomStatusForDate(current);
            rangeMap.put(current.toEpochDay(), dailyStatus);
            current = current.plusDays(1);
        }

        return rangeMap;
    }

    // ==================== ARRIVALS & DEPARTURES ====================

    @Override
    @Transactional(readOnly = true)
    public List<ReservationResponseDTO> getArrivalsForDate(LocalDate date) {
        List<Reservation> reservations = reservationRepository.findByCheckInDate(date);
        return reservations.stream()
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED ||
                        r.getStatus() == ReservationStatus.PENDING)
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<ReservationResponseDTO> getDeparturesForDate(LocalDate date) {
        List<Reservation> reservations = reservationRepository.findByCheckOutDate(date);
        return reservations.stream()
                .filter(r -> r.getStatus() == ReservationStatus.CHECKED_IN ||
                        r.getStatus() == ReservationStatus.OCCUPIED)
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public DailyOperationsSummaryDTO getDailyOperationsSummary(LocalDate date) {
        List<Room> allRooms = roomRepository.findAll();
        int totalRooms = allRooms.size();

        List<Reservation> todayReservations = reservationRepository.findReservationsOverlapping(date, date);

        // Filter out cancelled reservations
        todayReservations = todayReservations.stream()
                .filter(r -> r.getStatus() != ReservationStatus.CANCELLED)
                .collect(Collectors.toList());

        Set<Long> occupiedRoomIds = todayReservations.stream()
                .filter(r -> r.getStatus() == ReservationStatus.CHECKED_IN ||
                        r.getStatus() == ReservationStatus.OCCUPIED)
                .flatMap(r -> r.getRooms().stream())
                .map(Room::getId)
                .collect(Collectors.toSet());

        int occupiedRooms = occupiedRoomIds.size();

        int expectedArrivals = (int) reservationRepository.findByCheckInDate(date).stream()
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED ||
                        r.getStatus() == ReservationStatus.PENDING)
                .count();

        int expectedDepartures = (int) reservationRepository.findByCheckOutDate(date).stream()
                .filter(r -> r.getStatus() == ReservationStatus.CHECKED_IN ||
                        r.getStatus() == ReservationStatus.OCCUPIED)
                .count();

        int inHouseGuests = (int) todayReservations.stream()
                .filter(r -> r.getStatus() == ReservationStatus.CHECKED_IN ||
                        r.getStatus() == ReservationStatus.OCCUPIED)
                .count();

        int pendingReservations = (int) todayReservations.stream()
                .filter(r -> r.getStatus() == ReservationStatus.PENDING)
                .count();

        int confirmedReservations = (int) todayReservations.stream()
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED)
                .count();

        double occupancyRate = totalRooms > 0 ? (double) occupiedRooms / totalRooms * 100 : 0.0;

        return DailyOperationsSummaryDTO.builder()
                .date(date)
                .totalRooms(totalRooms)
                .occupiedRooms(occupiedRooms)
                .availableRooms(totalRooms - occupiedRooms)
                .expectedArrivals(expectedArrivals)
                .expectedDepartures(expectedDepartures)
                .inHouseGuests(inHouseGuests)
                .occupancyRate(Math.round(occupancyRate * 100.0) / 100.0)
                .pendingReservations(pendingReservations)
                .confirmedReservations(confirmedReservations)
                .build();
    }

    // ==================== GUEST & SEARCH ====================

    @Override
    @Transactional(readOnly = true)
    public List<ReservationResponseDTO> getReservationsByGuestId(String guestId) {
        List<Reservation> reservations = reservationRepository.findByGuestGuestId(guestId);
        return reservations.stream().map(this::mapToResponseDTO).collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<ReservationResponseDTO> searchReservations(String guestId, String statusStr,
                                                           LocalDate checkInDate, LocalDate checkOutDate) {
        List<Reservation> reservations = reservationRepository.findAll();

        return reservations.stream()
                .filter(r -> guestId == null || (r.getGuest() != null &&
                        r.getGuest().getGuestId().equals(guestId)))
                .filter(r -> statusStr == null || r.getStatus().name().equals(statusStr.toUpperCase()))
                .filter(r -> checkInDate == null || r.getCheckInDate().equals(checkInDate))
                .filter(r -> checkOutDate == null || r.getCheckOutDate().equals(checkOutDate))
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    // ==================== OCCUPANCY ====================

    @Override
    @Transactional(readOnly = true)
    public OccupancyStatsDTO getCurrentOccupancyStats() {
        return getOccupancyStatsForDate(LocalDate.now());
    }

    @Override
    @Transactional(readOnly = true)
    public OccupancyStatsDTO getOccupancyStatsForDate(LocalDate date) {
        List<Room> allRooms = roomRepository.findAll();
        int totalRooms = allRooms.size();

        List<Reservation> reservations = reservationRepository.findReservationsOverlapping(date, date);

        // Filter out cancelled reservations
        reservations = reservations.stream()
                .filter(r -> r.getStatus() != ReservationStatus.CANCELLED)
                .collect(Collectors.toList());

        Set<Long> occupiedRoomIds = reservations.stream()
                .filter(r -> r.getStatus() == ReservationStatus.CHECKED_IN ||
                        r.getStatus() == ReservationStatus.OCCUPIED)
                .flatMap(r -> r.getRooms().stream())
                .map(Room::getId)
                .collect(Collectors.toSet());

        Set<Long> reservedRoomIds = reservations.stream()
                .filter(r -> r.getStatus() == ReservationStatus.CONFIRMED ||
                        r.getStatus() == ReservationStatus.PENDING)
                .flatMap(r -> r.getRooms().stream())
                .map(Room::getId)
                .collect(Collectors.toSet());

        int occupiedRooms = occupiedRoomIds.size();
        int reservedRooms = reservedRoomIds.size();

        int totalGuests = reservations.stream()
                .filter(r -> r.getStatus() == ReservationStatus.CHECKED_IN ||
                        r.getStatus() == ReservationStatus.OCCUPIED)
                .mapToInt(r -> {
                    if (r.getReservationDetails() != null) {
                        return r.getReservationDetails().getAdults() + r.getReservationDetails().getKids();
                    }
                    return 1; // Default to 1 guest if no details
                })
                .sum();

        double occupancyRate = totalRooms > 0 ? (double) occupiedRooms / totalRooms * 100 : 0.0;

        return OccupancyStatsDTO.builder()
                .date(date)
                .totalRooms(totalRooms)
                .occupiedRooms(occupiedRooms)
                .availableRooms(totalRooms - occupiedRooms - reservedRooms)
                .reservedRooms(reservedRooms)
                .occupancyRate(Math.round(occupancyRate * 100.0) / 100.0)
                .totalGuests(totalGuests)
                .build();
    }

    // ==================== HELPER METHODS ====================

    private void validateDates(LocalDate checkIn, LocalDate checkOut) {
        if (checkIn == null || checkOut == null) {
            throw new IllegalArgumentException("Check-in and check-out dates are required");
        }
        if (checkOut.isBefore(checkIn) || checkOut.equals(checkIn)) {
            throw new IllegalArgumentException("Check-out date must be after check-in date");
        }
        // Remove past date validation to allow historical data entry
        // if (checkIn.isBefore(LocalDate.now())) {
        //     throw new IllegalArgumentException("Check-in date cannot be in the past");
        // }
    }

    private Set<Room> fetchAndValidateRooms(Set<Long> roomIds, LocalDate checkIn, LocalDate checkOut, Long excludeReservationId) {
        if (roomIds == null || roomIds.isEmpty()) {
            throw new IllegalArgumentException("At least one room must be selected");
        }

        List<Room> rooms = roomRepository.findAllById(roomIds);
        if (rooms.size() != roomIds.size()) {
            Set<Long> foundIds = rooms.stream().map(Room::getId).collect(Collectors.toSet());
            Set<Long> missingIds = new HashSet<>(roomIds);
            missingIds.removeAll(foundIds);
            throw new EntityNotFoundException("Rooms not found: " + missingIds);
        }

        // Check room availability
        for (Room room : rooms) {
            List<Reservation> conflicts = excludeReservationId == null
                    ? reservationRepository.findOverlappingReservationsForRoom(room.getId(), checkIn, checkOut)
                    : reservationRepository.findOverlappingReservationsForRoomExcludingReservation(
                    room.getId(), excludeReservationId, checkIn, checkOut);

            boolean hasActiveConflict = conflicts.stream()
                    .anyMatch(r -> r.getStatus() != ReservationStatus.CANCELLED &&
                            r.getStatus() != ReservationStatus.CHECKED_OUT);

            if (hasActiveConflict) {
                throw new IllegalStateException("Room " + room.getRoomNumber() +
                        " is not available for the selected dates");
            }
        }

        return new HashSet<>(rooms);
    }

    /**
     * Validate status transitions with more flexibility for administrative corrections.
     * Allows most transitions except a few illogical ones (e.g., from CHECKED_OUT or CANCELLED to active statuses)
     */
    private void validateStatusTransition(ReservationStatus current, ReservationStatus next) {
        if (current == next) {
            return; // No change
        }

        // Allow transitions from CHECKED_OUT only to itself (no change)
        if (current == ReservationStatus.CHECKED_OUT && next != ReservationStatus.CHECKED_OUT) {
            log.warn("Attempting to transition from CHECKED_OUT to {}. This is unusual but allowed for administrative corrections.", next);
            // Allow it but log a warning
        }

        // Block transitions from CANCELLED to active statuses - use create new reservation instead
        if (current == ReservationStatus.CANCELLED && next != ReservationStatus.CANCELLED) {
            log.warn("Attempting to reactivate a CANCELLED reservation to {}. This is unusual but allowed for administrative corrections.", next);
            // Allow it but log a warning
        }

        // All other transitions are allowed for flexibility
        log.info("Status transition from {} to {} validated successfully", current, next);
    }

    private boolean hasReservationDetails(ReservationRequestDTO requestDTO) {
        return requestDTO.getAdults() != null ||
                requestDTO.getKids() != null ||
                requestDTO.getMealPlan() != null ||
                requestDTO.getAmenities() != null ||
                requestDTO.getSpecialRequests() != null ||
                requestDTO.getAdditionalNotes() != null;
    }

    private void recordStatusChange(Reservation reservation, ReservationStatus oldStatus,
                                    ReservationStatus newStatus, String changedBy, String notes) {
        try {
            ReservationHistoryDTO historyDTO = ReservationHistoryDTO.builder()
                    .reservationId(reservation.getReservationId())
                    .previousStatus(oldStatus)
                    .newStatus(newStatus)
                    .changedBy(changedBy)
                    .notes(notes)
                    .build();
            historyService.recordHistory(historyDTO);
        } catch (Exception e) {
            log.warn("Failed to record history for reservation {}: {}",
                    reservation.getReservationId(), e.getMessage());
            // Don't fail the main operation if history recording fails
        }
    }

    private ReservationResponseDTO mapToResponseDTO(Reservation r) {
        return ReservationResponseDTO.builder()
                .reservationId(r.getReservationId())
                .guestId(r.getGuest() != null ? r.getGuest().getGuestId() : null)
                .roomIds(r.getRooms() != null
                        ? r.getRooms().stream().map(Room::getId).collect(Collectors.toSet())
                        : Collections.emptySet())
                .checkInDate(r.getCheckInDate())
                .checkOutDate(r.getCheckOutDate())
                .status(r.getStatus())
                .createdAt(r.getCreatedAt())
                .updatedAt(r.getUpdatedAt())
                .build();
    }

    private void logAudit(String entityType, String entityId, String action,
                          String actorType, String actorId, String description) {
        try {
            AuditLog log = AuditLog.builder()
                    .entityType(entityType)
                    .entityId(entityId)
                    .action(action)
                    .actorType(actorType)
                    .actorId(actorId)
                    .description(description)
                    .timestamp(Instant.now())
                    .build();

            auditLogRepository.save(log);
        } catch (Exception e) {
            log.error("Failed to create audit log: {}", e.getMessage());
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\RoomServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.dto.RoomDTO;
import com.example.stayops.entity.Hotel;
import com.example.stayops.entity.Room;
import com.example.stayops.repository.HotelRepository;
import com.example.stayops.repository.RoomRepository;
import com.example.stayops.service.RoomService;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class RoomServiceImpl implements RoomService {

    private final RoomRepository roomRepository;
    private final HotelRepository hotelRepository;

    @Override
    @Transactional
    public RoomDTO createRoom(RoomDTO roomDTO) {
        Room room = Room.builder()
                .roomNumber(roomDTO.getRoomNumber())
                .type(roomDTO.getType())
                .capacity(roomDTO.getCapacity())
                .pricePerNight(roomDTO.getPricePerNight())
                .availabilityStatus(roomDTO.getAvailabilityStatus())
                .floorNumber(roomDTO.getFloorNumber())
                .description(roomDTO.getDescription())
                .build();

        if (roomDTO.getHotelId() != null) {
            Hotel hotel = hotelRepository.findById(roomDTO.getHotelId())
                    .orElseThrow(() -> new EntityNotFoundException("Hotel not found: " + roomDTO.getHotelId()));
            room.setHotel(hotel);
        }

        Room saved = roomRepository.save(room);
        return mapToDTO(saved);
    }

    @Override
    @Transactional
    public RoomDTO updateRoom(Long id, RoomDTO roomDTO) {
        Room room = roomRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Room not found: " + id));

        room.setRoomNumber(roomDTO.getRoomNumber());
        room.setType(roomDTO.getType());
        room.setCapacity(roomDTO.getCapacity());
        room.setPricePerNight(roomDTO.getPricePerNight());
        room.setAvailabilityStatus(roomDTO.getAvailabilityStatus());
        room.setFloorNumber(roomDTO.getFloorNumber());
        room.setDescription(roomDTO.getDescription());

        if (roomDTO.getHotelId() != null) {
            Hotel hotel = hotelRepository.findById(roomDTO.getHotelId())
                    .orElseThrow(() -> new EntityNotFoundException("Hotel not found: " + roomDTO.getHotelId()));
            room.setHotel(hotel);
        }

        Room saved = roomRepository.save(room);
        return mapToDTO(saved);
    }

    @Override
    @Transactional
    public void deleteRoom(Long id) {
        Room room = roomRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Room not found: " + id));
        roomRepository.delete(room);
    }

    @Override
    @Transactional(readOnly = true)
    public RoomDTO getRoomById(Long id) {
        Room room = roomRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Room not found: " + id));
        return mapToDTO(room);
    }

    @Override
    @Transactional(readOnly = true)
    public List<RoomDTO> getAllRooms() {
        return roomRepository.findAll().stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<RoomDTO> getAvailableRooms() {
        return roomRepository.findByAvailabilityStatus("AVAILABLE").stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<RoomDTO> getRoomsByType(String type) {
        return roomRepository.findByType(type).stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<RoomDTO> getRoomsByHotel(Long hotelId) {
        return roomRepository.findByHotelId(hotelId).stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    private RoomDTO mapToDTO(Room room) {
        return RoomDTO.builder()
                .id(room.getId())
                .roomNumber(room.getRoomNumber())
                .type(room.getType())
                .capacity(room.getCapacity())
                .pricePerNight(room.getPricePerNight())
                .availabilityStatus(room.getAvailabilityStatus())
                .floorNumber(room.getFloorNumber())
                .description(room.getDescription())
                .hotelId(room.getHotel() != null ? room.getHotel().getId() : null)
                .build();
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\RoomStatusHistoryServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.dto.RoomStatusHistoryDTO;
import com.example.stayops.entity.Room;
import com.example.stayops.entity.RoomStatusHistory;
import com.example.stayops.repository.RoomRepository;
import com.example.stayops.repository.RoomStatusHistoryRepository;
import com.example.stayops.service.RoomStatusHistoryService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class RoomStatusHistoryServiceImpl implements RoomStatusHistoryService {

    private final RoomStatusHistoryRepository historyRepository;
    private final RoomRepository roomRepository;

    @Override
    public RoomStatusHistoryDTO createStatusChange(RoomStatusHistoryDTO dto) {
        Room room = roomRepository.findById(dto.getRoomId())
                .orElseThrow(() -> new RuntimeException("Room not found"));

        RoomStatusHistory history = RoomStatusHistory.builder()
                .room(room)
                .previousStatus(dto.getPreviousStatus())
                .newStatus(dto.getNewStatus())
                .changedAt(LocalDateTime.now())
                .build();

        historyRepository.save(history);

        dto.setId(history.getId());
        dto.setChangedAt(history.getChangedAt());
        return dto;
    }

    @Override
    public List<RoomStatusHistoryDTO> getHistoryByRoom(Long roomId) {
        return historyRepository.findByRoomId(roomId)
                .stream()
                .map(h -> new RoomStatusHistoryDTO(
                        h.getId(),
                        h.getRoom().getId(),
                        h.getPreviousStatus(),
                        h.getNewStatus(),
                        h.getChangedAt()
                ))
                .collect(Collectors.toList());
    }

    @Override
    public List<RoomStatusHistoryDTO> getAllHistory() {
        return historyRepository.findAll()
                .stream()
                .map(h -> new RoomStatusHistoryDTO(
                        h.getId(),
                        h.getRoom().getId(),
                        h.getPreviousStatus(),
                        h.getNewStatus(),
                        h.getChangedAt()
                ))
                .collect(Collectors.toList());
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\ServiceRequestServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.dto.ServiceRequestDTO;
import com.example.stayops.entity.ServiceRequest;
import com.example.stayops.repository.ServiceRequestRepository;
import com.example.stayops.service.ServiceRequestService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class ServiceRequestServiceImpl implements ServiceRequestService {

    private final ServiceRequestRepository serviceRequestRepository;

    @Override
    @Transactional
    public ServiceRequestDTO createServiceRequest(ServiceRequestDTO dto) {
        log.info("Creating service request: {}", dto);

        ServiceRequest serviceRequest = ServiceRequest.builder()
                .serviceType(dto.getServiceType())
                .description(dto.getDescription())
                .status(dto.getStatus() != null ? dto.getStatus() : "PENDING")
                .requestedBy(dto.getRequestedBy())
                .priority(dto.getPriority())
                .build();

        ServiceRequest saved = serviceRequestRepository.save(serviceRequest);
        return mapToDTO(saved);
    }

    @Override
    @Transactional(readOnly = true)
    public ServiceRequestDTO getServiceRequestById(Long id) {
        ServiceRequest serviceRequest = serviceRequestRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Service request not found: " + id));
        return mapToDTO(serviceRequest);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ServiceRequestDTO> getAllServiceRequests() {
        return serviceRequestRepository.findAll().stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public ServiceRequestDTO updateServiceRequest(Long id, ServiceRequestDTO dto) {
        log.info("Updating service request: {}", id);

        ServiceRequest serviceRequest = serviceRequestRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Service request not found: " + id));

        serviceRequest.setServiceType(dto.getServiceType());
        serviceRequest.setDescription(dto.getDescription());
        serviceRequest.setStatus(dto.getStatus());
        serviceRequest.setPriority(dto.getPriority());

        ServiceRequest updated = serviceRequestRepository.save(serviceRequest);
        return mapToDTO(updated);
    }

    @Override
    @Transactional
    public void deleteServiceRequest(Long id) {
        log.info("Deleting service request: {}", id);
        serviceRequestRepository.deleteById(id);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ServiceRequestDTO> getServiceRequestsByStatus(String status) {
        return serviceRequestRepository.findByStatus(status).stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<ServiceRequestDTO> getServiceRequestsByType(String serviceType) {
        return serviceRequestRepository.findByServiceType(serviceType).stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<ServiceRequestDTO> getServiceRequestsByPriority(String priority) {
        return serviceRequestRepository.findByPriority(priority).stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<ServiceRequestDTO> getServiceRequestsByReservation(Long reservationId) {
        return serviceRequestRepository.findByReservationReservationId(reservationId).stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<ServiceRequestDTO> getServiceRequestsByRoom(Long roomId) {
        return serviceRequestRepository.findByRoomId(roomId).stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<ServiceRequestDTO> getServiceRequestsByAssignedStaff(String staffId) {
        return serviceRequestRepository.findByAssignedTo(staffId).stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<ServiceRequestDTO> getPendingRequests() {
        return serviceRequestRepository.findPendingRequests().stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<ServiceRequestDTO> getUrgentRequests() {
        return serviceRequestRepository.findUrgentRequests().stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public ServiceRequestDTO assignToStaff(Long requestId, String staffId) {
        log.info("Assigning service request {} to staff {}", requestId, staffId);

        ServiceRequest serviceRequest = serviceRequestRepository.findById(requestId)
                .orElseThrow(() -> new RuntimeException("Service request not found: " + requestId));

        serviceRequest.setAssignedTo(staffId);
        serviceRequest.setStatus("IN_PROGRESS");

        ServiceRequest updated = serviceRequestRepository.save(serviceRequest);
        return mapToDTO(updated);
    }

    @Override
    @Transactional
    public ServiceRequestDTO updateStatus(Long requestId, String status) {
        log.info("Updating service request {} status to {}", requestId, status);

        ServiceRequest serviceRequest = serviceRequestRepository.findById(requestId)
                .orElseThrow(() -> new RuntimeException("Service request not found: " + requestId));

        serviceRequest.setStatus(status);

        if ("COMPLETED".equals(status)) {
            serviceRequest.setCompletedAt(java.time.Instant.now());
        }

        ServiceRequest updated = serviceRequestRepository.save(serviceRequest);
        return mapToDTO(updated);
    }

    @Override
    @Transactional
    public ServiceRequestDTO markAsCompleted(Long requestId) {
        log.info("Marking service request {} as completed", requestId);

        ServiceRequest serviceRequest = serviceRequestRepository.findById(requestId)
                .orElseThrow(() -> new RuntimeException("Service request not found: " + requestId));

        serviceRequest.setStatus("COMPLETED");
        serviceRequest.setCompletedAt(java.time.Instant.now());

        ServiceRequest updated = serviceRequestRepository.save(serviceRequest);
        return mapToDTO(updated);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ServiceRequestDTO> getServiceRequestsByDateRange(java.time.Instant startDate, java.time.Instant endDate) {
        return serviceRequestRepository.findByDateRange(startDate, endDate).stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<ServiceRequestDTO> getIncompleteRequests() {
        return serviceRequestRepository.findIncompleteRequests().stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());
    }

    private ServiceRequestDTO mapToDTO(ServiceRequest entity) {
        return ServiceRequestDTO.builder()
                .id(entity.getId())
                .serviceType(entity.getServiceType())
                .description(entity.getDescription())
                .status(entity.getStatus())
                .requestedBy(entity.getRequestedBy())
                .priority(entity.getPriority())
                .reservationId(entity.getReservation() != null ? entity.getReservation().getReservationId() : null)
                .roomId(entity.getRoom() != null ? entity.getRoom().getId() : null)
                .roomNumber(entity.getRoom() != null ? entity.getRoom().getRoomNumber() : null)
                .assignedTo(entity.getAssignedTo())
                .completedAt(entity.getCompletedAt())
                .notes(entity.getNotes())
                .createdAt(entity.getCreatedAt())
                .updatedAt(entity.getUpdatedAt())
                .build();
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\ServiceTypeServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.dto.ServiceTypeDTO;
import com.example.stayops.entity.ServiceType;
import com.example.stayops.exception.ResourceNotFoundException;
import com.example.stayops.repository.ServiceTypeRepository;
import com.example.stayops.service.ServiceTypeService;
import com.example.stayops.util.ServiceTypeMapper;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.validation.annotation.Validated;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Validated
@Transactional
public class ServiceTypeServiceImpl implements ServiceTypeService {

    private final ServiceTypeRepository repository;
    private final ServiceTypeMapper mapper;

    @Override
    public ServiceTypeDTO create(ServiceTypeDTO dto) {
        log.debug("Creating ServiceType with code={}", dto.getCode());
        ServiceType entity = mapper.toEntity(dto);
        // ensure id not set
        entity.setId(null);
        ServiceType saved = repository.save(entity);
        return mapper.toDto(saved);
    }

    @Override
    public ServiceTypeDTO getById(Long id) {
        ServiceType st = repository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("ServiceType", "id", id));
        return mapper.toDto(st);
    }

    @Override
    public ServiceTypeDTO getByCode(String code) {
        ServiceType st = repository.findByCode(code)
                .orElseThrow(() -> new ResourceNotFoundException("ServiceType", "code", code));
        return mapper.toDto(st);
    }

    @Override
    public List<ServiceTypeDTO> getAll() {
        return repository.findAll()
                .stream()
                .map(mapper::toDto)
                .collect(Collectors.toList());
    }

    @Override
    public ServiceTypeDTO update(Long id, ServiceTypeDTO dto) {
        ServiceType existing = repository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("ServiceType", "id", id));
        // update fields
        existing.setName(dto.getName());
        existing.setCode(dto.getCode());
        existing.setDefaultCharge(dto.getDefaultCharge());
        existing.setDescription(dto.getDescription());
        ServiceType updated = repository.save(existing);
        return mapper.toDto(updated);
    }

    @Override
    public void delete(Long id) {
        ServiceType existing = repository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("ServiceType", "id", id));
        repository.delete(existing);
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\service\impl\StaffServiceImpl.java ==== 
package com.example.stayops.service.impl;

import com.example.stayops.dto.StaffRequestDTO;
import com.example.stayops.dto.StaffResponseDTO;
import com.example.stayops.entity.Department;
import com.example.stayops.entity.Staff;
import com.example.stayops.repository.DepartmentRepository;
import com.example.stayops.repository.StaffRepository;
import com.example.stayops.service.StaffService;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional
public class StaffServiceImpl implements StaffService {

    private final StaffRepository staffRepository;
    private final DepartmentRepository departmentRepository;

    @Override
    public StaffResponseDTO createStaff(StaffRequestDTO dto) {
        Department department = departmentRepository.findById(dto.getDepartmentId())
                .orElseThrow(() -> new EntityNotFoundException("Department not found with id: " + dto.getDepartmentId()));

        Staff staff = Staff.builder()
                .staffId(dto.getStaffId())
                .name(dto.getName())
                .email(dto.getEmail())
                .phone(dto.getPhone())
                .role(dto.getRole())
                .status(dto.getStatus())
                .hireDate(dto.getHireDate())
                .department(department)
                .hotel(department.getHotel())  // FIXED: Set hotel from department
                .build();

        return mapToResponseDTO(staffRepository.save(staff));
    }

    @Override
    public StaffResponseDTO updateStaff(String staffId, StaffRequestDTO dto) {
        Staff staff = staffRepository.findById(staffId)
                .orElseThrow(() -> new EntityNotFoundException("Staff not found with id: " + staffId));

        Department department = departmentRepository.findById(dto.getDepartmentId())
                .orElseThrow(() -> new EntityNotFoundException("Department not found with id: " + dto.getDepartmentId()));

        staff.setName(dto.getName());
        staff.setEmail(dto.getEmail());
        staff.setPhone(dto.getPhone());
        staff.setRole(dto.getRole());
        staff.setStatus(dto.getStatus());
        staff.setHireDate(dto.getHireDate());
        staff.setDepartment(department);
        staff.setHotel(department.getHotel());  // FIXED: Set hotel from department

        return mapToResponseDTO(staffRepository.save(staff));
    }

    @Override
    public void deleteStaff(String staffId) {
        if (!staffRepository.existsById(staffId)) {
            throw new EntityNotFoundException("Staff not found with id: " + staffId);
        }
        staffRepository.deleteById(staffId);
    }

    @Override
    public StaffResponseDTO getStaffById(String staffId) {
        return staffRepository.findById(staffId)
                .map(this::mapToResponseDTO)
                .orElseThrow(() -> new EntityNotFoundException("Staff not found with id: " + staffId));
    }

    @Override
    public List<StaffResponseDTO> getAllStaff() {
        return staffRepository.findAll()
                .stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    private StaffResponseDTO mapToResponseDTO(Staff staff) {
        return StaffResponseDTO.builder()
                .staffId(staff.getStaffId())
                .name(staff.getName())
                .email(staff.getEmail())
                .phone(staff.getPhone())
                .role(staff.getRole())
                .status(staff.getStatus())
                .hireDate(staff.getHireDate())
                .departmentId(staff.getDepartment().getId())
                .departmentName(staff.getDepartment().getName())
                .createdAt(staff.getCreatedAt())
                .updatedAt(staff.getUpdatedAt())
                .build();
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\util\ImageConverterUtil.java ==== 
package com.example.stayops.util;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.Base64;

public class ImageConverterUtil {

    // --- Original methods (kept as-is) ---

    public static File base64ToPng(String base64Image, String outputPath) throws IOException {
        if (base64Image.contains(",")){
            base64Image = base64Image.split(",")[1];
        }

        byte[] imageBytes = Base64.getDecoder().decode(base64Image);
        try (OutputStream out = new FileOutputStream(outputPath)){
            out.write(imageBytes);
        }
        return new File(outputPath);
    }

    public static String pngToBase64(File file) throws IOException {
        BufferedImage bufferedImage = ImageIO.read(file);
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        ImageIO.write(bufferedImage, "png", outputStream);

        return Base64.getEncoder().encodeToString(outputStream.toByteArray());
    }

    // made static (was non-static in your snippet) so other classes can call it directly
    public static BufferedImage base64ToBufferedImage (String base64Image) throws IOException {
        if (base64Image.contains(",")){
            base64Image = base64Image.split(",")[1];
        }
        byte[] imageBytes = Base64.getDecoder().decode(base64Image);
        try (InputStream in = new ByteArrayInputStream(imageBytes)){
            return ImageIO.read(in);
        }
    }

    public static String bufferedImageToBase64(BufferedImage image) throws IOException {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        ImageIO.write(image, "png", outputStream);
        return Base64.getEncoder().encodeToString(outputStream.toByteArray());
    }

    // --- New helper methods (added) ---

    /**
     * Convert a base64 or data-url string into raw bytes.
     */
    public static byte[] base64ToBytes(String base64Image) {
        if (base64Image == null) return null;
        if (base64Image.contains(",")) {
            base64Image = base64Image.split(",")[1];
        }
        return Base64.getDecoder().decode(base64Image);
    }

    /**
     * Convert raw image bytes to a data URL string like: data:image/png;base64,<payload>
     * Attempts to detect PNG/JPEG. Falls back to image/png if uncertain.
     */
    public static String bytesToBase64DataUrl(byte[] imageBytes) {
        if (imageBytes == null) return null;
        String mime = detectImageMimeType(imageBytes);
        String base64 = Base64.getEncoder().encodeToString(imageBytes);
        return "data:" + mime + ";base64," + base64;
    }

    /**
     * Basic mime type detection for common image formats based on magic numbers.
     * Supports png and jpeg detection; falls back to image/png.
     */
    public static String detectImageMimeType(byte[] imageBytes) {
        if (imageBytes == null || imageBytes.length < 4) {
            return "image/png";
        }

        // PNG: 89 50 4E 47
        if ((imageBytes[0] & 0xFF) == 0x89 &&
                (imageBytes[1] & 0xFF) == 0x50 &&
                (imageBytes[2] & 0xFF) == 0x4E &&
                (imageBytes[3] & 0xFF) == 0x47) {
            return "image/png";
        }

        // JPEG: FF D8 FF
        if ((imageBytes[0] & 0xFF) == 0xFF &&
                (imageBytes[1] & 0xFF) == 0xD8 &&
                (imageBytes[2] & 0xFF) == 0xFF) {
            return "image/jpeg";
        }

        // default
        return "image/png";
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\util\JwtUtil.java ==== 
package com.example.stayops.util;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Component
@Slf4j
public class JwtUtil {

    @Value("${jwt.secret:mySecretKeyThatShouldBeAtLeast32CharactersLongForHS256Algorithm}")
    private String secret;

    @Value("${jwt.expiration:86400}") // seconds (default 24 hours)
    private Long expiration;

    private SecretKey getSigningKey() {
        // Ensure the secret is long enough for HS256
        if (secret == null || secret.length() < 32) {
            log.warn("JWT secret is too short or missing. Using default development secret.");
            secret = "mySecretKeyThatShouldBeAtLeast32CharactersLongForHS256Algorithm";
        }
        return Keys.hmacShaKeyFor(secret.getBytes());
    }

    public String getUsernameFromToken(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public String extractEmail(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        try {
            final Claims claims = extractAllClaims(token);
            return claimsResolver.apply(claims);
        } catch (JwtException e) {
            log.error("Error extracting claim from JWT token: {}", e.getMessage());
            throw e;
        }
    }

    private Claims extractAllClaims(String token) {
        try {
            return Jwts.parserBuilder()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(token)
                    .getBody();
        } catch (ExpiredJwtException e) {
            log.warn("JWT token has expired: {}", e.getMessage());
            throw e;
        } catch (UnsupportedJwtException e) {
            log.error("JWT token is unsupported: {}", e.getMessage());
            throw e;
        } catch (MalformedJwtException e) {
            log.error("JWT token is malformed: {}", e.getMessage());
            throw e;
        } catch (SecurityException e) {
            log.error("JWT signature validation failed: {}", e.getMessage());
            throw e;
        } catch (IllegalArgumentException e) {
            log.error("JWT token compact of handler are invalid: {}", e.getMessage());
            throw e;
        }
    }

    private Boolean isTokenExpired(String token) {
        try {
            return extractExpiration(token).before(new Date());
        } catch (JwtException e) {
            log.error("Error checking token expiration: {}", e.getMessage());
            return true; // Consider expired if we can't parse it
        }
    }

    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        // Add first authority as role claim (if present)
        if (userDetails.getAuthorities().iterator().hasNext()) {
            claims.put("role", userDetails.getAuthorities().iterator().next().getAuthority());
        }
        return createToken(claims, userDetails.getUsername());
    }

    public String generateToken(String email) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("role", "ROLE_GUEST"); // Default role for email-based token generation
        return createToken(claims, email);
    }

    private String createToken(Map<String, Object> claims, String subject) {
        try {
            return Jwts.builder()
                    .setClaims(claims)
                    .setSubject(subject)
                    .setIssuedAt(new Date(System.currentTimeMillis()))
                    .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))
                    .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                    .compact();
        } catch (Exception e) {
            log.error("Error creating JWT token: {}", e.getMessage());
            throw new RuntimeException("Could not create JWT token", e);
        }
    }

    public Boolean validateToken(String token, UserDetails userDetails) {
        try {
            final String email = extractEmail(token);
            return (email.equals(userDetails.getUsername()) && !isTokenExpired(token));
        } catch (JwtException e) {
            log.error("JWT token validation failed: {}", e.getMessage());
            return false;
        }
    }

    public Boolean validateToken(String token, String email) {
        try {
            final String tokenEmail = extractEmail(token);
            return (tokenEmail.equals(email) && !isTokenExpired(token));
        } catch (JwtException e) {
            log.error("JWT token validation failed for email {}: {}", email, e.getMessage());
            return false;
        }
    }

    public Boolean isTokenValid(String token) {
        try {
            extractAllClaims(token);
            return !isTokenExpired(token);
        } catch (JwtException e) {
            log.debug("JWT token is invalid: {}", e.getMessage());
            return false;
        }
    }

    public Long getExpirationTime() {
        return expiration;
    }

    public String getRoleFromToken(String token) {
        try {
            Claims claims = extractAllClaims(token);
            return claims.get("role", String.class);
        } catch (JwtException e) {
            log.error("Error extracting role from token: {}", e.getMessage());
            return null;
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\util\QRCodeUtil.java ==== 
package com.example.stayops.util;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.EncodeHintType;
import com.google.zxing.WriterException;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.QRCodeWriter;
import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class QRCodeUtil {

    public static String generateGuestId(){
        return UUID.randomUUID().toString();
    }

    public static byte[] generateQRCodeImage(String text, int width, int height){
        try {
            // Add encoding hints for better QR code generation
            Map<EncodeHintType, Object> hints = new HashMap<>();
            hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);
            hints.put(EncodeHintType.CHARACTER_SET, "UTF-8");
            hints.put(EncodeHintType.MARGIN, 1);

            QRCodeWriter qrCodeWriter = new QRCodeWriter();
            BitMatrix bitMatrix = qrCodeWriter.encode(text, BarcodeFormat.QR_CODE, width, height, hints);

            BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
            for (int x = 0; x < width; x++){
                for (int y = 0; y < height; y++){
                    image.setRGB(x, y, bitMatrix.get(x, y) ? 0xFF000000 : 0xFFFFFFFF);
                }
            }

            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ImageIO.write(image, "PNG", baos);
            baos.flush();
            byte[] imageBytes = baos.toByteArray();
            baos.close();

            return imageBytes;
        } catch (WriterException | IOException e){
            throw new RuntimeException("Error generating QR code: " + e.getMessage(), e);
        }
    }
}==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\util\ServiceTypeMapper.java ==== 
package com.example.stayops.util;

import com.example.stayops.dto.ServiceTypeDTO;
import com.example.stayops.entity.ServiceType;
import org.springframework.stereotype.Component;

@Component
public class ServiceTypeMapper {

    public ServiceTypeDTO toDto(ServiceType entity) {
        if (entity == null) return null;
        return ServiceTypeDTO.builder()
                .id(entity.getId())
                .name(entity.getName())
                .code(entity.getCode())
                .defaultCharge(entity.getDefaultCharge())
                .description(entity.getDescription())
                .build();
    }

    public ServiceType toEntity(ServiceTypeDTO dto) {
        if (dto == null) return null;
        return ServiceType.builder()
                .id(dto.getId())
                .name(dto.getName())
                .code(dto.getCode())
                .defaultCharge(dto.getDefaultCharge())
                .description(dto.getDescription())
                .build();
    }
}
==== D:\Projects\StayOps\StayOps\backend\stayops\src\main\java\com\example\stayops\util\TestDataSeeder.java ==== 
package com.example.stayops.util;

import com.example.stayops.entity.PricingRule;
import com.example.stayops.repository.PricingRuleRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;

@Component
@Profile("dev") // Only run in dev profile
@RequiredArgsConstructor
@Slf4j
public class TestDataSeeder implements CommandLineRunner {

    private final PricingRuleRepository pricingRuleRepo;

    @Override
    public void run(String... args) {
        log.info("Seeding test data for automations...");

        // Seed pricing rules if empty
        if (pricingRuleRepo.count() == 0) {
            seedPricingRules();
        }

        log.info("Test data seeding completed");
    }

    private void seedPricingRules() {
        // Early Bird Discount (30+ days advance)
        pricingRuleRepo.save(PricingRule.builder()
                .ruleName("Early Bird Special - 30 Days")
                .ruleType("EARLY_BIRD")
                .isActive(true)
                .priority(1)
                .minDaysToArrival(30)
                .priceMultiplier(new BigDecimal("0.85")) // 15% discount
                .minPrice(new BigDecimal("10000")) // Floor: LKR 10,000
                .description("15% discount for bookings 30+ days in advance")
                .build());

        // Last Minute Premium
        pricingRuleRepo.save(PricingRule.builder()
                .ruleName("Last Minute Premium")
                .ruleType("LAST_MINUTE")
                .isActive(true)
                .priority(2)
                .maxDaysToArrival(3)
                .priceMultiplier(new BigDecimal("1.20")) // 20% increase
                .description("20% increase for bookings within 3 days")
                .build());

        // Weekend Premium
        pricingRuleRepo.save(PricingRule.builder()
                .ruleName("Weekend Premium")
                .ruleType("SEASONAL")
                .isActive(true)
                .priority(3)
                .dayOfWeek("FRIDAY")
                .priceMultiplier(new BigDecimal("1.15")) // 15% increase
                .description("15% increase for Friday-Sunday stays")
                .build());

        // High Occupancy Surge
        pricingRuleRepo.save(PricingRule.builder()
                .ruleName("High Demand Surge")
                .ruleType("OCCUPANCY_BASED")
                .isActive(true)
                .priority(4)
                .minOccupancyPercent(new BigDecimal("80"))
                .priceMultiplier(new BigDecimal("1.25")) // 25% increase
                .maxPrice(new BigDecimal("60000")) // Ceiling: LKR 60,000
                .description("25% surge when occupancy exceeds 80%")
                .build());

        // Festive Season (December)
        pricingRuleRepo.save(PricingRule.builder()
                .ruleName("December Festive Premium")
                .ruleType("SEASONAL")
                .isActive(true)
                .priority(5)
                .seasonStartDate(java.time.LocalDate.of(2024, 12, 1))
                .seasonEndDate(java.time.LocalDate.of(2024, 12, 31))
                .priceMultiplier(new BigDecimal("1.30")) // 30% increase
                .description("30% premium for December festive season")
                .build());

        log.info("Created 5 pricing rules");
    }
}